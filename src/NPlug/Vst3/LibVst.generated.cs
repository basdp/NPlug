//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace NPlug.Vst3;


using System.Runtime.InteropServices;

using System.Runtime.CompilerServices;

internal static partial class LibVst
{
    /// <summary>
    /// FUnknown
    /// The basic interface of all interfaces.
    /// </summary>
    /// <remarks>
    ///  pluginBase- The FUnknown::queryInterface method is used to retrieve pointers to other
    /// interfaces of the object.
    /// - FUnknown::addRef and FUnknown::release manage the lifetime of the object.
    /// If no more references exist, the object is destroyed in memory.Interfaces are identified by 16 byte Globally Unique Identifiers.
    /// The SDK provides a class called FUID for this purpose.@ref howtoClass
    /// </remarks>
    public unsafe partial struct FUnknown : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            vtbl[0] = (delegate*unmanaged<FUnknown*, Guid*, void**, ComResult>)&queryInterface_ccw;
            vtbl[1] = (delegate*unmanaged<FUnknown*, uint>)&addRef_ccw;
            vtbl[2] = (delegate*unmanaged<FUnknown*, uint>)&release_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.FUnknown*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.FUnknown*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.FUnknown*, uint>)Vtbl[1])((LibVst.FUnknown*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.FUnknown*, uint>)Vtbl[2])((LibVst.FUnknown*)Unsafe.AsPointer(ref this));
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [UnmanagedCallersOnly]
        private static partial ComResult queryInterface_ccw(FUnknown* self, Guid* _iid, void** obj);
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [UnmanagedCallersOnly]
        private static partial uint addRef_ccw(FUnknown* self);
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial uint release_ccw(FUnknown* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (FUnknown, 0x00000000, 0x00000000, 0xC0000000, 0x00000046)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x46, 0x00, 0x00, 0x00 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Base class for streams.
    /// </summary>
    /// <remarks>
    ///  pluginBase- read/write binary data from/to stream
    /// - get/set stream read-write position (read and write position is the same)
    /// </remarks>
    public unsafe partial struct IBStream : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IBStream*, void*, int, int*, ComResult>)&read_ccw;
            vtbl[4] = (delegate*unmanaged<IBStream*, void*, int, int*, ComResult>)&write_ccw;
            vtbl[5] = (delegate*unmanaged<IBStream*, long, int, long*, ComResult>)&seek_ccw;
            vtbl[6] = (delegate*unmanaged<IBStream*, long*, ComResult>)&tell_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IBStream*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IBStream*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IBStream*, uint>)Vtbl[1])((LibVst.IBStream*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IBStream*, uint>)Vtbl[2])((LibVst.IBStream*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Reads binary data from stream.
        /// </summary>
        /// <param name="buffer">: destination buffer</param>
        /// <param name="numBytes">: amount of bytes to be read</param>
        /// <param name="numBytesRead">: result - how many bytes have been read from stream (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult read(void* buffer, int numBytes, int* numBytesRead)
        {
            return ((delegate*unmanaged<LibVst.IBStream*, void*, int, int*, ComResult>)Vtbl[3])((LibVst.IBStream*)Unsafe.AsPointer(ref this), buffer, numBytes, numBytesRead);
        }
        
        /// <summary>
        /// Writes binary data to stream.
        /// </summary>
        /// <param name="buffer">: source buffer</param>
        /// <param name="numBytes">: amount of bytes to write</param>
        /// <param name="numBytesWritten">: result - how many bytes have been written to stream (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult write(void* buffer, int numBytes, int* numBytesWritten)
        {
            return ((delegate*unmanaged<LibVst.IBStream*, void*, int, int*, ComResult>)Vtbl[4])((LibVst.IBStream*)Unsafe.AsPointer(ref this), buffer, numBytes, numBytesWritten);
        }
        
        /// <summary>
        /// Sets stream read-write position.
        /// </summary>
        /// <param name="pos">: new stream position (dependent on mode)</param>
        /// <param name="mode">: value of enum IStreamSeekMode</param>
        /// <param name="result">: new seek position (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult seek(long pos, int mode, long* result)
        {
            return ((delegate*unmanaged<LibVst.IBStream*, long, int, long*, ComResult>)Vtbl[5])((LibVst.IBStream*)Unsafe.AsPointer(ref this), pos, mode, result);
        }
        
        /// <summary>
        /// Gets current stream read-write position.
        /// </summary>
        /// <param name="pos">: is assigned the current position if function succeeds</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult tell(long* pos)
        {
            return ((delegate*unmanaged<LibVst.IBStream*, long*, ComResult>)Vtbl[6])((LibVst.IBStream*)Unsafe.AsPointer(ref this), pos);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Reads binary data from stream.
        /// </summary>
        /// <param name="buffer">: destination buffer</param>
        /// <param name="numBytes">: amount of bytes to be read</param>
        /// <param name="numBytesRead">: result - how many bytes have been read from stream (set to 0 if this is of no interest)</param>
        [UnmanagedCallersOnly]
        private static partial ComResult read_ccw(IBStream* self, void* buffer, int numBytes, int* numBytesRead);
        
        /// <summary>
        /// Writes binary data to stream.
        /// </summary>
        /// <param name="buffer">: source buffer</param>
        /// <param name="numBytes">: amount of bytes to write</param>
        /// <param name="numBytesWritten">: result - how many bytes have been written to stream (set to 0 if this is of no interest)</param>
        [UnmanagedCallersOnly]
        private static partial ComResult write_ccw(IBStream* self, void* buffer, int numBytes, int* numBytesWritten);
        
        /// <summary>
        /// Sets stream read-write position.
        /// </summary>
        /// <param name="pos">: new stream position (dependent on mode)</param>
        /// <param name="mode">: value of enum IStreamSeekMode</param>
        /// <param name="result">: new seek position (set to 0 if this is of no interest)</param>
        [UnmanagedCallersOnly]
        private static partial ComResult seek_ccw(IBStream* self, long pos, int mode, long* result);
        
        /// <summary>
        /// Gets current stream read-write position.
        /// </summary>
        /// <param name="pos">: is assigned the current position if function succeeds</param>
        [UnmanagedCallersOnly]
        private static partial ComResult tell_ccw(IBStream* self, long* pos);
        
        public enum IStreamSeekMode
        {
            /// <summary>
            /// set absolute seek position
            /// </summary>
            kIBSeekSet = 0,
            
            /// <summary>
            /// set seek position relative to current position
            /// </summary>
            kIBSeekCur,
            
            /// <summary>
            /// set seek position relative to stream end
            /// </summary>
            kIBSeekEnd,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IBStream, 0xC3BF6EA2, 0x30994752, 0x9B6BF990, 0x1EE33E9B)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc3, 0xbf, 0x6e, 0xa2, 0x30, 0x99, 0x47, 0x52, 0x9b, 0x6b, 0xf9, 0x90, 0x1e, 0xe3, 0x3e, 0x9b })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa2, 0x6e, 0xbf, 0xc3, 0x52, 0x47, 0x99, 0x30, 0x90, 0xf9, 0x6b, 0x9b, 0x9b, 0x3e, 0xe3, 0x1e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Stream with a size.
    /// </summary>
    /// <remarks>
    ///  pluginBase[extends IBStream] when stream type supports it (like file and memory stream)
    /// </remarks>
    public unsafe partial struct ISizeableStream : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<ISizeableStream*, long*, ComResult>)&getStreamSize_ccw;
            vtbl[4] = (delegate*unmanaged<ISizeableStream*, long, ComResult>)&setStreamSize_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.ISizeableStream*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.ISizeableStream*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.ISizeableStream*, uint>)Vtbl[1])((LibVst.ISizeableStream*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.ISizeableStream*, uint>)Vtbl[2])((LibVst.ISizeableStream*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Return the stream size
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getStreamSize(long* size)
        {
            return ((delegate*unmanaged<LibVst.ISizeableStream*, long*, ComResult>)Vtbl[3])((LibVst.ISizeableStream*)Unsafe.AsPointer(ref this), size);
        }
        
        /// <summary>
        /// Set the steam size. File streams can only be resized if they are write enabled.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setStreamSize(long size)
        {
            return ((delegate*unmanaged<LibVst.ISizeableStream*, long, ComResult>)Vtbl[4])((LibVst.ISizeableStream*)Unsafe.AsPointer(ref this), size);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Return the stream size
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getStreamSize_ccw(ISizeableStream* self, long* size);
        
        /// <summary>
        /// Set the steam size. File streams can only be resized if they are write enabled.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setStreamSize_ccw(ISizeableStream* self, long size);
        
        /// <summary>
        /// DECLARE_CLASS_IID (ISizeableStream, 0x04F9549E, 0xE02F4E6E, 0x87E86A87, 0x47F4E17F)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x04, 0xf9, 0x54, 0x9e, 0xe0, 0x2f, 0x4e, 0x6e, 0x87, 0xe8, 0x6a, 0x87, 0x47, 0xf4, 0xe1, 0x7f })
                        : new ReadOnlySpan<byte>(new byte[] { 0x9e, 0x54, 0xf9, 0x04, 0x6e, 0x4e, 0x2f, 0xe0, 0x87, 0x6a, 0xe8, 0x87, 0x7f, 0xe1, 0xf4, 0x47 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Interface allowing an object to be copied.
    /// - [plug 
    /// &amp;
    /// host imp] 
    /// - [released: N4.12]
    /// </summary>
    public unsafe partial struct ICloneable : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<ICloneable*, LibVst.FUnknown*>)&clone_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.ICloneable*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.ICloneable*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.ICloneable*, uint>)Vtbl[1])((LibVst.ICloneable*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.ICloneable*, uint>)Vtbl[2])((LibVst.ICloneable*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Create exact copy of the object
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.FUnknown* clone()
        {
            return ((delegate*unmanaged<LibVst.ICloneable*, LibVst.FUnknown*>)Vtbl[3])((LibVst.ICloneable*)Unsafe.AsPointer(ref this));
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Create exact copy of the object
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.FUnknown* clone_ccw(ICloneable* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (ICloneable, 0xD45406B9, 0x3A2D4443, 0x9DAD9BA9, 0x85A1454B)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xd4, 0x54, 0x06, 0xb9, 0x3a, 0x2d, 0x44, 0x43, 0x9d, 0xad, 0x9b, 0xa9, 0x85, 0xa1, 0x45, 0x4b })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb9, 0x06, 0x54, 0xd4, 0x43, 0x44, 0x2d, 0x3a, 0xa9, 0x9b, 0xad, 0x9d, 0x4b, 0x45, 0xa1, 0x85 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Interface to a string of variable size and encoding. 
    /// - [host imp] or [plug imp]
    /// - [released: ]
    /// </summary>
    public unsafe partial struct IString : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 9;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IString*, byte*, void>)&setText8_ccw;
            vtbl[4] = (delegate*unmanaged<IString*, char*, void>)&setText16_ccw;
            vtbl[5] = (delegate*unmanaged<IString*, byte*>)&getText8_ccw;
            vtbl[6] = (delegate*unmanaged<IString*, char*>)&getText16_ccw;
            vtbl[7] = (delegate*unmanaged<IString*, void*, byte, void>)&take_ccw;
            vtbl[8] = (delegate*unmanaged<IString*, byte>)&isWideString_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IString*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IString*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IString*, uint>)Vtbl[1])((LibVst.IString*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IString*, uint>)Vtbl[2])((LibVst.IString*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Assign ASCII string
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setText8(byte* text)
        {
            ((delegate*unmanaged<LibVst.IString*, byte*, void>)Vtbl[3])((LibVst.IString*)Unsafe.AsPointer(ref this), text);
        }
        
        /// <summary>
        /// Assign unicode string
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setText16(char* text)
        {
            ((delegate*unmanaged<LibVst.IString*, char*, void>)Vtbl[4])((LibVst.IString*)Unsafe.AsPointer(ref this), text);
        }
        
        /// <summary>
        /// Return ASCII string. If the string is unicode so far, it will be converted.
        /// So you need to be careful, because the conversion can result in data loss. 
        /// It is save though to call getText8 if isWideString() returns false
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte* getText8()
        {
            return ((delegate*unmanaged<LibVst.IString*, byte*>)Vtbl[5])((LibVst.IString*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Return unicode string. If the string is ASCII so far, it will be converted.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public char* getText16()
        {
            return ((delegate*unmanaged<LibVst.IString*, char*>)Vtbl[6])((LibVst.IString*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// !Do not use this method! Early implementations take the given pointer as 
        /// internal string and this will cause problems because 'free' will be used to delete the passed memory.
        /// Later implementations will redirect 'take' to setText8 and setText16
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void take(void* s, [MarshalAs(UnmanagedType.U1)] byte isWide)
        {
            ((delegate*unmanaged<LibVst.IString*, void*, byte, void>)Vtbl[7])((LibVst.IString*)Unsafe.AsPointer(ref this), s, isWide);
        }
        
        /// <summary>
        /// Returns true if the string is in unicode format, returns false if the string is ASCII
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [return:MarshalAs(UnmanagedType.U1)]
        public byte isWideString()
        {
            return ((delegate*unmanaged<LibVst.IString*, byte>)Vtbl[8])((LibVst.IString*)Unsafe.AsPointer(ref this));
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Assign ASCII string
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void setText8_ccw(IString* self, byte* text);
        
        /// <summary>
        /// Assign unicode string
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void setText16_ccw(IString* self, char* text);
        
        /// <summary>
        /// Return ASCII string. If the string is unicode so far, it will be converted.
        /// So you need to be careful, because the conversion can result in data loss. 
        /// It is save though to call getText8 if isWideString() returns false
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial byte* getText8_ccw(IString* self);
        
        /// <summary>
        /// Return unicode string. If the string is ASCII so far, it will be converted.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial char* getText16_ccw(IString* self);
        
        /// <summary>
        /// !Do not use this method! Early implementations take the given pointer as 
        /// internal string and this will cause problems because 'free' will be used to delete the passed memory.
        /// Later implementations will redirect 'take' to setText8 and setText16
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void take_ccw(IString* self, void* s, [MarshalAs(UnmanagedType.U1)] byte isWide);
        
        /// <summary>
        /// Returns true if the string is in unicode format, returns false if the string is ASCII
        /// </summary>
        [UnmanagedCallersOnly]
        [return:MarshalAs(UnmanagedType.U1)]
        private static partial byte isWideString_ccw(IString* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IString, 0xF99DB7A3, 0x0FC14821, 0x800B0CF9, 0x8E348EDF)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf9, 0x9d, 0xb7, 0xa3, 0x0f, 0xc1, 0x48, 0x21, 0x80, 0x0b, 0x0c, 0xf9, 0x8e, 0x34, 0x8e, 0xdf })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa3, 0xb7, 0x9d, 0xf9, 0x21, 0x48, 0xc1, 0x0f, 0xf9, 0x0c, 0x0b, 0x80, 0xdf, 0x8e, 0x34, 0x8e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Interface for error handling. 
    /// - [plug imp]
    /// - [released: Sequel 2]
    /// </summary>
    public unsafe partial struct IErrorContext : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IErrorContext*, byte, void>)&disableErrorUI_ccw;
            vtbl[4] = (delegate*unmanaged<IErrorContext*, ComResult>)&errorMessageShown_ccw;
            vtbl[5] = (delegate*unmanaged<IErrorContext*, LibVst.IString*, ComResult>)&getErrorMessage_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Tells the plug-in to not show any UI elements on errors.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void disableErrorUI_ccw(IErrorContext* self, [MarshalAs(UnmanagedType.U1)] byte state);
        
        /// <summary>
        /// If an error happens and disableErrorUI was not set this should return kResultTrue if the plug-in already showed a message to the user what happened.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult errorMessageShown_ccw(IErrorContext* self);
        
        /// <summary>
        /// Fill message with error string. The host may show this to the user.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getErrorMessage_ccw(IErrorContext* self, LibVst.IString* message);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IErrorContext, 0x12BCD07B, 0x7C694336, 0xB7DA77C3, 0x444A0CD0)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x12, 0xbc, 0xd0, 0x7b, 0x7c, 0x69, 0x43, 0x36, 0xb7, 0xda, 0x77, 0xc3, 0x44, 0x4a, 0x0c, 0xd0 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x7b, 0xd0, 0xbc, 0x12, 0x36, 0x43, 0x69, 0x7c, 0xc3, 0x77, 0xda, 0xb7, 0xd0, 0x0c, 0x4a, 0x44 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Object Data Archive Interface. 
    /// - [host imp]
    /// </summary>
    /// <remarks>
    /// - store data/objects/binary/subattributes in the archive
    /// - read stored data from the archiveAll data stored to the archive are identified by a string (IAttrID), which must be unique on each
    /// IAttribute level.The basic set/get methods make use of the FVariant class defined in 'funknown.h'.
    /// For a more convenient usage of this interface, you should use the functions defined
    /// in namespace PAttributes (public.sdk/source/common/pattributes.h+cpp) !! frameworkHostClasses
    /// </remarks>
    public unsafe partial struct IAttributes : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, uint>)Vtbl[1])((LibVst.IAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, uint>)Vtbl[2])((LibVst.IAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        ///  Methods to write attributes*******************************************************************************************************@
        /// {
        /// Store any data in the archive. It is even possible to store sub-attributes by creating
        /// a new IAttributes instance via the IHostClasses interface and pass it to the parent in the
        /// FVariant. In this case the archive must take the ownership of the newly created object, which
        /// is true for all objects that have been created only for storing. You tell the archive to take
        /// ownership by adding the FVariant::kOwner flag to the FVariant::type member (data.type |= FVariant::kOwner).
        /// When using the PAttributes functions, this is done through a function parameter.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult set(LibVst.IAttrID attrID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[3])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data);
        }
        
        /// <summary>
        /// Store a list of data in the archive. Please note that the type of data is not mixable! So
        /// you can only store a list of integers or a list of doubles/strings/etc. You can also store a list
        /// of subattributes or other objects that implement the IPersistent interface.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queue(LibVst.IAttrID listID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[4])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), listID, data);
        }
        
        /// <summary>
        /// Store binary data in the archive. Parameter 'copyBytes' specifies if the passed data should be copied.
        /// The archive cannot take the ownership of binary data. Either it just references a buffer in order
        /// to write it to a file (copyBytes = false) or it copies the data to its own buffers (copyBytes = true).
        /// When binary data should be stored in the default pool for example, you must always copy it!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinaryData(LibVst.IAttrID attrID, void* data, uint bytes, [MarshalAs(UnmanagedType.U1)] byte copyBytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, void*, uint, byte, ComResult>)Vtbl[5])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data, bytes, copyBytes);
        }
        
        /// <remarks>
        ///  Methods to read attributes*******************************************************************************************************@
        /// {
        /// Get data previously stored to the archive.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult get(LibVst.IAttrID attrID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[6])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data);
        }
        
        /// <summary>
        /// Get list of data previously stored to the archive. As long as there are queue members the method
        /// will return kResultTrue. When the queue is empty, the methods returns kResultFalse. All lists except from
        /// object lists can be reset which means that the items can be read once again.
        /// </summary>
        /// <seealso cref="IAttributes::resetQueue "/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult unqueue(LibVst.IAttrID listID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[7])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), listID, data);
        }
        
        /// <summary>
        /// Get the amount of items in a queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getQueueItemCount(LibVst.IAttrID arg)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, int>)Vtbl[8])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), arg);
        }
        
        /// <summary>
        /// Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetQueue(LibVst.IAttrID attrID)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, ComResult>)Vtbl[9])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID);
        }
        
        /// <summary>
        /// Reset all queues in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetAllQueues()
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, ComResult>)Vtbl[10])((LibVst.IAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer
        /// must fit the size of data stored in the archive which can be queried via IAttributes::getBinaryDataSize
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinaryData(LibVst.IAttrID attrID, void* data, uint bytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, void*, uint, ComResult>)Vtbl[11])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data, bytes);
        }
        
        /// <summary>
        /// Get the size in bytes of binary data in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getBinaryDataSize(LibVst.IAttrID attrID)
        {
            return ((delegate*unmanaged<LibVst.IAttributes*, LibVst.IAttrID, uint>)Vtbl[12])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributes, 0xFA1E32F9, 0xCA6D46F5, 0xA982F956, 0xB1191B58)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xfa, 0x1e, 0x32, 0xf9, 0xca, 0x6d, 0x46, 0xf5, 0xa9, 0x82, 0xf9, 0x56, 0xb1, 0x19, 0x1b, 0x58 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xf9, 0x32, 0x1e, 0xfa, 0xf5, 0x46, 0x6d, 0xca, 0x56, 0xf9, 0x82, 0xa9, 0x58, 0x1b, 0x19, 0xb1 })
                    )));
            }
        }
    }
    
    public unsafe partial struct FIDString
    {
        public byte* Value;
    }
    
    public partial record struct IAttrID(LibVst.FIDString Value);
    
    /// <summary>
    /// FVariant struct declaration
    /// A Value of variable type.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct FVariant
    {
        /// <summary>
        /// 
        /// </summary>
        public ushort type;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            [FieldOffset(0)]
            public long intValue;
            
            [FieldOffset(0)]
            public double floatValue;
            
            [FieldOffset(0)]
            public byte* string8;
            
            [FieldOffset(0)]
            public char* string16;
            
            [FieldOffset(0)]
            public LibVst.FUnknown* @object;
        }
        
        public LibVst.FVariant.Union union;
    }
    
    /// <summary>
    /// Persistent Object Interface. 
    /// [plug imp] @n This interface is used to store/restore attributes of an object.
    /// An IPlugController can implement this interface to handle presets.
    /// The gui-xml for a preset control looks like this:
    /// </summary>
    /// <remarks>
    /// @code ....
    /// &lt;view name="PresetView" data="Preset"/&gt;
    /// ....
    /// &lt;template name="PresetView"&gt;
    /// 	&lt;view name="preset control" size="0, 0, 100, 20"/&gt;
    /// 	&lt;switch name="store preset" size="125,0,80,20" style="push|immediate" title="Store"  /&gt;
    /// 	&lt;switch name="remove preset" size="220,0,80,20" style="push|immediate" title="Delete"  /&gt;
    /// &lt;/template&gt;
    /// @endcodeThe tag data="Preset" tells the host to create a preset controller that handles the 
    /// 3 values named "preset control",  "store preset", and "remove preset".
    /// </remarks>
    public unsafe partial struct IPersistent : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPersistent*, byte*, ComResult>)&getClassID_ccw;
            vtbl[4] = (delegate*unmanaged<IPersistent*, LibVst.IAttributes*, ComResult>)&saveAttributes_ccw;
            vtbl[5] = (delegate*unmanaged<IPersistent*, LibVst.IAttributes*, ComResult>)&loadAttributes_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// The class ID must be a 16 bytes unique id that is used to create the object. 
        /// This ID is also used to identify the preset list when used with presets.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getClassID_ccw(IPersistent* self, byte* uid);
        
        /// <summary>
        /// Store all members/data in the passed IAttributes.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult saveAttributes_ccw(IPersistent* self, LibVst.IAttributes* arg);
        
        /// <summary>
        /// Restore all members/data from the passed IAttributes.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult loadAttributes_ccw(IPersistent* self, LibVst.IAttributes* arg);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPersistent, 0xBA1A4637, 0x3C9F46D0, 0xA65DBA0E, 0xB85DA829)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xba, 0x1a, 0x46, 0x37, 0x3c, 0x9f, 0x46, 0xd0, 0xa6, 0x5d, 0xba, 0x0e, 0xb8, 0x5d, 0xa8, 0x29 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x37, 0x46, 0x1a, 0xba, 0xd0, 0x46, 0x9f, 0x3c, 0x0e, 0xba, 0x5d, 0xa6, 0x29, 0xa8, 0x5d, 0xb8 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended access to Attributes; supports Attribute retrieval via iteration. 
    /// - [host imp]
    /// - [released] C7/N6
    /// </summary>
    /// <remarks>
    ///  frameworkHostClasses
    /// </remarks>
    public unsafe partial struct IAttributes2 : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, uint>)Vtbl[1])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, uint>)Vtbl[2])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        ///  Methods to write attributes*******************************************************************************************************@
        /// {
        /// Store any data in the archive. It is even possible to store sub-attributes by creating
        /// a new IAttributes instance via the IHostClasses interface and pass it to the parent in the
        /// FVariant. In this case the archive must take the ownership of the newly created object, which
        /// is true for all objects that have been created only for storing. You tell the archive to take
        /// ownership by adding the FVariant::kOwner flag to the FVariant::type member (data.type |= FVariant::kOwner).
        /// When using the PAttributes functions, this is done through a function parameter.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult set(LibVst.IAttrID attrID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[3])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID, data);
        }
        
        /// <summary>
        /// Store a list of data in the archive. Please note that the type of data is not mixable! So
        /// you can only store a list of integers or a list of doubles/strings/etc. You can also store a list
        /// of subattributes or other objects that implement the IPersistent interface.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queue(LibVst.IAttrID listID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[4])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), listID, data);
        }
        
        /// <summary>
        /// Store binary data in the archive. Parameter 'copyBytes' specifies if the passed data should be copied.
        /// The archive cannot take the ownership of binary data. Either it just references a buffer in order
        /// to write it to a file (copyBytes = false) or it copies the data to its own buffers (copyBytes = true).
        /// When binary data should be stored in the default pool for example, you must always copy it!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinaryData(LibVst.IAttrID attrID, void* data, uint bytes, [MarshalAs(UnmanagedType.U1)] byte copyBytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, void*, uint, byte, ComResult>)Vtbl[5])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID, data, bytes, copyBytes);
        }
        
        /// <remarks>
        ///  Methods to read attributes*******************************************************************************************************@
        /// {
        /// Get data previously stored to the archive.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult get(LibVst.IAttrID attrID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[6])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID, data);
        }
        
        /// <summary>
        /// Get list of data previously stored to the archive. As long as there are queue members the method
        /// will return kResultTrue. When the queue is empty, the methods returns kResultFalse. All lists except from
        /// object lists can be reset which means that the items can be read once again.
        /// </summary>
        /// <seealso cref="IAttributes::resetQueue "/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult unqueue(LibVst.IAttrID listID, LibVst.FVariant* data)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, LibVst.FVariant*, ComResult>)Vtbl[7])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), listID, data);
        }
        
        /// <summary>
        /// Get the amount of items in a queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getQueueItemCount(LibVst.IAttrID arg)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, int>)Vtbl[8])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), arg);
        }
        
        /// <summary>
        /// Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetQueue(LibVst.IAttrID attrID)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, ComResult>)Vtbl[9])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID);
        }
        
        /// <summary>
        /// Reset all queues in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetAllQueues()
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, ComResult>)Vtbl[10])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer
        /// must fit the size of data stored in the archive which can be queried via IAttributes::getBinaryDataSize
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinaryData(LibVst.IAttrID attrID, void* data, uint bytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, void*, uint, ComResult>)Vtbl[11])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID, data, bytes);
        }
        
        /// <summary>
        /// Get the size in bytes of binary data in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getBinaryDataSize(LibVst.IAttrID attrID)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, LibVst.IAttrID, uint>)Vtbl[12])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), attrID);
        }
        
        /// <summary>
        /// Returns the number of existing attributes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countAttributes()
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, int>)Vtbl[13])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns the attribute's ID for the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IAttrID getAttributeID(int index)
        {
            return ((delegate*unmanaged<LibVst.IAttributes2*, int, LibVst.IAttrID>)Vtbl[14])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), index);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributes2, 0x1382126A, 0xFECA4871, 0x97D52A45, 0xB042AE99)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x13, 0x82, 0x12, 0x6a, 0xfe, 0xca, 0x48, 0x71, 0x97, 0xd5, 0x2a, 0x45, 0xb0, 0x42, 0xae, 0x99 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6a, 0x12, 0x82, 0x13, 0x71, 0x48, 0xca, 0xfe, 0x45, 0x2a, 0xd5, 0x97, 0x99, 0xae, 0x42, 0xb0 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic interface to a plug-in component: IPluginBase
    /// </summary>
    /// <remarks>
    ///  pluginBase- [plug imp]
    /// - initialize/terminate the plug-in componentThe host uses this interface to initialize and to terminate the plug-in component.
    /// The context that is passed to the initialize method contains any interface to the
    /// host that the plug-in will need to work. These interfaces can vary from category to category.
    /// A list of supported host context interfaces should be included in the documentation
    /// of a specific category.
    /// </remarks>
    public unsafe partial struct IPluginBase : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 2;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPluginBase*, LibVst.FUnknown*, ComResult>)&initialize_ccw;
            vtbl[4] = (delegate*unmanaged<IPluginBase*, ComResult>)&terminate_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// The host passes a number of interfaces as context to initialize the plug-in class.
        /// </summary>
        /// <param name="context,">passed by the host, is mandatory and should implement IHostApplication</param>
        /// <note>
        /// Extensive memory allocations etc. should be performed in this method rather than in
        /// the class' constructor! If the method does NOT return kResultOk, the object is released
        /// immediately. In this case terminate is not called!
        /// </note>
        [UnmanagedCallersOnly]
        private static partial ComResult initialize_ccw(IPluginBase* self, LibVst.FUnknown* context);
        
        /// <summary>
        /// This function is called before the plug-in is unloaded and can be used for
        /// cleanups. You have to release all references to any host application interfaces.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult terminate_ccw(IPluginBase* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginBase, 0x22888DDB, 0x156E45AE, 0x8358B348, 0x08190625)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x22, 0x88, 0x8d, 0xdb, 0x15, 0x6e, 0x45, 0xae, 0x83, 0x58, 0xb3, 0x48, 0x08, 0x19, 0x06, 0x25 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xdb, 0x8d, 0x88, 0x22, 0xae, 0x45, 0x6e, 0x15, 0x48, 0xb3, 0x58, 0x83, 0x25, 0x06, 0x19, 0x08 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IPluginFactory interface declaration
    /// Class factory that any plug-in defines for creating class instances: IPluginFactory
    /// </summary>
    /// <remarks>
    ///  pluginBase- [plug imp]From the host's point of view a plug-in module is a factory which can create
    /// a certain kind of object(s). The interface IPluginFactory provides methods
    /// to get information about the classes exported by the plug-in and a
    /// mechanism to create instances of these classes (that usually define the IPluginBase interface).&lt;b&gt;An implementation is provided in public.sdk/source/common/pluginfactory.cpp &lt;/b&gt;
    /// </remarks>
    /// <seealso cref="GetPluginFactory"/>
    public unsafe partial struct IPluginFactory : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPluginFactory*, LibVst.PFactoryInfo*, ComResult>)&getFactoryInfo_ccw;
            vtbl[4] = (delegate*unmanaged<IPluginFactory*, int>)&countClasses_ccw;
            vtbl[5] = (delegate*unmanaged<IPluginFactory*, int, LibVst.PClassInfo*, ComResult>)&getClassInfo_ccw;
            vtbl[6] = (delegate*unmanaged<IPluginFactory*, LibVst.FIDString, LibVst.FIDString, void**, ComResult>)&createInstance_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getFactoryInfo_ccw(IPluginFactory* self, LibVst.PFactoryInfo* info);
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int countClasses_ccw(IPluginFactory* self);
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getClassInfo_ccw(IPluginFactory* self, int index, LibVst.PClassInfo* info);
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult createInstance_ccw(IPluginFactory* self, LibVst.FIDString cid, LibVst.FIDString _iid, void** obj);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory, 0x7A4D811C, 0x52114A1F, 0xAED9D2EE, 0x0B43BF9F)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x7a, 0x4d, 0x81, 0x1c, 0x52, 0x11, 0x4a, 0x1f, 0xae, 0xd9, 0xd2, 0xee, 0x0b, 0x43, 0xbf, 0x9f })
                        : new ReadOnlySpan<byte>(new byte[] { 0x1c, 0x81, 0x4d, 0x7a, 0x1f, 0x4a, 0x11, 0x52, 0xee, 0xd2, 0xd9, 0xae, 0x9f, 0xbf, 0x43, 0x0b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic Information about the class factory of the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PFactoryInfo
    {
        /// <summary>
        /// e.g. "Steinberg Media Technologies"
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// e.g. "http://www.steinberg.de"
        /// </summary>
        public fixed byte url[256];
        
        /// <summary>
        /// e.g. "info@steinberg.de"
        /// </summary>
        public fixed byte email[128];
        
        /// <summary>
        /// (see FactoryFlags above)
        /// </summary>
        public int flags;
        
        /// <summary>
        /// 
        /// </summary>
        public enum FactoryFlags
        {
            /// <summary>
            /// Nothing
            /// </summary>
            kNoFlags = 0,
            
            /// <summary>
            /// The number of exported classes can change each time the Module is loaded. If this flag
            /// is set, the host does not cache class information. This leads to a longer startup time
            /// because the host always has to load the Module to get the current class information.
            /// </summary>
            kClassesDiscardable = 1 << 0,
            
            /// <summary>
            /// This flag is deprecated, do not use anymore, resp. it will get ignored from
            /// Cubase/Nuendo 12 and later.
            /// </summary>
            kLicenseCheck = 1 << 1,
            
            /// <summary>
            /// Component will not be unloaded until process exit
            /// </summary>
            kComponentNonDiscardable = 1 << 3,
            
            /// <summary>
            /// Components have entirely unicode encoded strings (True for VST 3 plug-ins so far).
            /// </summary>
            kUnicode = 1 << 4,
        }
    }
    
    /// <summary>
    /// Basic Information about a class provided by the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PClassInfo
    {
        /// <summary>
        /// Class ID 16 Byte class GUID
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// Cardinality of the class, set to kManyInstances (see @ref PClassInfo::ClassCardinality)
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// Class category, host uses this to categorize interfaces
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// Class name, visible to the user
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// 
        /// </summary>
        public enum ClassCardinality
        {
            kManyInstances = 0x7FFFFFFF,
        }
    }
    
    /// <summary>
    /// IPluginFactory2 interface declaration
    /// Version 2 of class factory supporting PClassInfo2: IPluginFactory2
    /// </summary>
    /// <remarks>
    ///  pluginBase@copydoc IPluginFactory
    /// </remarks>
    public unsafe partial struct IPluginFactory2 : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginFactory.InitializeVtbl(vtbl);
            vtbl[7] = (delegate*unmanaged<IPluginFactory2*, int, LibVst.PClassInfo2*, ComResult>)&getClassInfo2_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, uint>)Vtbl[1])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, uint>)Vtbl[2])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFactoryInfo(LibVst.PFactoryInfo* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, LibVst.PFactoryInfo*, ComResult>)Vtbl[3])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), info);
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countClasses()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, int>)Vtbl[4])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo(int index, LibVst.PClassInfo* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, int, LibVst.PClassInfo*, ComResult>)Vtbl[5])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), index, info);
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(LibVst.FIDString cid, LibVst.FIDString _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, LibVst.FIDString, LibVst.FIDString, void**, ComResult>)Vtbl[6])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), cid, _iid, obj);
        }
        
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo2(int index, LibVst.PClassInfo2* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory2*, int, LibVst.PClassInfo2*, ComResult>)Vtbl[7])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), index, info);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getClassInfo2_ccw(IPluginFactory2* self, int index, LibVst.PClassInfo2* info);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory2, 0x0007B650, 0xF24B4C0B, 0xA464EDB9, 0xF00B2ABB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x00, 0x07, 0xb6, 0x50, 0xf2, 0x4b, 0x4c, 0x0b, 0xa4, 0x64, 0xed, 0xb9, 0xf0, 0x0b, 0x2a, 0xbb })
                        : new ReadOnlySpan<byte>(new byte[] { 0x50, 0xb6, 0x07, 0x00, 0x0b, 0x4c, 0x4b, 0xf2, 0xb9, 0xed, 0x64, 0xa4, 0xbb, 0x2a, 0x0b, 0xf0 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Version 2 of Basic Information about a class provided by the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PClassInfo2
    {
        /// <summary>
        /// Class ID 16 Byte class GUID
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// Cardinality of the class, set to kManyInstances (see @ref PClassInfo::ClassCardinality)
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// Class category, host uses this to categorize interfaces
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// Class name, visible to the user
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// flags used for a specific category, must be defined where category is defined
        /// </summary>
        public uint classFlags;
        
        /// <summary>
        /// module specific subcategories, can be more than one, logically added by the OR operator
        /// </summary>
        public fixed byte subCategories[128];
        
        /// <summary>
        /// overwrite vendor information from factory info
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// Version string (e.g. "1.0.0.512" with Major.Minor.Subversion.Build)
        /// </summary>
        public fixed byte version[64];
        
        /// <summary>
        /// SDK version used to build this class (e.g. "VST 3.0")
        /// </summary>
        public fixed byte sdkVersion[64];
    }
    
    /// <summary>
    /// IPluginFactory3 interface declaration
    /// Version 3 of class factory supporting PClassInfoW: IPluginFactory3
    /// </summary>
    /// <remarks>
    ///  pluginBase@copydoc IPluginFactory
    /// </remarks>
    public unsafe partial struct IPluginFactory3 : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 10;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginFactory2.InitializeVtbl(vtbl);
            vtbl[8] = (delegate*unmanaged<IPluginFactory3*, int, LibVst.PClassInfoW*, ComResult>)&getClassInfoUnicode_ccw;
            vtbl[9] = (delegate*unmanaged<IPluginFactory3*, LibVst.FUnknown*, ComResult>)&setHostContext_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, uint>)Vtbl[1])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, uint>)Vtbl[2])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFactoryInfo(LibVst.PFactoryInfo* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, LibVst.PFactoryInfo*, ComResult>)Vtbl[3])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), info);
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countClasses()
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, int>)Vtbl[4])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo(int index, LibVst.PClassInfo* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, int, LibVst.PClassInfo*, ComResult>)Vtbl[5])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), index, info);
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(LibVst.FIDString cid, LibVst.FIDString _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, LibVst.FIDString, LibVst.FIDString, void**, ComResult>)Vtbl[6])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), cid, _iid, obj);
        }
        
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo2(int index, LibVst.PClassInfo2* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, int, LibVst.PClassInfo2*, ComResult>)Vtbl[7])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), index, info);
        }
        
        /// <summary>
        /// Returns the unicode class info for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfoUnicode(int index, LibVst.PClassInfoW* info)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, int, LibVst.PClassInfoW*, ComResult>)Vtbl[8])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), index, info);
        }
        
        /// <summary>
        /// Receives information about host
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setHostContext(LibVst.FUnknown* context)
        {
            return ((delegate*unmanaged<LibVst.IPluginFactory3*, LibVst.FUnknown*, ComResult>)Vtbl[9])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), context);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the unicode class info for a given index.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getClassInfoUnicode_ccw(IPluginFactory3* self, int index, LibVst.PClassInfoW* info);
        
        /// <summary>
        /// Receives information about host
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setHostContext_ccw(IPluginFactory3* self, LibVst.FUnknown* context);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory3, 0x4555A2AB, 0xC1234E57, 0x9B122910, 0x36878931)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x45, 0x55, 0xa2, 0xab, 0xc1, 0x23, 0x4e, 0x57, 0x9b, 0x12, 0x29, 0x10, 0x36, 0x87, 0x89, 0x31 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xab, 0xa2, 0x55, 0x45, 0x57, 0x4e, 0x23, 0xc1, 0x10, 0x29, 0x12, 0x9b, 0x31, 0x89, 0x87, 0x36 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Unicode Version of Basic Information about a class provided by the plug-in
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PClassInfoW
    {
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public fixed char name[64];
        
        /// <summary>
        /// flags used for a specific category, must be defined where category is defined
        /// </summary>
        public uint classFlags;
        
        /// <summary>
        /// module specific subcategories, can be more than one, logically added by the OR operator
        /// </summary>
        public fixed byte subCategories[128];
        
        /// <summary>
        /// overwrite vendor information from factory info
        /// </summary>
        public fixed char vendor[64];
        
        /// <summary>
        /// Version string (e.g. "1.0.0.512" with Major.Minor.Subversion.Build)
        /// </summary>
        public fixed char version[64];
        
        /// <summary>
        /// SDK version used to build this class (e.g. "VST 3.0")
        /// </summary>
        public fixed char sdkVersion[64];
    }
    
    /// <summary>
    /// optional interface to query the compatibility of the plug-ins classes
    /// - [plug imp]
    /// </summary>
    /// <remarks>
    /// A plug-in can add a class with this interface to its class factory if it cannot provide a
    /// moduleinfo.json file in its plug-in package/bundle where the compatibility is normally part of.If the module contains a moduleinfo.json the host will ignore this class.The class must write into the stream an UTF-8 encoded json description of the compatibility of
    /// the other classes in the factory.It is expected that the JSON5 written starts with an array:@code [
    ///     {
    /// 		"New": "B9F9ADE1CD9C4B6DA57E61E3123535FD",
    /// 		"Old": [
    /// 		  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", // just an example
    /// 		  "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB", // another example
    /// 		],
    /// 	},
    /// ]
    /// @endcode
    /// </remarks>
    public unsafe partial struct IPluginCompatibility : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPluginCompatibility*, LibVst.IBStream*, ComResult>)&getCompatibilityJSON_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the compatibility stream
        /// </summary>
        /// <param name="stream">the stream the plug-in must write the UTF8 encoded JSON5 compatibility
        /// string.</param>
        /// <returns>kResultTrue on success</returns>
        [UnmanagedCallersOnly]
        private static partial ComResult getCompatibilityJSON_ccw(IPluginCompatibility* self, LibVst.IBStream* stream);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginCompatibility, 0x4AFD4B6A, 0x35D7C240, 0xA5C31414, 0xFB7D15E6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x4a, 0xfd, 0x4b, 0x6a, 0x35, 0xd7, 0xc2, 0x40, 0xa5, 0xc3, 0x14, 0x14, 0xfb, 0x7d, 0x15, 0xe6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6a, 0x4b, 0xfd, 0x4a, 0x40, 0xc2, 0xd7, 0x35, 0x14, 0x14, 0xc3, 0xa5, 0xe6, 0x15, 0x7d, 0xfb })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Interface to return an ascii string of variable size. 
    /// In order to manage memory allocation and deallocation properly, 
    /// this interface is used to transfer a string as result parameter of
    /// a method requires a string of unknown size. 
    /// - [host imp] or [plug imp]
    /// - [released: SX 4]
    /// </summary>
    public unsafe partial struct IStringResult : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IStringResult*, byte*, void>)&setText_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IStringResult*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IStringResult*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IStringResult*, uint>)Vtbl[1])((LibVst.IStringResult*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IStringResult*, uint>)Vtbl[2])((LibVst.IStringResult*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// 
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setText(byte* text)
        {
            ((delegate*unmanaged<LibVst.IStringResult*, byte*, void>)Vtbl[3])((LibVst.IStringResult*)Unsafe.AsPointer(ref this), text);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// 
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void setText_ccw(IStringResult* self, byte* text);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IStringResult, 0x550798BC, 0x872049DB, 0x84920A15, 0x3B50B7A8)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x55, 0x07, 0x98, 0xbc, 0x87, 0x20, 0x49, 0xdb, 0x84, 0x92, 0x0a, 0x15, 0x3b, 0x50, 0xb7, 0xa8 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xbc, 0x98, 0x07, 0x55, 0xdb, 0x49, 0x20, 0x87, 0x15, 0x0a, 0x92, 0x84, 0xa8, 0xb7, 0x50, 0x3b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// A dependent will get notified about changes of a model.
    /// [plug imp]
    /// - notify changes of a model
    /// </summary>
    /// <remarks>
    ///  frameworkHostClasses
    /// </remarks>
    /// <seealso cref="IUpdateHandler"/>
    public unsafe partial struct IDependent : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IDependent*, LibVst.FUnknown*, int, void>)&update_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Inform the dependent, that the passed FUnknown has changed.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial void update_ccw(IDependent* self, LibVst.FUnknown* changedUnknown, int message);
        
        public enum ChangeMessage
        {
            kWillChange,
            
            kChanged,
            
            kDestroyed,
            
            kWillDestroy,
            
            kStdChangeMessageLast = kWillDestroy,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IDependent, 0xF52B7AAE, 0xDE72416d, 0x8AF18ACE, 0x9DD7BD5E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf5, 0x2b, 0x7a, 0xae, 0xde, 0x72, 0x41, 0x6d, 0x8a, 0xf1, 0x8a, 0xce, 0x9d, 0xd7, 0xbd, 0x5e })
                        : new ReadOnlySpan<byte>(new byte[] { 0xae, 0x7a, 0x2b, 0xf5, 0x6d, 0x41, 0x72, 0xde, 0xce, 0x8a, 0xf1, 0x8a, 0x5e, 0xbd, 0xd7, 0x9d })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Host implements dependency handling for plugins.
    /// - [host imp]
    /// - [get this interface from IHostClasses]
    /// - [released N3.1]
    /// </summary>
    /// <remarks>
    /// - Install/Remove change notifications
    /// - Trigger updates when an object has changedCan be used between host-objects and the Plug-In or 
    /// inside the Plug-In to handle internal updates! frameworkHostClasses
    /// </remarks>
    /// <seealso cref="IDependent"/>
    public unsafe partial struct IUpdateHandler : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, uint>)Vtbl[1])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, uint>)Vtbl[2])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Install update notification for given object. It is essential to
        /// remove all dependencies again using 'removeDependent'! Dependencies
        /// are not removed automatically when the 'object' is released!
        /// </summary>
        /// <param name="dependent">: interface through which the update is passed</param>
        /// <param name="object">: interface to object that sends change notifications</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addDependent(LibVst.FUnknown* @object, LibVst.IDependent* dependent)
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, LibVst.FUnknown*, LibVst.IDependent*, ComResult>)Vtbl[3])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this), @object, dependent);
        }
        
        /// <summary>
        /// Remove a previously installed dependency.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult removeDependent(LibVst.FUnknown* @object, LibVst.IDependent* dependent)
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, LibVst.FUnknown*, LibVst.IDependent*, ComResult>)Vtbl[4])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this), @object, dependent);
        }
        
        /// <summary>
        /// Inform all dependents, that object has changed.
        /// </summary>
        /// <param name="message">is a value of enum IDependent::ChangeMessage, usually  IDependent::kChanged - can be
        /// a private message as well (only known to sender and dependent)</param>
        /// <param name="object">is the object that has changed</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult triggerUpdates(LibVst.FUnknown* @object, int message)
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, LibVst.FUnknown*, int, ComResult>)Vtbl[5])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this), @object, message);
        }
        
        /// <summary>
        /// Same as triggerUpdates, but delivered in idle (usefull to collect updates).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult deferUpdates(LibVst.FUnknown* @object, int message)
        {
            return ((delegate*unmanaged<LibVst.IUpdateHandler*, LibVst.FUnknown*, int, ComResult>)Vtbl[6])((LibVst.IUpdateHandler*)Unsafe.AsPointer(ref this), @object, message);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUpdateHandler, 0xF5246D56, 0x86544d60, 0xB026AFB5, 0x7B697B37)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf5, 0x24, 0x6d, 0x56, 0x86, 0x54, 0x4d, 0x60, 0xb0, 0x26, 0xaf, 0xb5, 0x7b, 0x69, 0x7b, 0x37 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x56, 0x6d, 0x24, 0xf5, 0x60, 0x4d, 0x54, 0x86, 0xb5, 0xaf, 0x26, 0xb0, 0x37, 0x7b, 0x69, 0x7b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Callback interface passed to IPlugView.
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]Enables a plug-in to resize the view and cause the host to resize the window.
    /// </remarks>
    public unsafe partial struct IPlugFrame : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPlugFrame*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IPlugFrame*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IPlugFrame*, uint>)Vtbl[1])((LibVst.IPlugFrame*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IPlugFrame*, uint>)Vtbl[2])((LibVst.IPlugFrame*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Called to inform the host about the resize of a given view.
        /// Afterwards the host has to call IPlugView::onSize ().
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resizeView(LibVst.IPlugView* view, LibVst.ViewRect* newSize)
        {
            return ((delegate*unmanaged<LibVst.IPlugFrame*, LibVst.IPlugView*, LibVst.ViewRect*, ComResult>)Vtbl[3])((LibVst.IPlugFrame*)Unsafe.AsPointer(ref this), view, newSize);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugFrame, 0x367FAF01, 0xAFA94693, 0x8D4DA2A0, 0xED0882A3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x36, 0x7f, 0xaf, 0x01, 0xaf, 0xa9, 0x46, 0x93, 0x8d, 0x4d, 0xa2, 0xa0, 0xed, 0x08, 0x82, 0xa3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x01, 0xaf, 0x7f, 0x36, 0x93, 0x46, 0xa9, 0xaf, 0xa0, 0xa2, 0x4d, 0x8d, 0xa3, 0x82, 0x08, 0xed })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Plug-in definition of a view.
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// </remarks>
    /// <seealso cref="platformUITypeIPlugFrame, "/>
    /// <par>
    /// Sizing of a view
    /// Usually, the size of a plug-in view is fixed. But both the host and the plug-in can cause
    /// a view to be resized:@n - @b Host: If IPlugView::canResize () returns kResultTrue the host will set up the window
    /// so that the user can resize it. While the user resizes the window,
    /// IPlugView::checkSizeConstraint () is called, allowing the plug-in to change the size to a valid
    /// a valid supported rectangle size. The host then resizes the window to this rect and has to call IPlugView::onSize ().@n @n - @b Plug-in: The plug-in can call IPlugFrame::resizeView () and cause the host to resize the
    /// window.@n @n Afterwards, in the same callstack, the host has to call IPlugView::onSize () if a resize is needed (size was changed).
    /// Note that if the host calls IPlugView::getSize () before calling IPlugView::onSize () (if needed),
    /// it will get the current (old) size not the wanted one!!@n Here the calling sequence:@n - plug-in-&gt;host: IPlugFrame::resizeView (newSize)
    /// - host-&gt;plug-in (optional): IPlugView::getSize () returns the currentSize (not the newSize!)
    /// - host-&gt;plug-in: if newSize is different from the current size: IPlugView::onSize (newSize)
    /// - host-&gt;plug-in (optional): IPlugView::getSize () returns the newSize@n &lt;b&gt;Please only resize the platform representation of the view when IPlugView::onSize () is
    /// called.&lt;/b&gt;
    /// </par>
    /// <par>
    /// Keyboard handling
    /// The plug-in view receives keyboard events from the host. A view implementation must not handle
    /// keyboard events by the means of platform callbacks, but let the host pass them to the view. The host
    /// depends on a proper return value when IPlugView::onKeyDown is called, otherwise the plug-in view may
    /// cause a malfunction of the host's key command handling.
    /// </par>
    public unsafe partial struct IPlugView : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 12;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPlugView*, LibVst.FIDString, ComResult>)&isPlatformTypeSupported_ccw;
            vtbl[4] = (delegate*unmanaged<IPlugView*, void*, LibVst.FIDString, ComResult>)&attached_ccw;
            vtbl[5] = (delegate*unmanaged<IPlugView*, ComResult>)&removed_ccw;
            vtbl[6] = (delegate*unmanaged<IPlugView*, float, ComResult>)&onWheel_ccw;
            vtbl[7] = (delegate*unmanaged<IPlugView*, ushort, short, short, ComResult>)&onKeyDown_ccw;
            vtbl[8] = (delegate*unmanaged<IPlugView*, ushort, short, short, ComResult>)&onKeyUp_ccw;
            vtbl[9] = (delegate*unmanaged<IPlugView*, LibVst.ViewRect*, ComResult>)&getSize_ccw;
            vtbl[10] = (delegate*unmanaged<IPlugView*, LibVst.ViewRect*, ComResult>)&onSize_ccw;
            vtbl[11] = (delegate*unmanaged<IPlugView*, byte, ComResult>)&onFocus_ccw;
            vtbl[12] = (delegate*unmanaged<IPlugView*, LibVst.IPlugFrame*, ComResult>)&setFrame_ccw;
            vtbl[13] = (delegate*unmanaged<IPlugView*, ComResult>)&canResize_ccw;
            vtbl[14] = (delegate*unmanaged<IPlugView*, LibVst.ViewRect*, ComResult>)&checkSizeConstraint_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Is Platform UI Type supported
        /// </summary>
        /// <param name="type">: IDString of @ref platformUIType</param>
        [UnmanagedCallersOnly]
        private static partial ComResult isPlatformTypeSupported_ccw(IPlugView* self, LibVst.FIDString type);
        
        /// <summary>
        /// The parent window of the view has been created, the (platform) representation of the view
        /// should now be created as well.
        /// Note that the parent is owned by the caller and you are not allowed to alter it in any way
        /// other than adding your own views.
        /// Note that in this call the plug-in could call a IPlugFrame::resizeView ()!
        /// </summary>
        /// <param name="type">: @ref platformUIType which should be created</param>
        /// <param name="parent">: platform handle of the parent window or view</param>
        [UnmanagedCallersOnly]
        private static partial ComResult attached_ccw(IPlugView* self, void* parent, LibVst.FIDString type);
        
        /// <summary>
        /// The parent window of the view is about to be destroyed.
        /// You have to remove all your own views from the parent window or view.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult removed_ccw(IPlugView* self);
        
        /// <summary>
        /// Handling of mouse wheel.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult onWheel_ccw(IPlugView* self, float distance);
        
        /// <summary>
        /// Handling of keyboard events : Key Down.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of modifiers - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise kResultFalse. @n &lt;b&gt;Please note that kResultTrue must only be returned if the key has really been
        /// handled. &lt;/b&gt;Otherwise key command handling of the host might be blocked!</returns>
        [UnmanagedCallersOnly]
        private static partial ComResult onKeyDown_ccw(IPlugView* self, ushort key, short keyCode, short modifiers);
        
        /// <summary>
        /// Handling of keyboard events : Key Up.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of KeyModifier - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise return kResultFalse.</returns>
        [UnmanagedCallersOnly]
        private static partial ComResult onKeyUp_ccw(IPlugView* self, ushort key, short keyCode, short modifiers);
        
        /// <summary>
        /// Returns the size of the platform representation of the view.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getSize_ccw(IPlugView* self, LibVst.ViewRect* size);
        
        /// <summary>
        /// Resizes the platform representation of the view to the given rect. Note that if the plug-in
        /// requests a resize (IPlugFrame::resizeView ()) onSize has to be called afterward.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult onSize_ccw(IPlugView* self, LibVst.ViewRect* newSize);
        
        /// <summary>
        /// Focus changed message.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult onFocus_ccw(IPlugView* self, [MarshalAs(UnmanagedType.U1)] byte state);
        
        /// <summary>
        /// Sets IPlugFrame object to allow the plug-in to inform the host about resizing.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setFrame_ccw(IPlugView* self, LibVst.IPlugFrame* frame);
        
        /// <summary>
        /// Is view sizable by user.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult canResize_ccw(IPlugView* self);
        
        /// <summary>
        /// On live resize this is called to check if the view can be resized to the given rect, if not
        /// adjust the rect to the allowed size.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult checkSizeConstraint_ccw(IPlugView* self, LibVst.ViewRect* rect);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugView, 0x5BC32507, 0xD06049EA, 0xA6151B52, 0x2B755B29)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x5b, 0xc3, 0x25, 0x07, 0xd0, 0x60, 0x49, 0xea, 0xa6, 0x15, 0x1b, 0x52, 0x2b, 0x75, 0x5b, 0x29 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x07, 0x25, 0xc3, 0x5b, 0xea, 0x49, 0x60, 0xd0, 0x52, 0x1b, 0x15, 0xa6, 0x29, 0x5b, 0x75, 0x2b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Graphical rectangle structure. Used with IPlugView.
    /// </summary>
    /// <remarks>
    ///  pluginGUI
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ViewRect
    {
        public int left;
        
        public int top;
        
        public int right;
        
        public int bottom;
    }
    
    /// <summary>
    /// Plug-in view content scale support
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIPlug vst366- [plug impl]
    /// - [extends IPlugView]
    /// - [released: 3.6.6]
    /// - [optional]This interface communicates the content scale factor from the host to the plug-in view on
    /// systems where plug-ins cannot get this information directly like Microsoft Windows.The host calls setContentScaleFactor directly before or after the plug-in view is attached and when
    /// the scale factor changes while the view is attached (system change or window moved to another screen
    /// with different scaling settings).The host may call setContentScaleFactor in a different context, for example: scaling the plug-in
    /// editor for better readability.When a plug-in handles this (by returning kResultTrue), it needs to scale the width and height of
    /// its view by the scale factor and inform the host via a IPlugFrame::resizeView(). The host will then
    /// call IPlugView::onSize().Note that the host is allowed to call setContentScaleFactor() at any time the IPlugView is valid.
    /// If this happens before the IPlugFrame object is set on your view, make sure that when the host calls
    /// IPlugView::getSize() afterwards you return the size of your view for that new scale factor.It is recommended to implement this interface on Microsoft Windows to let the host know that the
    /// plug-in is able to render in different scalings.
    /// </remarks>
    public unsafe partial struct IPlugViewContentScaleSupport : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPlugViewContentScaleSupport*, LibVst.ScaleFactor, ComResult>)&setContentScaleFactor_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPlugViewContentScaleSupport*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IPlugViewContentScaleSupport*, uint>)Vtbl[1])((LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IPlugViewContentScaleSupport*, uint>)Vtbl[2])((LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this));
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setContentScaleFactor(LibVst.ScaleFactor factor)
        {
            return ((delegate*unmanaged<LibVst.IPlugViewContentScaleSupport*, LibVst.ScaleFactor, ComResult>)Vtbl[3])((LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this), factor);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        [UnmanagedCallersOnly]
        private static partial ComResult setContentScaleFactor_ccw(IPlugViewContentScaleSupport* self, LibVst.ScaleFactor factor);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugViewContentScaleSupport, 0x65ED9690, 0x8AC44525, 0x8AADEF7A, 0x72EA703F)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x65, 0xed, 0x96, 0x90, 0x8a, 0xc4, 0x45, 0x25, 0x8a, 0xad, 0xef, 0x7a, 0x72, 0xea, 0x70, 0x3f })
                        : new ReadOnlySpan<byte>(new byte[] { 0x90, 0x96, 0xed, 0x65, 0x25, 0x45, 0xc4, 0x8a, 0x7a, 0xef, 0xad, 0x8a, 0x3f, 0x70, 0xea, 0x72 })
                    )));
            }
        }
    }
    
    public partial record struct ScaleFactor(float Value);
    
    /// <summary>
    /// 
    /// </summary>
    public enum Direction
    {
        kNorth,
        
        kNorthEast,
        
        kEast,
        
        kSouthEast,
        
        kSouth,
        
        kSouthWest,
        
        kWest,
        
        kNorthWest,
        
        /// <summary>
        /// same position or center point of a geometry
        /// </summary>
        kNoDirection,
        
        kNumberOfDirections,
    }
    
    /// <summary>
    /// 
    /// </summary>
    public enum Orientation
    {
        kHorizontal,
        
        kVertical,
        
        kNumberOfOrientations,
    }
    
    /// <summary>
    /// Virtual Key Codes.
    /// OS-independent enumeration of virtual keycodes.
    /// </summary>
    public enum VirtualKeyCodes
    {
        KEY_BACK = 1,
        
        KEY_TAB,
        
        KEY_CLEAR,
        
        KEY_RETURN,
        
        KEY_PAUSE,
        
        KEY_ESCAPE,
        
        KEY_SPACE,
        
        KEY_NEXT,
        
        KEY_END,
        
        KEY_HOME,
        
        KEY_LEFT,
        
        KEY_UP,
        
        KEY_RIGHT,
        
        KEY_DOWN,
        
        KEY_PAGEUP,
        
        KEY_PAGEDOWN,
        
        KEY_SELECT,
        
        KEY_PRINT,
        
        KEY_ENTER,
        
        KEY_SNAPSHOT,
        
        KEY_INSERT,
        
        KEY_DELETE,
        
        KEY_HELP,
        
        KEY_NUMPAD0,
        
        KEY_NUMPAD1,
        
        KEY_NUMPAD2,
        
        KEY_NUMPAD3,
        
        KEY_NUMPAD4,
        
        KEY_NUMPAD5,
        
        KEY_NUMPAD6,
        
        KEY_NUMPAD7,
        
        KEY_NUMPAD8,
        
        KEY_NUMPAD9,
        
        KEY_MULTIPLY,
        
        KEY_ADD,
        
        KEY_SEPARATOR,
        
        KEY_SUBTRACT,
        
        KEY_DECIMAL,
        
        KEY_DIVIDE,
        
        KEY_F1,
        
        KEY_F2,
        
        KEY_F3,
        
        KEY_F4,
        
        KEY_F5,
        
        KEY_F6,
        
        KEY_F7,
        
        KEY_F8,
        
        KEY_F9,
        
        KEY_F10,
        
        KEY_F11,
        
        KEY_F12,
        
        KEY_NUMLOCK,
        
        KEY_SCROLL,
        
        KEY_SHIFT,
        
        KEY_CONTROL,
        
        KEY_ALT,
        
        /// <summary>
        /// only occurs on a Mac
        /// </summary>
        KEY_EQUALS,
        
        /// <summary>
        /// Windows only
        /// </summary>
        KEY_CONTEXTMENU,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_PLAY,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_STOP,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_PREV,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_NEXT,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_VOLUME_UP,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_VOLUME_DOWN,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F13,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F14,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F15,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F16,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F17,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F18,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F19,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        VKEY_FIRST_CODE = KEY_BACK,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        VKEY_LAST_CODE = KEY_F19,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        VKEY_FIRST_ASCII = 128,
    }
    
    /// <summary>
    /// OS-independent enumeration of virtual modifier-codes.
    /// </summary>
    public enum KeyModifier
    {
        /// <summary>
        /// same on both PC and Mac
        /// </summary>
        kShiftKey = 1 << 0,
        
        /// <summary>
        /// same on both PC and Mac
        /// </summary>
        kAlternateKey = 1 << 1,
        
        /// <summary>
        /// windows ctrl key; mac cmd key (apple button)
        /// </summary>
        kCommandKey = 1 << 2,
        
        /// <summary>
        /// windows: not assigned, mac: ctrl key
        /// </summary>
        kControlKey = 1 << 3,
    }
    
    public enum StandardColor
    {
        kBlack = 0,
        
        kWhite,
        
        kGray5,
        
        kGray10,
        
        kGray20,
        
        kGray30,
        
        kGray40,
        
        kGray50,
        
        kGray60,
        
        kGray70,
        
        kGray80,
        
        kGray90,
        
        kRed,
        
        kLtRed,
        
        kDkRed,
        
        kGreen,
        
        kLtGreen,
        
        kDkGreen,
        
        kBlue,
        
        kLtBlue,
        
        kDkBlue,
        
        kMagenta,
        
        kLtMagenta,
        
        kDkMagenta,
        
        kYellow,
        
        kLtYellow,
        
        kDkYellow,
        
        kOrange,
        
        kLtOrange,
        
        kDkOrange,
        
        kGold,
        
        kBlack50,
        
        kBlack70,
        
        kNumStandardColors,
        
        kLtGray = kGray20,
        
        kGray = kGray50,
        
        kDkGray = kGray70,
    }
    
    /// <summary>
    /// Attribute list used in IMessage and IStreamAttributes: Vst::IAttributeList
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]An attribute list associates values with a key (id: some predefined keys can be found in @ref presetAttributes).
    /// </remarks>
    public unsafe partial struct IAttributeList : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, uint>)Vtbl[1])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, uint>)Vtbl[2])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Sets integer value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setInt(LibVst.AttrID id, long value)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, long, ComResult>)Vtbl[3])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
        }
        
        /// <summary>
        /// Gets integer value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getInt(LibVst.AttrID id, long* value)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, long*, ComResult>)Vtbl[4])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
        }
        
        /// <summary>
        /// Sets float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setFloat(LibVst.AttrID id, double value)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, double, ComResult>)Vtbl[5])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
        }
        
        /// <summary>
        /// Gets float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFloat(LibVst.AttrID id, double* value)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, double*, ComResult>)Vtbl[6])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
        }
        
        /// <summary>
        /// Sets string value (UTF16) (must be null-terminated!).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setString(LibVst.AttrID id, char* @string)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, char*, ComResult>)Vtbl[7])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, @string);
        }
        
        /// <summary>
        /// Gets string value (UTF16). Note that Size is in Byte, not the string Length!
        /// Do not forget to multiply the length by sizeof (TChar)!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getString(LibVst.AttrID id, char* @string, uint sizeInBytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, char*, uint, ComResult>)Vtbl[8])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, @string, sizeInBytes);
        }
        
        /// <summary>
        /// Sets binary data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinary(LibVst.AttrID id, void* data, uint sizeInBytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, void*, uint, ComResult>)Vtbl[9])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, data, sizeInBytes);
        }
        
        /// <summary>
        /// Gets binary data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinary(LibVst.AttrID id, void** data, uint* sizeInBytes)
        {
            return ((delegate*unmanaged<LibVst.IAttributeList*, LibVst.AttrID, void**, uint*, ComResult>)Vtbl[10])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, data, sizeInBytes);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributeList, 0x1E5F0AEB, 0xCC7F4533, 0xA2544011, 0x38AD5EE4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x1e, 0x5f, 0x0a, 0xeb, 0xcc, 0x7f, 0x45, 0x33, 0xa2, 0x54, 0x40, 0x11, 0x38, 0xad, 0x5e, 0xe4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xeb, 0x0a, 0x5f, 0x1e, 0x33, 0x45, 0x7f, 0xcc, 0x11, 0x40, 0x54, 0xa2, 0xe4, 0x5e, 0xad, 0x38 })
                    )));
            }
        }
    }
    
    public unsafe partial struct AttrID
    {
        public byte* Value;
    }
    
    /// <summary>
    /// Meta attributes of a stream: Vst::IStreamAttributes
    /// </summary>
    /// <remarks>
    ///  vstIHost vst360- [host imp]
    /// - [extends IBStream]
    /// - [released: 3.6.0]
    /// - [optional]Interface to access preset meta information from stream, used, for example, in setState in order to inform the plug-in about
    /// the current context in which the preset loading occurs (Project context or Preset load (see @ref StateType))or used to get the full file path of the loaded preset (if available).@code {.cpp}
    /// //------------------------------------------------------------------------
    /// #include "pluginterfaces/base/ustring.h"
    /// #include "pluginterfaces/vst/vstpresetkeys.h"
    /// ...
    /// 
    /// tresult PLUGIN_API MyPlugin::setState (IBStream* state)
    /// {
    /// 	FUnknownPtr&lt;IStreamAttributes&gt; stream (state);
    /// 	if (stream)
    /// 	{
    /// 		IAttributeList* list = stream-&gt;getAttributes ();
    /// 		if (list)
    /// 		{
    /// 			// get the current type (project/Default..) of this state
    /// 			String128 string;
    /// 			if (list-&gt;getString (PresetAttributes::kStateType, string, 128 * sizeof (TChar)) == kResultTrue)
    /// 			{
    /// 				UString128 tmp (string);
    /// 				char ascii[128];
    /// 				tmp.toAscii (ascii, 128);
    /// 				if (!strncmp (ascii, StateType::kProject, strlen (StateType::kProject)))
    /// 				{
    /// 					// we are in project loading context...
    /// 				}
    /// 			}
    /// 
    /// 			// get the full file path of this state
    /// 			TChar fullPath[1024];
    /// 			if (list-&gt;getString (PresetAttributes::kFilePathStringType, fullPath, 1024 * sizeof (TChar)) == kResultTrue)
    /// 			{
    /// 				// here we have the full path ...
    /// 			}
    /// 		}
    /// 	}
    /// 
    /// 	//...read the state here.....
    /// 	return kResultTrue;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IStreamAttributes : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IStreamAttributes*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IStreamAttributes*, uint>)Vtbl[1])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IStreamAttributes*, uint>)Vtbl[2])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets filename (without file extension) of the stream.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFileName(LibVst.String128* name)
        {
            return ((delegate*unmanaged<LibVst.IStreamAttributes*, LibVst.String128*, ComResult>)Vtbl[3])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this), name);
        }
        
        /// <summary>
        /// Gets meta information list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IAttributeList* getAttributes()
        {
            return ((delegate*unmanaged<LibVst.IStreamAttributes*, LibVst.IAttributeList*>)Vtbl[4])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IStreamAttributes, 0xD6CE2FFC, 0xEFAF4B8C, 0x9E74F1BB, 0x12DA44B4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xd6, 0xce, 0x2f, 0xfc, 0xef, 0xaf, 0x4b, 0x8c, 0x9e, 0x74, 0xf1, 0xbb, 0x12, 0xda, 0x44, 0xb4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xfc, 0x2f, 0xce, 0xd6, 0x8c, 0x4b, 0xaf, 0xef, 0xbb, 0xf1, 0x74, 0x9e, 0xb4, 0x44, 0xda, 0x12 })
                    )));
            }
        }
    }
    
    public unsafe partial struct String128
    {
        public fixed char Value[128];
    }
    
    /// <summary>
    /// IComponent Interface
    /// Component base interface: Vst::IComponent
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This is the basic interface for a VST component and must always be supported.
    /// It contains the common parts of any kind of processing class. The parts that
    /// are specific to a media type are defined in a separate interface. An implementation
    /// component must provide both the specific interface and IComponent.
    /// </remarks>
    /// <seealso cref="IPluginBase"/>
    public unsafe partial struct IComponent : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 9;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginBase.InitializeVtbl(vtbl);
            vtbl[5] = (delegate*unmanaged<IComponent*, Guid*, ComResult>)&getControllerClassId_ccw;
            vtbl[6] = (delegate*unmanaged<IComponent*, LibVst.IoMode, ComResult>)&setIoMode_ccw;
            vtbl[7] = (delegate*unmanaged<IComponent*, LibVst.MediaType, LibVst.BusDirection, int>)&getBusCount_ccw;
            vtbl[8] = (delegate*unmanaged<IComponent*, LibVst.MediaType, LibVst.BusDirection, int, LibVst.BusInfo*, ComResult>)&getBusInfo_ccw;
            vtbl[9] = (delegate*unmanaged<IComponent*, LibVst.RoutingInfo*, LibVst.RoutingInfo*, ComResult>)&getRoutingInfo_ccw;
            vtbl[10] = (delegate*unmanaged<IComponent*, LibVst.MediaType, LibVst.BusDirection, int, byte, ComResult>)&activateBus_ccw;
            vtbl[11] = (delegate*unmanaged<IComponent*, byte, ComResult>)&setActive_ccw;
            vtbl[12] = (delegate*unmanaged<IComponent*, LibVst.IBStream*, ComResult>)&setState_ccw;
            vtbl[13] = (delegate*unmanaged<IComponent*, LibVst.IBStream*, ComResult>)&getState_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called before initializing the component to get information about the controller class.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getControllerClassId_ccw(IComponent* self, Guid* classId);
        
        /// <summary>
        /// Called before 'initialize' to set the component usage (optional). See @ref IoModes
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setIoMode_ccw(IComponent* self, LibVst.IoMode mode);
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int getBusCount_ccw(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir);
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getBusInfo_ccw(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir, int index, LibVst.BusInfo* bus);
        
        /// <summary>
        /// Retrieves routing information (to be implemented when more than one regular input or output bus exists).
        /// The inInfo always refers to an input bus while the returned outInfo must refer to an output bus!
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getRoutingInfo_ccw(IComponent* self, LibVst.RoutingInfo* inInfo, LibVst.RoutingInfo* outInfo);
        
        /// <summary>
        /// Called upon (de-)activating a bus in the host application. The plug-in should only processed
        /// an activated bus, the host could provide less see @ref AudioBusBuffers in the process call
        /// (see @ref IAudioProcessor::process) if last busses are not activated. An already activated bus 
        /// does not need to be reactivated after a IAudioProcessor::setBusArrangements call.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult activateBus_ccw(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir, int index, [MarshalAs(UnmanagedType.U1)] byte state);
        
        /// <summary>
        /// Activates / deactivates the component.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setActive_ccw(IComponent* self, [MarshalAs(UnmanagedType.U1)] byte state);
        
        /// <summary>
        /// Sets complete state of component.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setState_ccw(IComponent* self, LibVst.IBStream* state);
        
        /// <summary>
        /// Retrieves complete state of component.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getState_ccw(IComponent* self, LibVst.IBStream* state);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponent, 0xE831FF31, 0xF2D54301, 0x928EBBEE, 0x25697802)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xe8, 0x31, 0xff, 0x31, 0xf2, 0xd5, 0x43, 0x01, 0x92, 0x8e, 0xbb, 0xee, 0x25, 0x69, 0x78, 0x02 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x31, 0xff, 0x31, 0xe8, 0x01, 0x43, 0xd5, 0xf2, 0xee, 0xbb, 0x8e, 0x92, 0x02, 0x78, 0x69, 0x25 })
                    )));
            }
        }
    }
    
    public partial record struct IoMode(int Value);
    
    public partial record struct MediaType(int Value);
    
    public partial record struct BusDirection(int Value);
    
    /// <summary>
    /// BusInfo:
    /// This is the structure used with getBusInfo, informing the host about what is a specific given bus.@n See also: Steinberg::Vst::IComponent::getBusInfo
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct BusInfo
    {
        /// <summary>
        /// Media type - has to be a value of @ref MediaTypes
        /// </summary>
        public LibVst.MediaType mediaType;
        
        /// <summary>
        /// input or output @ref BusDirections
        /// </summary>
        public LibVst.BusDirection direction;
        
        /// <summary>
        /// number of channels (if used then need to be recheck after @ref
        /// </summary>
        public int channelCount;
        
        /// <summary>
        /// name of the bus
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// main or aux - has to be a value of @ref BusTypes
        /// </summary>
        public LibVst.BusType busType;
        
        /// <summary>
        /// flags - a combination of @ref BusFlags
        /// </summary>
        public uint flags;
        
        public enum BusFlags
        {
            /// <summary>
            /// The bus should be activated by the host per default on instantiation (activateBus call is requested).
            /// By default a bus is inactive.
            /// </summary>
            kDefaultActive = 1 << 0,
            
            /// <summary>
            /// The bus does not contain ordinary audio data, but data used for control changes at sample rate.
            /// The data is in the same format as the audio data [-1..1].
            /// A host has to prevent unintended routing to speakers to prevent damage.
            /// Only valid for audio media type busses.
            /// [released: 3.7.0]
            /// </summary>
            kIsControlVoltage = 1 << 1,
        }
    }
    
    public partial record struct BusType(int Value);
    
    /// <summary>
    /// Routing Information:
    /// When the plug-in supports multiple I/O busses, a host may want to know how the busses are related. The
    /// relation of an event-input-channel to an audio-output-bus in particular is of interest to the host
    /// (in order to relate MIDI-tracks to audio-channels)@n See also: IComponent::getRoutingInfo, @ref vst3Routing
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct RoutingInfo
    {
        /// <summary>
        /// media type see @ref MediaTypes
        /// </summary>
        public LibVst.MediaType mediaType;
        
        /// <summary>
        /// bus index
        /// </summary>
        public int busIndex;
        
        /// <summary>
        /// channel (-1 for all channels)
        /// </summary>
        public int channel;
    }
    
    /// <summary>
    /// List of events to process: Vst::IEventList
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]
    /// </remarks>
    /// <seealso cref="ProcessData, Event"/>
    public unsafe partial struct IEventList : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IEventList*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IEventList*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IEventList*, uint>)Vtbl[1])((LibVst.IEventList*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IEventList*, uint>)Vtbl[2])((LibVst.IEventList*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns the count of events.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getEventCount()
        {
            return ((delegate*unmanaged<LibVst.IEventList*, int>)Vtbl[3])((LibVst.IEventList*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets parameter by index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getEvent(int index, LibVst.Event* e)
        {
            return ((delegate*unmanaged<LibVst.IEventList*, int, LibVst.Event*, ComResult>)Vtbl[4])((LibVst.IEventList*)Unsafe.AsPointer(ref this), index, e);
        }
        
        /// <summary>
        /// Adds a new event.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addEvent(LibVst.Event* e)
        {
            return ((delegate*unmanaged<LibVst.IEventList*, LibVst.Event*, ComResult>)Vtbl[5])((LibVst.IEventList*)Unsafe.AsPointer(ref this), e);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEventList, 0x3A2C4214, 0x346349FE, 0xB2C4F397, 0xB9695A44)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x3a, 0x2c, 0x42, 0x14, 0x34, 0x63, 0x49, 0xfe, 0xb2, 0xc4, 0xf3, 0x97, 0xb9, 0x69, 0x5a, 0x44 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x14, 0x42, 0x2c, 0x3a, 0xfe, 0x49, 0x63, 0x34, 0x97, 0xf3, 0xc4, 0xb2, 0x44, 0x5a, 0x69, 0xb9 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Event
    /// </summary>
    /// <remarks>
    ///  vstEventGrpStructure representing a single Event of different types associated to a specific event (@ref kEvent) bus.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct Event
    {
        /// <summary>
        /// event bus index
        /// </summary>
        public int busIndex;
        
        /// <summary>
        /// sample frames related to the current block start sample position
        /// </summary>
        public int sampleOffset;
        
        /// <summary>
        /// position in project
        /// </summary>
        public LibVst.TQuarterNotes ppqPosition;
        
        /// <summary>
        /// combination of @ref EventFlags
        /// </summary>
        public ushort flags;
        
        /// <summary>
        /// a value from @ref EventTypes
        /// </summary>
        public ushort type;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            /// <summary>
            /// type == kNoteOnEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteOnEvent noteOn;
            
            /// <summary>
            /// type == kNoteOffEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteOffEvent noteOff;
            
            /// <summary>
            /// type == kDataEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.DataEvent data;
            
            /// <summary>
            /// type == kPolyPressureEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.PolyPressureEvent polyPressure;
            
            /// <summary>
            /// type == kNoteExpressionValueEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteExpressionValueEvent noteExpressionValue;
            
            /// <summary>
            /// type == kNoteExpressionTextEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteExpressionTextEvent noteExpressionText;
            
            /// <summary>
            /// type == kChordEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.ChordEvent chord;
            
            /// <summary>
            /// type == kScaleEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.ScaleEvent scale;
            
            /// <summary>
            /// type == kLegacyMIDICCOutEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.LegacyMIDICCOutEvent midiCCOut;
        }
        
        public LibVst.Event.Union union;
        
        /// <summary>
        /// Event Flags - used for Event::flags
        /// </summary>
        public enum EventFlags
        {
            /// <summary>
            /// indicates that the event is played live (directly from keyboard)
            /// </summary>
            kIsLive = 1 << 0,
            
            /// <summary>
            /// reserved for user (for internal use)
            /// </summary>
            kUserReserved1 = 1 << 14,
            
            /// <summary>
            /// reserved for user (for internal use)
            /// </summary>
            kUserReserved2 = 1 << 15,
        }
        
        /// <summary>
        /// Event Types - used for Event::type
        /// </summary>
        public enum EventTypes
        {
            /// <summary>
            /// is @ref NoteOnEvent
            /// </summary>
            kNoteOnEvent = 0,
            
            /// <summary>
            /// is @ref NoteOffEvent
            /// </summary>
            kNoteOffEvent = 1,
            
            /// <summary>
            /// is @ref DataEvent
            /// </summary>
            kDataEvent = 2,
            
            /// <summary>
            /// is @ref PolyPressureEvent
            /// </summary>
            kPolyPressureEvent = 3,
            
            /// <summary>
            /// is @ref NoteExpressionValueEvent
            /// </summary>
            kNoteExpressionValueEvent = 4,
            
            /// <summary>
            /// is @ref NoteExpressionTextEvent
            /// </summary>
            kNoteExpressionTextEvent = 5,
            
            /// <summary>
            /// is @ref ChordEvent
            /// </summary>
            kChordEvent = 6,
            
            /// <summary>
            /// is @ref ScaleEvent
            /// </summary>
            kScaleEvent = 7,
            
            /// <summary>
            /// is @ref LegacyMIDICCOutEvent
            /// </summary>
            kLegacyMIDICCOutEvent = 65535,
        }
    }
    
    public partial record struct TQuarterNotes(double Value);
    
    /// <summary>
    /// Note-on event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrpPitch uses the twelve-tone equal temperament tuning (12-TET).
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteOnEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz (12-TET: twelve-tone equal temperament)
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// 1.f = +1 cent, -1.f = -1 cent
        /// </summary>
        public float tuning;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float velocity;
        
        /// <summary>
        /// in sample frames (optional, Note Off has to follow in any case!)
        /// </summary>
        public int length;
        
        /// <summary>
        /// note identifier (if not available then -1)
        /// </summary>
        public int noteId;
    }
    
    /// <summary>
    /// Note-off event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteOffEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz (12-TET)
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float velocity;
        
        /// <summary>
        /// associated noteOn identifier (if not available then -1)
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// 1.f = +1 cent, -1.f = -1 cent
        /// </summary>
        public float tuning;
    }
    
    /// <summary>
    /// Data event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct DataEvent
    {
        /// <summary>
        /// size in bytes of the data block bytes
        /// </summary>
        public uint size;
        
        /// <summary>
        /// type of this data block (see @ref DataTypes)
        /// </summary>
        public uint type;
        
        /// <summary>
        /// pointer to the data block
        /// </summary>
        public byte* bytes;
        
        /// <summary>
        /// Value for DataEvent::type
        /// </summary>
        public enum DataTypes
        {
            /// <summary>
            /// for MIDI system exclusive message
            /// </summary>
            kMidiSysEx = 0,
        }
    }
    
    /// <summary>
    /// PolyPressure event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PolyPressureEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float pressure;
        
        /// <summary>
        /// event should be applied to the noteId (if not -1)
        /// </summary>
        public int noteId;
    }
    
    /// <summary>
    /// Note Expression Value event. Used in @ref Event (union)
    /// A note expression event affects one single playing note (referring its noteId).
    /// This kind of event is send from host to the plug-in like other events (NoteOnEvent, NoteOffEvent,...) in @ref ProcessData during the process call.
    /// Note expression events for a specific noteId can only occur after a NoteOnEvent. The host must take care that the event list (@ref IEventList) is properly sorted.
    /// Expression events are always absolute normalized values [0.0, 1.0].
    /// The predefined types have a predefined mapping of the normalized values (see @ref NoteExpressionTypeIDs)
    /// </summary>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteExpressionValueEvent
    {
        /// <summary>
        /// see @ref NoteExpressionTypeID
        /// </summary>
        public LibVst.NoteExpressionTypeID typeId;
        
        /// <summary>
        /// associated note identifier to apply the change
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// normalized value [0.0, 1.0].
        /// </summary>
        public LibVst.NoteExpressionValue value;
    }
    
    public partial record struct NoteExpressionTypeID(uint Value);
    
    public partial record struct NoteExpressionValue(double Value);
    
    /// <summary>
    /// Note Expression Text event. Used in Event (union)
    /// A Expression event affects one single playing note.
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteExpressionTextEvent
    {
        /// <summary>
        /// see @ref NoteExpressionTypeID (kTextTypeID or kPhoneticTypeID)
        /// </summary>
        public LibVst.NoteExpressionTypeID typeId;
        
        /// <summary>
        /// associated note identifier to apply the change
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public uint textLen;
        
        /// <summary>
        /// UTF-16, null terminated
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Chord event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ChordEvent
    {
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short root;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short bassNote;
        
        /// <summary>
        /// root is bit 0
        /// </summary>
        public short mask;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public ushort textLen;
        
        /// <summary>
        /// UTF-16, null terminated Hosts Chord Name
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Scale event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ScaleEvent
    {
        /// <summary>
        /// range [0, 127] = root Note/Transpose Factor
        /// </summary>
        public short root;
        
        /// <summary>
        /// Bit 0 =  C,  Bit 1 = C#, ... (0x5ab5 = Major Scale)
        /// </summary>
        public short mask;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public ushort textLen;
        
        /// <summary>
        /// UTF-16, null terminated, Hosts Scale Name
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Legacy MIDI CC Out event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp- [released: 3.6.12]This kind of event is reserved for generating MIDI CC as output event for kEvent Bus during the process call.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct LegacyMIDICCOutEvent
    {
        /// <summary>
        /// see enum ControllerNumbers [0, 255]
        /// </summary>
        public byte controlNumber;
        
        /// <summary>
        /// channel index in event bus [0, 15]
        /// </summary>
        public sbyte channel;
        
        /// <summary>
        /// value of Controller [0, 127]
        /// </summary>
        public sbyte value;
        
        /// <summary>
        /// [0, 127] used for pitch bend (kPitchBend) and polyPressure (kCtrlPolyPressure)
        /// </summary>
        public sbyte value2;
    }
    
    /// <summary>
    /// All parameter changes of a processing block: Vst::IParameterChanges
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface is used to transmit any changes to be applied to parameters
    /// in the current processing block. A change can be caused by GUI interaction as
    /// well as automation. They are transmitted as a list of queues (@ref IParamValueQueue)containing only queues for parameters that actually did change.
    /// See @ref IParamValueQueue, @ref ProcessData
    /// </remarks>
    public unsafe partial struct IParameterChanges : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, uint>)Vtbl[1])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, uint>)Vtbl[2])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns count of Parameter changes in the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getParameterCount()
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, int>)Vtbl[3])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns the queue at a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IParamValueQueue* getParameterData(int index)
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, int, LibVst.IParamValueQueue*>)Vtbl[4])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this), index);
        }
        
        /// <summary>
        /// Adds a new parameter queue with a given ID at the end of the list,
        /// returns it and its index in the parameter changes list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IParamValueQueue* addParameterData(LibVst.ParamID* id, int* index)
        {
            return ((delegate*unmanaged<LibVst.IParameterChanges*, LibVst.ParamID*, int*, LibVst.IParamValueQueue*>)Vtbl[5])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this), id, index);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterChanges, 0xA4779663, 0x0BB64A56, 0xB44384A8, 0x466FEB9D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xa4, 0x77, 0x96, 0x63, 0x0b, 0xb6, 0x4a, 0x56, 0xb4, 0x43, 0x84, 0xa8, 0x46, 0x6f, 0xeb, 0x9d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x63, 0x96, 0x77, 0xa4, 0x56, 0x4a, 0xb6, 0x0b, 0xa8, 0x84, 0x43, 0xb4, 0x9d, 0xeb, 0x6f, 0x46 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Queue of changes for a specific parameter: Vst::IParamValueQueue
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]The change queue can be interpreted as segment of an automation curve. For each
    /// processing block, a segment with the size of the block is transmitted to the processor.
    /// The curve is expressed as sampling points of a linear approximation of
    /// the original automation curve. If the original already is a linear curve, it can
    /// be transmitted precisely. A non-linear curve has to be converted to a linear
    /// approximation by the host. Every point of the value queue defines a linear
    /// section of the curve as a straight line from the previous point of a block to
    /// the new one. So the plug-in can calculate the value of the curve for any sample
    /// position in the block.&lt;b&gt;Implicit Points:&lt;/b&gt;@n In each processing block, the section of the curve for each parameter is transmitted.
    /// In order to reduce the amount of points, the point at block position 0 can be omitted.
    /// - If the curve has a slope of 0 over a period of multiple blocks, only one point is
    /// transmitted for the block where the constant curve section starts. The queue for the following
    /// blocks will be empty as long as the curve slope is 0.
    /// - If the curve has a constant slope other than 0 over the period of several blocks, only
    /// the value for the last sample of the block is transmitted. In this case, the last valid point
    /// is at block position -1. The processor can calculate the value for each sample in the block
    /// by using a linear interpolation:@code {.cpp}
    /// //------------------------------------------------------------------------
    /// double x1 = -1; // position of last point related to current buffer
    /// double y1 = currentParameterValue; // last transmitted value
    /// 
    /// int32 pointTime = 0;
    /// ParamValue pointValue = 0;
    /// IParamValueQueue::getPoint (0, pointTime, pointValue);
    /// 
    /// double x2 = pointTime;
    /// double y2 = pointValue;
    /// 
    /// double slope = (y2 - y1) / (x2 - x1);
    /// double offset = y1 - (slope * x1);
    /// 
    /// double curveValue = (slope * bufferTime) + offset; // bufferTime is any position in buffer
    /// @endcode@b Jumps: @n A jump in the automation curve has to be transmitted as two points: one with the
    /// old value and one with the new value at the next sample position. html "automation.jpg"See @ref IParameterChanges, @ref ProcessData
    /// </remarks>
    public unsafe partial struct IParamValueQueue : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, uint>)Vtbl[1])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, uint>)Vtbl[2])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns its associated ID.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.ParamID getParameterId()
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, LibVst.ParamID>)Vtbl[3])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns count of points in the queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getPointCount()
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, int>)Vtbl[4])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets the value and offset at a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getPoint(int index, int* sampleOffset, LibVst.ParamValue* value)
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, int, int*, LibVst.ParamValue*, ComResult>)Vtbl[5])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this), index, sampleOffset, value);
        }
        
        /// <summary>
        /// Adds a new value at the end of the queue, its index is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addPoint(int sampleOffset, LibVst.ParamValue value, int* index)
        {
            return ((delegate*unmanaged<LibVst.IParamValueQueue*, int, LibVst.ParamValue, int*, ComResult>)Vtbl[6])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this), sampleOffset, value, index);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParamValueQueue, 0x01263A18, 0xED074F6F, 0x98C9D356, 0x4686F9BA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x01, 0x26, 0x3a, 0x18, 0xed, 0x07, 0x4f, 0x6f, 0x98, 0xc9, 0xd3, 0x56, 0x46, 0x86, 0xf9, 0xba })
                        : new ReadOnlySpan<byte>(new byte[] { 0x18, 0x3a, 0x26, 0x01, 0x6f, 0x4f, 0x07, 0xed, 0x56, 0xd3, 0xc9, 0x98, 0xba, 0xf9, 0x86, 0x46 })
                    )));
            }
        }
    }
    
    public partial record struct ParamID(uint Value);
    
    public partial record struct ParamValue(double Value);
    
    /// <summary>
    /// Audio processing interface: Vst::IAudioProcessor
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface must always be supported by audio processing plug-ins.
    /// </remarks>
    public unsafe partial struct IAudioProcessor : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IAudioProcessor*, LibVst.SpeakerArrangement*, int, LibVst.SpeakerArrangement*, int, ComResult>)&setBusArrangements_ccw;
            vtbl[4] = (delegate*unmanaged<IAudioProcessor*, LibVst.BusDirection, int, LibVst.SpeakerArrangement*, ComResult>)&getBusArrangement_ccw;
            vtbl[5] = (delegate*unmanaged<IAudioProcessor*, int, ComResult>)&canProcessSampleSize_ccw;
            vtbl[6] = (delegate*unmanaged<IAudioProcessor*, uint>)&getLatencySamples_ccw;
            vtbl[7] = (delegate*unmanaged<IAudioProcessor*, LibVst.ProcessSetup*, ComResult>)&setupProcessing_ccw;
            vtbl[8] = (delegate*unmanaged<IAudioProcessor*, byte, ComResult>)&setProcessing_ccw;
            vtbl[9] = (delegate*unmanaged<IAudioProcessor*, LibVst.ProcessData*, ComResult>)&process_ccw;
            vtbl[10] = (delegate*unmanaged<IAudioProcessor*, uint>)&getTailSamples_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Try to set (host =&gt; plug-in) a wanted arrangement for inputs and outputs.
        /// The host should always deliver the same number of input and output busses than the plug-in
        /// needs (see @ref IComponent::getBusCount). The plug-in has 3 possibilities to react on this
        /// setBusArrangements call:@n 1. The plug-in accepts these arrangements, then it should modify, if needed, its busses to match 
        /// these new arrangements (later on asked by the host with IComponent::getBusInfo () or
        /// IAudioProcessor::getBusArrangement ()) and then should return kResultTrue.@n 2. The plug-in does not accept or support these requested arrangements for all
        /// inputs/outputs or just for some or only one bus, but the plug-in can try to adapt its current
        /// arrangements according to the requested ones (requested arrangements for kMain busses should be
        /// handled with more priority than the ones for kAux busses), then it should modify its busses arrangements
        /// and should return kResultFalse.@n 3. Same than the point 2 above the plug-in does not support these requested arrangements 
        /// but the plug-in cannot find corresponding arrangements, the plug-in could keep its current arrangement
        /// or fall back to a default arrangement by modifying its busses arrangements and should return kResultFalse.@n
        /// </summary>
        /// <param name="inputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numIns">number of /ref SpeakerArrangement in inputs array</param>
        /// <param name="outputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numOuts">number of /ref SpeakerArrangement in outputs array 
        /// Returns kResultTrue when Arrangements is supported and is the current one, else returns kResultFalse.</param>
        [UnmanagedCallersOnly]
        private static partial ComResult setBusArrangements_ccw(IAudioProcessor* self, LibVst.SpeakerArrangement* inputs, int numIns, LibVst.SpeakerArrangement* outputs, int numOuts);
        
        /// <summary>
        /// Gets the bus arrangement for a given direction (input/output) and index.
        /// Note: IComponent::getBusInfo () and IAudioProcessor::getBusArrangement () should be always return the same 
        /// information about the busses arrangements.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getBusArrangement_ccw(IAudioProcessor* self, LibVst.BusDirection dir, int index, LibVst.SpeakerArrangement* arr);
        
        /// <summary>
        /// Asks if a given sample size is supported see @ref SymbolicSampleSizes.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult canProcessSampleSize_ccw(IAudioProcessor* self, int symbolicSampleSize);
        
        /// <summary>
        /// Gets the current Latency in samples.
        /// The returned value defines the group delay or the latency of the plug-in. For example, if the plug-in internally needs
        /// to look in advance (like compressors) 512 samples then this plug-in should report 512 as latency.
        /// If during the use of the plug-in this latency change, the plug-in has to inform the host by
        /// using IComponentHandler::restartComponent (kLatencyChanged), this could lead to audio playback interruption
        /// because the host has to recompute its internal mixer delay compensation.
        /// Note that for player live recording this latency should be zero or small.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial uint getLatencySamples_ccw(IAudioProcessor* self);
        
        /// <summary>
        /// Called in disable state (setActive not called with true) before setProcessing is called and processing will begin.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setupProcessing_ccw(IAudioProcessor* self, LibVst.ProcessSetup* setup);
        
        /// <summary>
        /// Informs the plug-in about the processing state. This will be called before any process calls
        /// start with true and after with false.
        /// Note that setProcessing (false) may be called after setProcessing (true) without any process
        /// calls.
        /// Note this function could be called in the UI or in Processing Thread, thats why the plug-in
        /// should only light operation (no memory allocation or big setup reconfiguration), 
        /// this could be used to reset some buffers (like Delay line or Reverb).
        /// The host has to be sure that it is called only when the plug-in is enable (setActive (true)
        /// was called).
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setProcessing_ccw(IAudioProcessor* self, [MarshalAs(UnmanagedType.U1)] byte state);
        
        /// <summary>
        /// The Process call, where all information (parameter changes, event, audio buffer) are passed.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult process_ccw(IAudioProcessor* self, LibVst.ProcessData* data);
        
        /// <summary>
        /// Gets tail size in samples. For example, if the plug-in is a Reverb plug-in and it knows that
        /// the maximum length of the Reverb is 2sec, then it has to return in getTailSamples() 
        /// (in VST2 it was getGetTailSize ()): 2*sampleRate.
        /// This information could be used by host for offline processing, process optimization and 
        /// downmix (avoiding signal cut (clicks)).
        /// It should return:
        /// - kNoTail when no tail
        /// - x * sampleRate when x Sec tail.
        /// - kInfiniteTail when infinite tail.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial uint getTailSamples_ccw(IAudioProcessor* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAudioProcessor, 0x42043F99, 0xB7DA453C, 0xA569E79D, 0x9AAEC33D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x42, 0x04, 0x3f, 0x99, 0xb7, 0xda, 0x45, 0x3c, 0xa5, 0x69, 0xe7, 0x9d, 0x9a, 0xae, 0xc3, 0x3d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x99, 0x3f, 0x04, 0x42, 0x3c, 0x45, 0xda, 0xb7, 0x9d, 0xe7, 0x69, 0xa5, 0x3d, 0xc3, 0xae, 0x9a })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Speaker Arrangements Types
    /// 
    /// </summary>
    public enum SpeakerArrangement : ulong
    {
        kSpeakerL = 1<<0,
        
        kSpeakerR = 1<<1,
        
        kSpeakerC = 1<<2,
        
        kSpeakerLfe = 1<<3,
        
        kSpeakerLs = 1<<4,
        
        kSpeakerRs = 1<<5,
        
        kSpeakerLc = 1<<6,
        
        kSpeakerRc = 1<<7,
        
        kSpeakerS = 1<<8,
        
        kSpeakerCs = kSpeakerS,
        
        kSpeakerSl = 1<<9,
        
        kSpeakerSr = 1<<10,
        
        kSpeakerTc = 1<<11,
        
        kSpeakerTfl = 1<<12,
        
        kSpeakerTfc = 1<<13,
        
        kSpeakerTfr = 1<<14,
        
        kSpeakerTrl = 1<<15,
        
        kSpeakerTrc = 1<<16,
        
        kSpeakerTrr = 1<<17,
        
        kSpeakerLfe2 = 1<<18,
        
        kSpeakerM = 1<<19,
        
        kSpeakerACN0 = 1UL << 20,
        
        kSpeakerACN1 = 1UL << 21,
        
        kSpeakerACN2 = 1UL << 22,
        
        kSpeakerACN3 = 1UL << 23,
        
        kSpeakerACN4 = 1UL << 38,
        
        kSpeakerACN5 = 1UL << 39,
        
        kSpeakerACN6 = 1UL << 40,
        
        kSpeakerACN7 = 1UL << 41,
        
        kSpeakerACN8 = 1UL << 42,
        
        kSpeakerACN9 = 1UL << 43,
        
        kSpeakerACN10 = 1UL << 44,
        
        kSpeakerACN11 = 1UL << 45,
        
        kSpeakerACN12 = 1UL << 46,
        
        kSpeakerACN13 = 1UL << 47,
        
        kSpeakerACN14 = 1UL << 48,
        
        kSpeakerACN15 = 1UL << 49,
        
        kSpeakerTsl = 1UL << 24,
        
        kSpeakerTsr = 1UL << 25,
        
        kSpeakerLcs = 1UL << 26,
        
        kSpeakerRcs = 1UL << 27,
        
        kSpeakerBfl = 1UL << 28,
        
        kSpeakerBfc = 1UL << 29,
        
        kSpeakerBfr = 1UL << 30,
        
        kSpeakerPl = 1UL << 31,
        
        kSpeakerPr = 1UL << 32,
        
        kSpeakerBsl = 1UL << 33,
        
        kSpeakerBsr = 1UL << 34,
        
        kSpeakerBrl = 1UL << 35,
        
        kSpeakerBrc = 1UL << 36,
        
        kSpeakerBrr = 1UL << 37,
        
        kEmpty = 0,
        
        kMono = kSpeakerM,
        
        kStereo = kSpeakerL | kSpeakerR,
        
        kStereoSurround = kSpeakerLs | kSpeakerRs,
        
        kStereoCenter = kSpeakerLc | kSpeakerRc,
        
        kStereoSide = kSpeakerSl | kSpeakerSr,
        
        kStereoCLfe = kSpeakerC | kSpeakerLfe,
        
        kStereoTF = kSpeakerTfl | kSpeakerTfr,
        
        kStereoTS = kSpeakerTsl | kSpeakerTsr,
        
        kStereoTR = kSpeakerTrl | kSpeakerTrr,
        
        kStereoBF = kSpeakerBfl | kSpeakerBfr,
        
        kCineFront = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLc | kSpeakerRc,
        
        k30Cine = kSpeakerL | kSpeakerR | kSpeakerC,
        
        k31Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe,
        
        k30Music = kSpeakerL | kSpeakerR | kSpeakerCs,
        
        k31Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerCs,
        
        k40Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerCs,
        
        k41Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerCs,
        
        k40Music = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs,
        
        k41Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs,
        
        k50 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs,
        
        k51 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs,
        
        k60Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerCs,
        
        k61Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs,
        
        k60Music = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k61Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k70Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc,
        
        k71Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc,
        
        k71CineFullFront = k71Cine,
        
        k70Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k71Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k71CineFullRear = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLcs | kSpeakerRcs,
        
        k71CineSideFill = k71Music,
        
        k71Proximity = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerPl | kSpeakerPr,
        
        k80Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs,
        
        k81Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs,
        
        k80Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k81Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k90Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr,
        
        k91Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr,
        
        k100Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k101Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        kAmbi1stOrderACN = kSpeakerACN0 | kSpeakerACN1 | kSpeakerACN2 | kSpeakerACN3,
        
        kAmbi2cdOrderACN = kAmbi1stOrderACN | kSpeakerACN4 | kSpeakerACN5 | kSpeakerACN6 | kSpeakerACN7 | kSpeakerACN8,
        
        kAmbi3rdOrderACN = kAmbi2cdOrderACN | kSpeakerACN9 | kSpeakerACN10 | kSpeakerACN11 | kSpeakerACN12 | kSpeakerACN13 | kSpeakerACN14 | kSpeakerACN15,
        
        k80Cube = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k40_4 = k80Cube,
        
        k71CineTopCenter = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerTc,
        
        k71CineCenterHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerTfc,
        
        k70CineFrontHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr,
        
        k70MPEG3D = k70CineFrontHigh,
        
        k50_2 = k70CineFrontHigh,
        
        k71CineFrontHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr,
        
        k71MPEG3D = k71CineFrontHigh,
        
        k51_2 = k71CineFrontHigh,
        
        k71CineSideHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTsl | kSpeakerTsr,
        
        k81MPEG3D = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerBfc,
        
        k41_4_1 = k81MPEG3D,
        
        k90 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_4 = k90,
        
        k91 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k51_4 = k91,
        
        k50_4_1 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfc,
        
        k51_4_1 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfc,
        
        k70_2 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTsl | kSpeakerTsr,
        
        k71_2 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTsl | kSpeakerTsr,
        
        k91Atmos = k71_2,
        
        k70_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrc,
        
        k72_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrc | kSpeakerLfe2,
        
        k70_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k71_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k111MPEG3D = k71_4,
        
        k70_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k71_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k90_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k91_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k90_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k91_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k100 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_5 = k100,
        
        k101 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k101MPEG3D = k101,
        
        k51_5 = k101,
        
        k102 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerLfe2,
        
        k52_5 = k102,
        
        k110 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_6 = k110,
        
        k111 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k51_6 = k111,
        
        k122 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerLfe2,
        
        k72_5 = k122,
        
        k130 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k131 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k140 = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfr | kSpeakerBrl | kSpeakerBrr,
        
        k60_4_4 = k140,
        
        k220 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrc | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k100_9_3 = k220,
        
        k222 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrc | kSpeakerTrr | kSpeakerLfe2 | kSpeakerTsl | kSpeakerTsr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k102_9_3 = k222,
        
        k50_5_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k51_5_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
    }
    
    /// <summary>
    /// Audio processing setup.
    /// </summary>
    /// <seealso cref="IAudioProcessor::setupProcessing"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ProcessSetup
    {
        /// <summary>
        /// @ref ProcessModes
        /// </summary>
        public int processMode;
        
        /// <summary>
        /// @ref SymbolicSampleSizes
        /// </summary>
        public int symbolicSampleSize;
        
        /// <summary>
        /// maximum number of samples per audio block
        /// </summary>
        public int maxSamplesPerBlock;
        
        /// <summary>
        /// sample rate
        /// </summary>
        public LibVst.SampleRate sampleRate;
    }
    
    public partial record struct SampleRate(double Value);
    
    /// <summary>
    /// Any data needed in audio processing.
    /// The host prepares AudioBusBuffers for each input/output bus,
    /// regardless of the bus activation state. Bus buffer indices always match
    /// with bus indices used in IComponent::getBusInfo of media type kAudio.
    /// </summary>
    /// <seealso cref="AudioBusBuffers, IParameterChanges, IEventList, ProcessContext, IProcessContextRequirements"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ProcessData
    {
        /// <summary>
        /// processing mode - value of @ref ProcessModes
        /// </summary>
        public int processMode;
        
        /// <summary>
        /// sample size - value of @ref SymbolicSampleSizes
        /// </summary>
        public int symbolicSampleSize;
        
        /// <summary>
        /// number of samples to process
        /// </summary>
        public int numSamples;
        
        /// <summary>
        /// number of audio input busses
        /// </summary>
        public int numInputs;
        
        /// <summary>
        /// number of audio output busses
        /// </summary>
        public int numOutputs;
        
        /// <summary>
        /// buffers of input busses
        /// </summary>
        public LibVst.AudioBusBuffers* inputs;
        
        /// <summary>
        /// buffers of output busses
        /// </summary>
        public LibVst.AudioBusBuffers* outputs;
        
        /// <summary>
        /// incoming parameter changes for this block
        /// </summary>
        public LibVst.IParameterChanges* inputParameterChanges;
        
        /// <summary>
        /// outgoing parameter changes for this block (optional)
        /// </summary>
        public LibVst.IParameterChanges* outputParameterChanges;
        
        /// <summary>
        /// incoming events for this block (optional)
        /// </summary>
        public LibVst.IEventList* inputEvents;
        
        /// <summary>
        /// outgoing events for this block (optional)
        /// </summary>
        public LibVst.IEventList* outputEvents;
        
        /// <summary>
        /// processing context (optional, but most welcome)
        /// </summary>
        public LibVst.ProcessContext* processContext;
    }
    
    /// <summary>
    /// Processing buffers of an audio bus.
    /// This structure contains the processing buffer for each channel of an audio bus.
    /// - The number of channels (numChannels) must always match the current bus arrangement.
    /// It could be set to value '0' when the host wants to flush the parameters (when the plug-in is not processed).
    /// - The size of the channel buffer array must always match the number of channels. So the host
    /// must always supply an array for the channel buffers, regardless if the
    /// bus is active or not. However, if an audio bus is currently inactive, the actual sample
    /// buffer addresses are safe to be null.
    /// - The silence flag is set when every sample of the according buffer has the value '0'. It is
    /// intended to be used as help for optimizations allowing a plug-in to reduce processing activities.
    /// But even if this flag is set for a channel, the channel buffers must still point to valid memory!
    /// This flag is optional. A host is free to support it or not.
    /// .
    /// </summary>
    /// <seealso cref="ProcessData"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct AudioBusBuffers
    {
        /// <summary>
        /// number of audio channels in bus
        /// </summary>
        public int numChannels;
        
        /// <summary>
        /// Bitset of silence state per channel
        /// </summary>
        public ulong silenceFlags;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            /// <summary>
            /// sample buffers to process with 32-bit precision
            /// </summary>
            [FieldOffset(0)]
            public LibVst.Sample32** channelBuffers32;
            
            /// <summary>
            /// sample buffers to process with 64-bit precision
            /// </summary>
            [FieldOffset(0)]
            public LibVst.Sample64** channelBuffers64;
        }
        
        public LibVst.AudioBusBuffers.Union union;
    }
    
    public partial record struct Sample32(float Value);
    
    public partial record struct Sample64(double Value);
    
    /// <summary>
    /// Audio processing context.
    /// For each processing block the host provides timing information and musical parameters that can
    /// change over time. For a host that supports jumps (like cycle) it is possible to split up a
    /// processing block into multiple parts in order to provide a correct project time inside of every
    /// block, but this behavior is not mandatory. Since the timing will be correct at the beginning of the
    /// next block again, a host that is dependent on a fixed processing block size can choose to neglect
    /// this problem.
    /// </summary>
    /// <seealso cref="IAudioProcessor, ProcessData"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ProcessContext
    {
        /// <summary>
        /// a combination of the values from @ref StatesAndFlags
        /// </summary>
        public uint state;
        
        /// <summary>
        /// current sample rate					(always valid)
        /// </summary>
        public double sampleRate;
        
        /// <summary>
        /// project time in samples				(always valid)
        /// </summary>
        public LibVst.TSamples projectTimeSamples;
        
        /// <summary>
        /// system time in nanoseconds					(optional)
        /// </summary>
        public long systemTime;
        
        /// <summary>
        /// project time, without loop					(optional)
        /// </summary>
        public LibVst.TSamples continousTimeSamples;
        
        /// <summary>
        /// musical position in quarter notes (1.0 equals 1 quarter note) (optional)
        /// </summary>
        public LibVst.TQuarterNotes projectTimeMusic;
        
        /// <summary>
        /// last bar start position, in quarter notes	(optional)
        /// </summary>
        public LibVst.TQuarterNotes barPositionMusic;
        
        /// <summary>
        /// cycle start in quarter notes				(optional)
        /// </summary>
        public LibVst.TQuarterNotes cycleStartMusic;
        
        /// <summary>
        /// cycle end in quarter notes					(optional)
        /// </summary>
        public LibVst.TQuarterNotes cycleEndMusic;
        
        /// <summary>
        /// tempo in BPM (Beats Per Minute)			(optional)
        /// </summary>
        public double tempo;
        
        /// <summary>
        /// time signature numerator (e.g. 3 for 3/4)	(optional)
        /// </summary>
        public int timeSigNumerator;
        
        /// <summary>
        /// time signature denominator (e.g. 4 for 3/4) (optional)
        /// </summary>
        public int timeSigDenominator;
        
        /// <summary>
        /// musical info								(optional)
        /// </summary>
        public LibVst.Chord chord;
        
        /// <summary>
        /// SMPTE (sync) offset in subframes (1/80 of frame) (optional)
        /// </summary>
        public int smpteOffsetSubframes;
        
        /// <summary>
        /// frame rate									(optional)
        /// </summary>
        public LibVst.FrameRate frameRate;
        
        /// <summary>
        /// MIDI Clock Resolution (24 Per Quarter Note), can be negative (nearest) (optional)
        /// </summary>
        public int samplesToNextClock;
        
        /// <summary>
        /// Transport state 
        /// &amp;
        /// other flags
        /// </summary>
        public enum StatesAndFlags
        {
            /// <summary>
            /// currently playing
            /// </summary>
            kPlaying = 1 << 1,
            
            /// <summary>
            /// cycle is active
            /// </summary>
            kCycleActive = 1 << 2,
            
            /// <summary>
            /// currently recording
            /// </summary>
            kRecording = 1 << 3,
            
            /// <summary>
            /// systemTime contains valid information
            /// </summary>
            kSystemTimeValid = 1 << 8,
            
            /// <summary>
            /// continousTimeSamples contains valid information
            /// </summary>
            kContTimeValid = 1 << 17,
            
            /// <summary>
            /// projectTimeMusic contains valid information
            /// </summary>
            kProjectTimeMusicValid = 1 << 9,
            
            /// <summary>
            /// barPositionMusic contains valid information
            /// </summary>
            kBarPositionValid = 1 << 11,
            
            /// <summary>
            /// cycleStartMusic and barPositionMusic contain valid information
            /// </summary>
            kCycleValid = 1 << 12,
            
            /// <summary>
            /// tempo contains valid information
            /// </summary>
            kTempoValid = 1 << 10,
            
            /// <summary>
            /// timeSigNumerator and timeSigDenominator contain valid information
            /// </summary>
            kTimeSigValid = 1 << 13,
            
            /// <summary>
            /// chord contains valid information
            /// </summary>
            kChordValid = 1 << 18,
            
            /// <summary>
            /// smpteOffset and frameRate contain valid information
            /// </summary>
            kSmpteValid = 1 << 14,
            
            /// <summary>
            /// samplesToNextClock valid
            /// </summary>
            kClockValid = 1 << 15,
        }
    }
    
    public partial record struct TSamples(long Value);
    
    /// <summary>
    /// Description of a chord.
    /// A chord is described with a key note, a root note and the@copydoc chordMask
    /// </summary>
    /// <seealso cref="ProcessContext"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct Chord
    {
        /// <summary>
        /// key note in chord
        /// </summary>
        public byte keyNote;
        
        /// <summary>
        /// lowest note in chord
        /// </summary>
        public byte rootNote;
        
        /// <summary>
        /// Bitmask of a chord. @n 1st bit set: minor second; 2nd bit set: major second, and so on. @n There is @b no bit for the keynote (root of the chord) because it is inherently always present. @n Examples:
        /// - XXXX 0000 0100 1000 (= 0x0048) -&gt; major chord
        /// - XXXX 0000 0100 0100 (= 0x0044) -&gt; minor chord
        /// - XXXX 0010 0100 0100 (= 0x0244) -&gt; minor chord with minor seventh
        /// </summary>
        public short chordMask;
        
        public enum Masks
        {
            /// <summary>
            /// mask for chordMask
            /// </summary>
            kChordMask = 0x0FFF,
            
            /// <summary>
            /// reserved for future use
            /// </summary>
            kReservedMask = 0xF000,
        }
    }
    
    /// <summary>
    /// Frame Rate 
    /// A frame rate describes the number of image (frame) displayed per second.
    /// Some examples:
    /// - 23.976 fps     is framesPerSecond: 24 and flags: kPullDownRate
    /// - 24 fps         is framesPerSecond: 24 and flags: 0
    /// - 25 fps         is framesPerSecond: 25 and flags: 0
    /// - 29.97 drop fps is framesPerSecond: 30 and flags: kDropRate|kPullDownRate
    /// - 29.97 fps      is framesPerSecond: 30 and flags: kPullDownRate
    /// - 30 fps         is framesPerSecond: 30 and flags: 0
    /// - 30 drop fps    is framesPerSecond: 30 and flags: kDropRate
    /// - 50 fps         is framesPerSecond: 50 and flags: 0
    /// - 59.94 fps	     is framesPerSecond: 60 and flags: kPullDownRate
    /// - 60 fps         is framesPerSecond: 60 and flags: 0
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct FrameRate
    {
        /// <summary>
        /// frame rate
        /// </summary>
        public uint framesPerSecond;
        
        /// <summary>
        /// flags #FrameRateFlags
        /// </summary>
        public uint flags;
        
        /// <summary>
        /// 
        /// </summary>
        public enum FrameRateFlags
        {
            kPullDownRate = 1 << 0,
            
            kDropRate = 1 << 1,
        }
    }
    
    /// <summary>
    /// Extended IAudioProcessor interface for a component: Vst::IAudioPresentationLatency
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst310- [plug imp]
    /// - [extends IAudioProcessor]
    /// - [released: 3.1.0]
    /// - [optional]Inform the plug-in about how long from the moment of generation/acquiring (from file or from Input)
    /// it will take for its input to arrive, and how long it will take for its output to be presented (to output or to speaker).Note for Input Presentation Latency: when reading from file, the first plug-in will have an input presentation latency set to zero.
    /// When monitoring audio input from an audio device, the initial input latency is the input latency of the audio device itself.Note for Output Presentation Latency: when writing to a file, the last plug-in will have an output presentation latency set to zero.
    /// When the output of this plug-in is connected to an audio device, the initial output latency is the output
    /// latency of the audio device itself.A value of zero either means no latency or an unknown latency.Each plug-in adding a latency (returning a none zero value for IAudioProcessor::getLatencySamples) will modify the input 
    /// presentation latency of the next plug-ins in the mixer routing graph and will modify the output presentation latency 
    /// of the previous plug-ins.@n html "iaudiopresentationlatency_usage.png"@n
    /// </remarks>
    /// <seealso cref="IAudioProcessor"/>
    /// <seealso cref="IComponent"/>
    public unsafe partial struct IAudioPresentationLatency : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IAudioPresentationLatency*, LibVst.BusDirection, int, uint, ComResult>)&setAudioPresentationLatencySamples_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Informs the plug-in about the Audio Presentation Latency in samples for a given direction (kInput/kOutput) and bus index.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setAudioPresentationLatencySamples_ccw(IAudioPresentationLatency* self, LibVst.BusDirection dir, int busIndex, uint latencyInSamples);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAudioPresentationLatency, 0x309ECE78, 0xEB7D4fae, 0x8B2225D9, 0x09FD08B6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x30, 0x9e, 0xce, 0x78, 0xeb, 0x7d, 0x4f, 0xae, 0x8b, 0x22, 0x25, 0xd9, 0x09, 0xfd, 0x08, 0xb6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x78, 0xce, 0x9e, 0x30, 0xae, 0x4f, 0x7d, 0xeb, 0xd9, 0x25, 0x22, 0x8b, 0xb6, 0x08, 0xfd, 0x09 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended IAudioProcessor interface for a component: Vst::IProcessContextRequirements
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst370- [plug imp]
    /// - [extends IAudioProcessor]
    /// - [released: 3.7.0]
    /// - [mandatory]To get accurate process context information (Vst::ProcessContext), it is now required to implement this interface and
    /// return the desired bit mask of flags which your audio effect needs. If you do not implement this
    /// interface, you may not get any information at all of the process function.The host asks for this information once between initialize and setActive. It cannot be changed afterwards.This gives the host the opportunity to better optimize the audio process graph when it knows which
    /// plug-ins need which information.Plug-Ins built with an earlier SDK version (
    /// &lt;
    /// 3.7) will still get the old information, but the information
    /// may not be as accurate as when using this interface.
    /// </remarks>
    public unsafe partial struct IProcessContextRequirements : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IProcessContextRequirements*, uint>)&getProcessContextRequirements_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        [UnmanagedCallersOnly]
        private static partial uint getProcessContextRequirements_ccw(IProcessContextRequirements* self);
        
        public enum Flags
        {
            /// <summary>
            /// kSystemTimeValid
            /// </summary>
            kNeedSystemTime = 1 << 0,
            
            /// <summary>
            /// kContTimeValid
            /// </summary>
            kNeedContinousTimeSamples = 1 << 1,
            
            /// <summary>
            /// kProjectTimeMusicValid
            /// </summary>
            kNeedProjectTimeMusic = 1 << 2,
            
            /// <summary>
            /// kBarPositionValid
            /// </summary>
            kNeedBarPositionMusic = 1 << 3,
            
            /// <summary>
            /// kCycleValid
            /// </summary>
            kNeedCycleMusic = 1 << 4,
            
            /// <summary>
            /// kClockValid
            /// </summary>
            kNeedSamplesToNextClock = 1 << 5,
            
            /// <summary>
            /// kTempoValid
            /// </summary>
            kNeedTempo = 1 << 6,
            
            /// <summary>
            /// kTimeSigValid
            /// </summary>
            kNeedTimeSignature = 1 << 7,
            
            /// <summary>
            /// kChordValid
            /// </summary>
            kNeedChord = 1 << 8,
            
            /// <summary>
            /// kSmpteValid
            /// </summary>
            kNeedFrameRate = 1 << 9,
            
            /// <summary>
            /// kPlaying, kCycleActive, kRecording
            /// </summary>
            kNeedTransportState = 1 << 10,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProcessContextRequirements, 0x2A654303, 0xEF764E3D, 0x95B5FE83, 0x730EF6D0)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x2a, 0x65, 0x43, 0x03, 0xef, 0x76, 0x4e, 0x3d, 0x95, 0xb5, 0xfe, 0x83, 0x73, 0x0e, 0xf6, 0xd0 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x03, 0x43, 0x65, 0x2a, 0x3d, 0x4e, 0x76, 0xef, 0x83, 0xfe, 0xb5, 0x95, 0xd0, 0xf6, 0x0e, 0x73 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController: Vst::IAutomationState
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst365- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.5]
    /// - [optional]Hosts can inform the plug-in about its current automation state (Read/Write/Nothing).
    /// </remarks>
    public unsafe partial struct IAutomationState : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IAutomationState*, int, ComResult>)&setAutomationState_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Sets the current Automation state.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setAutomationState_ccw(IAutomationState* self, int state);
        
        /// <summary>
        /// 
        /// </summary>
        public enum AutomationStates
        {
            /// <summary>
            /// Not Read and not Write
            /// </summary>
            kNoAutomation = 0,
            
            /// <summary>
            /// Read state
            /// </summary>
            kReadState = 1 << 0,
            
            /// <summary>
            /// Write state
            /// </summary>
            kWriteState = 1 << 1,
            
            /// <summary>
            /// Read and Write enable
            /// </summary>
            kReadWriteState = kReadState | kWriteState,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAutomationState, 0xB4E8287F, 0x1BB346AA, 0x83A46667, 0x68937BAB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xb4, 0xe8, 0x28, 0x7f, 0x1b, 0xb3, 0x46, 0xaa, 0x83, 0xa4, 0x66, 0x67, 0x68, 0x93, 0x7b, 0xab })
                        : new ReadOnlySpan<byte>(new byte[] { 0x7f, 0x28, 0xe8, 0xb4, 0xaa, 0x46, 0xb3, 0x1b, 0x67, 0x66, 0xa4, 0x83, 0xab, 0x7b, 0x93, 0x68 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Context Menu interface: Vst::IContextMenu
    /// </summary>
    /// <remarks>
    ///  vstIHost vst350- [host imp]
    /// - [create with IComponentHandler3::createContextMenu(..)]
    /// - [released: 3.5.0]
    /// - [optional]A context menu is composed of Item (entry). A Item is defined by a name, a tag, a flag
    /// and a associated target (called when this item will be selected/executed). 
    /// With IContextMenu the plug-in can retrieve a Item, add a Item, remove a Item and pop-up the menu.
    /// </remarks>
    /// <seealso cref="IComponentHandler3 for more information."/>
    public unsafe partial struct IContextMenu : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, uint>)Vtbl[1])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, uint>)Vtbl[2])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets the number of menu items.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getItemCount()
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, int>)Vtbl[3])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets a menu item and its target (target could be not assigned).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getItem(int index, LibVst.Item* item, LibVst.IContextMenuTarget** target)
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, int, LibVst.Item*, LibVst.IContextMenuTarget**, ComResult>)Vtbl[4])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), index, item, target);
        }
        
        /// <summary>
        /// Adds a menu item and its target.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addItem(LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, ComResult>)Vtbl[5])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), item, target);
        }
        
        /// <summary>
        /// Removes a menu item.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult removeItem(LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, ComResult>)Vtbl[6])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), item, target);
        }
        
        /// <summary>
        /// Pop-ups the menu. Coordinates are relative to the top-left position of the plug-ins view.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult popup(LibVst.UCoord x, LibVst.UCoord y)
        {
            return ((delegate*unmanaged<LibVst.IContextMenu*, LibVst.UCoord, LibVst.UCoord, ComResult>)Vtbl[7])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), x, y);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IContextMenu, 0x2E93C863, 0x0C9C4588, 0x97DBECF5, 0xAD17817D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x2e, 0x93, 0xc8, 0x63, 0x0c, 0x9c, 0x45, 0x88, 0x97, 0xdb, 0xec, 0xf5, 0xad, 0x17, 0x81, 0x7d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x63, 0xc8, 0x93, 0x2e, 0x88, 0x45, 0x9c, 0x0c, 0xf5, 0xec, 0xdb, 0x97, 0x7d, 0x81, 0x17, 0xad })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IContextMenuItem is an entry element of the context menu.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct IContextMenuItem
    {
        /// <summary>
        /// Name of the item
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// Identifier tag of the item
        /// </summary>
        public int tag;
        
        /// <summary>
        /// Flags of the item
        /// </summary>
        public int flags;
        
        public enum Flags
        {
            /// <summary>
            /// Item is a separator
            /// </summary>
            kIsSeparator = 1 << 0,
            
            /// <summary>
            /// Item is disabled
            /// </summary>
            kIsDisabled = 1 << 1,
            
            /// <summary>
            /// Item is checked
            /// </summary>
            kIsChecked = 1 << 2,
            
            /// <summary>
            /// Item is a group start (like sub folder)
            /// </summary>
            kIsGroupStart = 1 << 3 | kIsDisabled,
            
            /// <summary>
            /// Item is a group end
            /// </summary>
            kIsGroupEnd = 1 << 4 | kIsSeparator,
        }
    }
    
    public partial record struct Item(LibVst.IContextMenuItem Value);
    
    /// <summary>
    /// Context Menu Item Target interface: Vst::IContextMenuTarget
    /// </summary>
    /// <remarks>
    ///  vstIHost vstIPlug vst350- [host imp]
    /// - [plug imp]
    /// - [released: 3.5.0]
    /// - [optional]A receiver of a menu item should implement this interface, which will be called after the user has selected
    /// this menu item.
    /// </remarks>
    /// <seealso cref="IComponentHandler3 for more information."/>
    public unsafe partial struct IContextMenuTarget : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IContextMenuTarget*, int, ComResult>)&executeMenuItem_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IContextMenuTarget*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IContextMenuTarget*, uint>)Vtbl[1])((LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IContextMenuTarget*, uint>)Vtbl[2])((LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Called when an menu item was executed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult executeMenuItem(int tag)
        {
            return ((delegate*unmanaged<LibVst.IContextMenuTarget*, int, ComResult>)Vtbl[3])((LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this), tag);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called when an menu item was executed.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult executeMenuItem_ccw(IContextMenuTarget* self, int tag);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IContextMenuTarget, 0x3CDF2E75, 0x85D34144, 0xBF86D36B, 0xD7C4894D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x3c, 0xdf, 0x2e, 0x75, 0x85, 0xd3, 0x41, 0x44, 0xbf, 0x86, 0xd3, 0x6b, 0xd7, 0xc4, 0x89, 0x4d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x75, 0x2e, 0xdf, 0x3c, 0x44, 0x41, 0xd3, 0x85, 0x6b, 0xd3, 0x86, 0xbf, 0x4d, 0x89, 0xc4, 0xd7 })
                    )));
            }
        }
    }
    
    public partial record struct UCoord(int Value);
    
    /// <summary>
    /// Extended host callback interface Vst::IComponentHandler3 for an edit controller.
    /// </summary>
    /// <remarks>
    ///  vstIHost vst350- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.5.0]
    /// - [optional]A plug-in can ask the host to create a context menu for a given exported parameter ID or a generic context menu.@nThe host may pre-fill this context menu with specific items regarding the parameter ID like "Show automation for parameter",
    /// "MIDI learn" etc...@nThe plug-in can use the context menu in two ways :
    /// - add its own items to the menu via the IContextMenu interface and call IContextMenu::popup(..) to create the pop-up. See the @ref IContextMenuExample.- extract the host menu items and add them to a context menu created by the plug-in.@b Note: You can and should use this even if you do not add your own items to the menu as this is considered to be a big user value. IContextMenuExample Examples- For example, Cubase adds its owned entries in the context menu opened with right-click on an exported parameter when the plug-in uses createContextMenu. html "contextmenuexample.png"@n - Adding plug-in specific items to the context menu:@code {.cpp}
    /// //------------------------------------------------------------------------
    /// class PluginContextMenuTarget : public IContextMenuTarget, public FObject
    /// {
    /// public:
    /// 	PluginContextMenuTarget () {}
    /// 
    /// 	virtual tresult PLUGIN_API executeMenuItem (int32 tag)
    /// 	{
    /// 		// this will be called if the user has executed one of the menu items of the plug-in.
    /// 		// It will not be called for items of the host.
    /// 		switch (tag)
    /// 		{
    /// 			case 1: break;
    /// 			case 2: break;
    /// 		}
    /// 		return kResultTrue;
    /// 	}
    /// 
    /// 	OBJ_METHODS(PluginContextMenuTarget, FObject)
    /// 	DEFINE_INTERFACES
    /// 		DEF_INTERFACE (IContextMenuTarget)
    /// 	END_DEFINE_INTERFACES (FObject)
    /// 	REFCOUNT_METHODS(FObject)
    /// };
    /// 
    /// // The following is the code to create the context menu
    /// void popupContextMenu (IComponentHandler* componentHandler, IPlugView* view, const ParamID* paramID, UCoord x, UCoord y)
    /// {
    /// 	if (componentHandler == 0 || view == 0)
    /// 		return;
    /// 	FUnknownPtr&lt;IComponentHandler3&gt; handler (componentHandler);
    /// 	if (handler == 0)
    /// 		return;
    /// 	IContextMenu* menu = handler-&gt;createContextMenu (view, paramID);
    /// 	if (menu)
    /// 	{
    /// 		// here you can add your entries (optional)
    /// 		PluginContextMenuTarget* target = new PluginContextMenuTarget ();
    /// 		
    /// 		IContextMenu::Item item = {0};
    /// 		UString128 ("My Item 1").copyTo (item.name, 128);
    /// 		item.tag = 1;
    /// 		menu-&gt;addItem (item, target);
    /// 
    /// 		UString128 ("My Item 2").copyTo (item.name, 128);
    /// 		item.tag = 2;
    /// 		menu-&gt;addItem (item, target);
    /// 		target-&gt;release ();
    /// 		//--end of adding new entries
    /// 		
    /// 		// here the the context menu will be pop-up (and it waits a user interaction)
    /// 		menu-&gt;popup (x, y);
    /// 		menu-&gt;release ();
    /// 	}
    /// }
    /// @endcode
    /// </remarks>
    /// <seealso cref="IContextMenu"/>
    /// <seealso cref="IContextMenuTarget"/>
    public unsafe partial struct IComponentHandler3 : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler3*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler3*, uint>)Vtbl[1])((LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler3*, uint>)Vtbl[2])((LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Creates a host context menu for a plug-in:
        /// - If paramID is zero, the host may create a generic context menu.
        /// - The IPlugView object must be valid.
        /// - The return IContextMenu object needs to be released afterwards by the plug-in.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IContextMenu* createContextMenu(LibVst.IPlugView* plugView, LibVst.ParamID* paramID)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler3*, LibVst.IPlugView*, LibVst.ParamID*, LibVst.IContextMenu*>)Vtbl[3])((LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this), plugView, paramID);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler3, 0x69F11617, 0xD26B400D, 0xA4B6B964, 0x7B6EBBAB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x69, 0xf1, 0x16, 0x17, 0xd2, 0x6b, 0x40, 0x0d, 0xa4, 0xb6, 0xb9, 0x64, 0x7b, 0x6e, 0xbb, 0xab })
                        : new ReadOnlySpan<byte>(new byte[] { 0x17, 0x16, 0xf1, 0x69, 0x0d, 0x40, 0x6b, 0xd2, 0x64, 0xb9, 0xb6, 0xa4, 0xab, 0xbb, 0x6e, 0x7b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Host callback interface for an edit controller: Vst::IComponentHandler
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]Allow transfer of parameter editing to component (processor) via host and support automation.
    /// Cause the host to react on configuration changes (restartComponent).
    /// </remarks>
    /// <seealso cref="IEditController"/>
    public unsafe partial struct IComponentHandler : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, uint>)Vtbl[1])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, uint>)Vtbl[2])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// To be called before calling a performEdit (e.g. on mouse-click-down event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult beginEdit(LibVst.ParamID id)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, LibVst.ParamID, ComResult>)Vtbl[3])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id);
        }
        
        /// <summary>
        /// Called between beginEdit and endEdit to inform the handler that a given parameter has a new
        /// value. This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult performEdit(LibVst.ParamID id, LibVst.ParamValue valueNormalized)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, LibVst.ParamID, LibVst.ParamValue, ComResult>)Vtbl[4])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id, valueNormalized);
        }
        
        /// <summary>
        /// To be called after calling a performEdit (e.g. on mouse-click-up event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult endEdit(LibVst.ParamID id)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, LibVst.ParamID, ComResult>)Vtbl[5])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id);
        }
        
        /// <summary>
        /// Instructs host to restart the component. This must be called in the UI-Thread context!
        /// </summary>
        /// <param name="flags">is a combination of RestartFlags</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult restartComponent(int flags)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler*, int, ComResult>)Vtbl[6])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), flags);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler, 0x93A0BEA3, 0x0BD045DB, 0x8E890B0C, 0xC1E46AC6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x93, 0xa0, 0xbe, 0xa3, 0x0b, 0xd0, 0x45, 0xdb, 0x8e, 0x89, 0x0b, 0x0c, 0xc1, 0xe4, 0x6a, 0xc6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa3, 0xbe, 0xa0, 0x93, 0xdb, 0x45, 0xd0, 0x0b, 0x0c, 0x0b, 0x89, 0x8e, 0xc6, 0x6a, 0xe4, 0xc1 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IComponentHandler2
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.1.0]
    /// - [optional]One part handles:
    /// - Setting dirty state of the plug-in
    /// - Requesting the host to open the editorThe other part handles parameter group editing from the plug-in UI. It wraps a set of @ref IComponentHandler::beginEdit /@ref Steinberg::Vst::IComponentHandler::performEdit / @ref Steinberg::Vst::IComponentHandler::endEdit functions (see @ref IComponentHandler)which should use the same timestamp in the host when writing automation.
    /// This allows for better synchronizing of multiple parameter changes at once. IComponentHandler2Example Examples of different use cases@code {.cpp}
    /// //--------------------------------------
    /// // we are in the editcontroller...
    /// // in case of multiple switch buttons (with associated ParamID 1 and 3)
    /// // on mouse down :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;beginEdit (1);
    /// hostHandler-&gt;beginEdit (3);
    /// hostHandler-&gt;performEdit (1, 1.0);
    /// hostHandler-&gt;performEdit (3, 0.0); // the opposite of paramID 1 for example
    /// ....
    /// // on mouse up :
    /// hostHandler-&gt;endEdit (1);
    /// hostHandler-&gt;endEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// ....
    /// //--------------------------------------
    /// // in case of multiple faders (with associated ParamID 1 and 3)
    /// // on mouse down :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;beginEdit (1);
    /// hostHandler-&gt;beginEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// // on mouse move :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;performEdit (1, x); // x the wanted value
    /// hostHandler-&gt;performEdit (3, x);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// // on mouse up :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;endEdit (1);
    /// hostHandler-&gt;endEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// @endcode
    /// </remarks>
    /// <seealso cref="IEditControllerIComponentHandler,"/>
    public unsafe partial struct IComponentHandler2 : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, uint>)Vtbl[1])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, uint>)Vtbl[2])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Tells host that the plug-in is dirty (something besides parameters has changed since last save),
        /// if true the host should apply a save before quitting.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setDirty([MarshalAs(UnmanagedType.U1)] byte state)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, byte, ComResult>)Vtbl[3])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this), state);
        }
        
        /// <summary>
        /// Tells host that it should open the plug-in editor the next time it's possible.
        /// You should use this instead of showing an alert and blocking the program flow (especially on loading projects).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult requestOpenEditor(LibVst.FIDString name)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, LibVst.FIDString, ComResult>)Vtbl[4])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this), name);
        }
        
        /// <summary>
        /// Starts the group editing (call before a @ref IComponentHandler::beginEdit), the host will keep the current timestamp at this call and will use it for all @ref IComponentHandler::beginEdit / @ref IComponentHandler::performEdit / @ref IComponentHandler::endEdit calls until a @ref finishGroupEdit ().
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult startGroupEdit()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, ComResult>)Vtbl[5])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Finishes the group editing started by a @ref startGroupEdit (call after a @ref IComponentHandler::endEdit).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult finishGroupEdit()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandler2*, ComResult>)Vtbl[6])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler2, 0xF040B4B3, 0xA36045EC, 0xABCDC045, 0xB4D5A2CC)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf0, 0x40, 0xb4, 0xb3, 0xa3, 0x60, 0x45, 0xec, 0xab, 0xcd, 0xc0, 0x45, 0xb4, 0xd5, 0xa2, 0xcc })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb3, 0xb4, 0x40, 0xf0, 0xec, 0x45, 0x60, 0xa3, 0x45, 0xc0, 0xcd, 0xab, 0xcc, 0xa2, 0xd5, 0xb4 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IComponentHandlerBusActivation
    /// </summary>
    /// <remarks>
    ///  vstIHost vst368- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.6.8]
    /// - [optional]Allows the plug-in to request the host to activate or deactivate a specific bus. 
    /// If the host accepts this request, it will call later on @ref IComponent::activateBus. This is particularly useful for instruments with more than 1 outputs, where the user could request
    /// from the plug-in UI a given output bus activation.@code {.cpp}
    /// 	// somewhere in your code when you need to inform the host to enable a specific Bus.
    /// 	FUnknownPtr&lt;IComponentHandlerBusActivation&gt; busActivation (componentHandler);
    /// 	if (busActivation)
    /// 	{
    /// 		// here we want to activate our audio input sidechain (the 2cd input bus: index 1)
    /// 		busActivation-&gt;requestBusActivation (kAudio, kInput, 1, true);
    /// 	}
    /// @endcode
    /// </remarks>
    /// <seealso cref="IComponentHandler"/>
    public unsafe partial struct IComponentHandlerBusActivation : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandlerBusActivation*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandlerBusActivation*, uint>)Vtbl[1])((LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IComponentHandlerBusActivation*, uint>)Vtbl[2])((LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// request the host to activate or deactivate a specific bus.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult requestBusActivation(LibVst.MediaType type, LibVst.BusDirection dir, int index, [MarshalAs(UnmanagedType.U1)] byte state)
        {
            return ((delegate*unmanaged<LibVst.IComponentHandlerBusActivation*, LibVst.MediaType, LibVst.BusDirection, int, byte, ComResult>)Vtbl[3])((LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this), type, dir, index, state);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandlerBusActivation, 0x067D02C1, 0x5B4E274D, 0xA92D90FD, 0x6EAF7240)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x06, 0x7d, 0x02, 0xc1, 0x5b, 0x4e, 0x27, 0x4d, 0xa9, 0x2d, 0x90, 0xfd, 0x6e, 0xaf, 0x72, 0x40 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc1, 0x02, 0x7d, 0x06, 0x4d, 0x27, 0x4e, 0x5b, 0xfd, 0x90, 0x2d, 0xa9, 0x40, 0x72, 0xaf, 0x6e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IProgress
    /// </summary>
    /// <remarks>
    ///  vstIHost vst370- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.7.0]
    /// - [optional]Allows the plug-in to request the host to create a progress for some specific tasks which take
    /// some time. The host can visualize the progress as read-only UI elements. For example,
    /// after loading a project where a plug-in needs to load extra
    /// data (e.g. samples) in a background thread, this enables the host to get and visualize the current status of the loading
    /// progress and to inform the user when the loading is finished.
    /// Note: During the progress, the host can unload the plug-in at any time. Make sure that the plug-in 
    /// supports this use case. IProgressExample Example@code {.cpp}
    /// //--------------------------------------
    /// // we are in the editcontroller:
    /// // as member: IProgress::ID mProgressID;
    /// 
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;start (IProgress::ProgressType::UIBackgroundTask, STR ("Load Samples..."), mProgressID);
    /// 
    /// // ...
    /// myProgressValue += incProgressStep;
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;update (mProgressID, myProgressValue);
    /// 
    /// // ...
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;finish (mProgressID);
    /// @endcode
    /// </remarks>
    /// <seealso cref="IComponentHandler"/>
    public unsafe partial struct IProgress : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IProgress*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IProgress*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IProgress*, uint>)Vtbl[1])((LibVst.IProgress*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IProgress*, uint>)Vtbl[2])((LibVst.IProgress*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Start a new progress of a given type and optional Description. outID is as ID created by the
        /// host to identify this newly created progress (for update and finish method)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult start(ProgressType type, char* optionalDescription, LibVst.ID* outID)
        {
            return ((delegate*unmanaged<LibVst.IProgress*, ProgressType, char*, LibVst.ID*, ComResult>)Vtbl[3])((LibVst.IProgress*)Unsafe.AsPointer(ref this), type, optionalDescription, outID);
        }
        
        /// <summary>
        /// Update the progress value (normValue between [0, 1]) associated to the given id
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult update(LibVst.ID id, LibVst.ParamValue normValue)
        {
            return ((delegate*unmanaged<LibVst.IProgress*, LibVst.ID, LibVst.ParamValue, ComResult>)Vtbl[4])((LibVst.IProgress*)Unsafe.AsPointer(ref this), id, normValue);
        }
        
        /// <summary>
        /// Finish the progress associated to the given id
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult finish(LibVst.ID id)
        {
            return ((delegate*unmanaged<LibVst.IProgress*, LibVst.ID, ComResult>)Vtbl[5])((LibVst.IProgress*)Unsafe.AsPointer(ref this), id);
        }
        
        /// <summary>
        /// 
        /// </summary>
        public enum ProgressType : uint
        {
            /// <summary>
            /// plug-in state is restored async (in a background Thread)
            /// </summary>
            AsyncStateRestoration = 0,
            
            /// <summary>
            /// a plug-in task triggered by a UI action
            /// </summary>
            UIBackgroundTask,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProgress, 0x00C9DC5B, 0x9D904254, 0x91A388C8, 0xB4E91B69)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x00, 0xc9, 0xdc, 0x5b, 0x9d, 0x90, 0x42, 0x54, 0x91, 0xa3, 0x88, 0xc8, 0xb4, 0xe9, 0x1b, 0x69 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x5b, 0xdc, 0xc9, 0x00, 0x54, 0x42, 0x90, 0x9d, 0xc8, 0x88, 0xa3, 0x91, 0x69, 0x1b, 0xe9, 0xb4 })
                    )));
            }
        }
    }
    
    public partial record struct ID(ulong Value);
    
    /// <summary>
    /// Edit controller component interface: Vst::IEditController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// - [mandatory]The controller part of an effect or instrument with parameter handling (export, definition, conversion...).
    /// </remarks>
    /// <seealso cref="IMidiMappingIComponent::getControllerClassId,"/>
    public unsafe partial struct IEditController : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 13;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginBase.InitializeVtbl(vtbl);
            vtbl[5] = (delegate*unmanaged<IEditController*, LibVst.IBStream*, ComResult>)&setComponentState_ccw;
            vtbl[6] = (delegate*unmanaged<IEditController*, LibVst.IBStream*, ComResult>)&setState_ccw;
            vtbl[7] = (delegate*unmanaged<IEditController*, LibVst.IBStream*, ComResult>)&getState_ccw;
            vtbl[8] = (delegate*unmanaged<IEditController*, int>)&getParameterCount_ccw;
            vtbl[9] = (delegate*unmanaged<IEditController*, int, LibVst.ParameterInfo*, ComResult>)&getParameterInfo_ccw;
            vtbl[10] = (delegate*unmanaged<IEditController*, LibVst.ParamID, LibVst.ParamValue, LibVst.String128*, ComResult>)&getParamStringByValue_ccw;
            vtbl[11] = (delegate*unmanaged<IEditController*, LibVst.ParamID, char*, LibVst.ParamValue*, ComResult>)&getParamValueByString_ccw;
            vtbl[12] = (delegate*unmanaged<IEditController*, LibVst.ParamID, LibVst.ParamValue, LibVst.ParamValue>)&normalizedParamToPlain_ccw;
            vtbl[13] = (delegate*unmanaged<IEditController*, LibVst.ParamID, LibVst.ParamValue, LibVst.ParamValue>)&plainParamToNormalized_ccw;
            vtbl[14] = (delegate*unmanaged<IEditController*, LibVst.ParamID, LibVst.ParamValue>)&getParamNormalized_ccw;
            vtbl[15] = (delegate*unmanaged<IEditController*, LibVst.ParamID, LibVst.ParamValue, ComResult>)&setParamNormalized_ccw;
            vtbl[16] = (delegate*unmanaged<IEditController*, LibVst.IComponentHandler*, ComResult>)&setComponentHandler_ccw;
            vtbl[17] = (delegate*unmanaged<IEditController*, LibVst.FIDString, LibVst.IPlugView*>)&createView_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Receives the component state.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setComponentState_ccw(IEditController* self, LibVst.IBStream* state);
        
        /// <summary>
        /// Sets the controller state.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setState_ccw(IEditController* self, LibVst.IBStream* state);
        
        /// <summary>
        /// Gets the controller state.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getState_ccw(IEditController* self, LibVst.IBStream* state);
        
        /// <summary>
        /// parameters -------------------------
        /// Returns the number of parameters exported.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int getParameterCount_ccw(IEditController* self);
        
        /// <summary>
        /// Gets for a given index the parameter information.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getParameterInfo_ccw(IEditController* self, int paramIndex, LibVst.ParameterInfo* info);
        
        /// <summary>
        /// Gets for a given paramID and normalized value its associated string representation.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getParamStringByValue_ccw(IEditController* self, LibVst.ParamID id, LibVst.ParamValue valueNormalized, LibVst.String128* @string);
        
        /// <summary>
        /// Gets for a given paramID and string its normalized value.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getParamValueByString_ccw(IEditController* self, LibVst.ParamID id, char* @string, LibVst.ParamValue* valueNormalized);
        
        /// <summary>
        /// Returns for a given paramID and a normalized value its plain representation
        /// (for example -6 for -6dB - see @ref vst3AutomationIntro).
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.ParamValue normalizedParamToPlain_ccw(IEditController* self, LibVst.ParamID id, LibVst.ParamValue valueNormalized);
        
        /// <summary>
        /// Returns for a given paramID and a plain value its normalized value. (see @ref vst3AutomationIntro)
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.ParamValue plainParamToNormalized_ccw(IEditController* self, LibVst.ParamID id, LibVst.ParamValue plainValue);
        
        /// <summary>
        /// Returns the normalized value of the parameter associated to the paramID.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.ParamValue getParamNormalized_ccw(IEditController* self, LibVst.ParamID id);
        
        /// <summary>
        /// Sets the normalized value to the parameter associated to the paramID. The controller must never
        /// pass this value-change back to the host via the IComponentHandler. It should update the according
        /// GUI element(s) only!
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setParamNormalized_ccw(IEditController* self, LibVst.ParamID id, LibVst.ParamValue value);
        
        /// <summary>
        /// handler ----------------------------
        /// Gets from host a handler which allows the Plugin-in to communicate with the host.
        /// Note: This is mandatory if the host is using the IEditController!
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setComponentHandler_ccw(IEditController* self, LibVst.IComponentHandler* handler);
        
        /// <summary>
        /// view -------------------------------
        /// Creates the editor view of the plug-in, currently only "editor" is supported, see @ref ViewType. The life time of the editor view will never exceed the life time of this controller instance.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.IPlugView* createView_ccw(IEditController* self, LibVst.FIDString name);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditController, 0xDCD7BBE3, 0x7742448D, 0xA874AACC, 0x979C759E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xdc, 0xd7, 0xbb, 0xe3, 0x77, 0x42, 0x44, 0x8d, 0xa8, 0x74, 0xaa, 0xcc, 0x97, 0x9c, 0x75, 0x9e })
                        : new ReadOnlySpan<byte>(new byte[] { 0xe3, 0xbb, 0xd7, 0xdc, 0x8d, 0x44, 0x42, 0x77, 0xcc, 0xaa, 0x74, 0xa8, 0x9e, 0x75, 0x9c, 0x97 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Controller Parameter Info.
    /// A parameter info describes a parameter of the controller.
    /// The id must always be the same for a parameter as this uniquely identifies the parameter.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ParameterInfo
    {
        /// <summary>
        /// unique identifier of this parameter (named tag too)
        /// </summary>
        public LibVst.ParamID id;
        
        /// <summary>
        /// parameter title (e.g. "Volume")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// parameter shortTitle (e.g. "Vol")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// parameter unit (e.g. "dB")
        /// </summary>
        public LibVst.String128 units;
        
        /// <summary>
        /// number of discrete steps (0: continuous, 1: toggle, discrete value otherwise 
        /// (corresponding to max - min, for example: 127 for a min = 0 and a max = 127) - see @ref vst3ParameterIntro)
        /// </summary>
        public int stepCount;
        
        /// <summary>
        /// default normalized value [0,1] (in case of discrete value: defaultNormalizedValue = defDiscreteValue / stepCount)
        /// </summary>
        public LibVst.ParamValue defaultNormalizedValue;
        
        /// <summary>
        /// id of unit this parameter belongs to (see @ref vst3Units)
        /// </summary>
        public LibVst.UnitID unitId;
        
        /// <summary>
        /// ParameterFlags (see below)
        /// </summary>
        public int flags;
        
        public enum ParameterFlags
        {
            /// <summary>
            /// no flags wanted
            /// </summary>
            kNoFlags = 0,
            
            /// <summary>
            /// parameter can be automated
            /// </summary>
            kCanAutomate = 1 << 0,
            
            /// <summary>
            /// parameter cannot be changed from outside the plug-in (implies that kCanAutomate is NOT set)
            /// </summary>
            kIsReadOnly = 1 << 1,
            
            /// <summary>
            /// attempts to set the parameter value out of the limits will result in a wrap around [SDK 3.0.2]
            /// </summary>
            kIsWrapAround = 1 << 2,
            
            /// <summary>
            /// parameter should be displayed as list in generic editor or automation editing [SDK 3.1.0]
            /// </summary>
            kIsList = 1 << 3,
            
            /// <summary>
            /// parameter should be NOT displayed and cannot be changed from outside the plug-in 
            /// (implies that kCanAutomate is NOT set and kIsReadOnly is set) [SDK 3.7.0]
            /// </summary>
            kIsHidden = 1 << 4,
            
            /// <summary>
            /// parameter is a program change (unitId gives info about associated unit 
            /// - see @ref vst3ProgramLists)
            /// </summary>
            kIsProgramChange = 1 << 15,
            
            /// <summary>
            /// special bypass parameter (only one allowed): plug-in can handle bypass
            /// (highly recommended to export a bypass parameter for effect plug-in)
            /// </summary>
            kIsBypass = 1 << 16,
        }
    }
    
    public partial record struct UnitID(int Value);
    
    /// <summary>
    /// Edit controller component interface extension: Vst::IEditController2
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst310- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.1.0]
    /// - [optional]Extension to allow the host to inform the plug-in about the host Knob Mode,
    /// and to open the plug-in about box or help documentation.
    /// </remarks>
    /// <seealso cref="EditControllerIEditController,"/>
    public unsafe partial struct IEditController2 : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IEditController2*, LibVst.KnobMode, ComResult>)&setKnobMode_ccw;
            vtbl[4] = (delegate*unmanaged<IEditController2*, byte, ComResult>)&openHelp_ccw;
            vtbl[5] = (delegate*unmanaged<IEditController2*, byte, ComResult>)&openAboutBox_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Host could set the Knob Mode for the plug-in. Return kResultFalse means not supported mode.
        /// </summary>
        /// <seealso cref="KnobModes. "/>
        [UnmanagedCallersOnly]
        private static partial ComResult setKnobMode_ccw(IEditController2* self, LibVst.KnobMode mode);
        
        /// <summary>
        /// Host could ask to open the plug-in help (could be: opening a PDF document or link to a web page).
        /// The host could call it with onlyCheck set to true for testing support of open Help. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult openHelp_ccw(IEditController2* self, [MarshalAs(UnmanagedType.U1)] byte onlyCheck);
        
        /// <summary>
        /// Host could ask to open the plug-in about box.
        /// The host could call it with onlyCheck set to true for testing support of open AboutBox. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult openAboutBox_ccw(IEditController2* self, [MarshalAs(UnmanagedType.U1)] byte onlyCheck);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditController2, 0x7F4EFE59, 0xF3204967, 0xAC27A3AE, 0xAFB63038)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x7f, 0x4e, 0xfe, 0x59, 0xf3, 0x20, 0x49, 0x67, 0xac, 0x27, 0xa3, 0xae, 0xaf, 0xb6, 0x30, 0x38 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x59, 0xfe, 0x4e, 0x7f, 0x67, 0x49, 0x20, 0xf3, 0xae, 0xa3, 0x27, 0xac, 0x38, 0x30, 0xb6, 0xaf })
                    )));
            }
        }
    }
    
    public partial record struct KnobMode(int Value);
    
    /// <summary>
    /// MIDI Mapping interface: Vst::IMidiMapping
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst301- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.0.1]
    /// - [optional]MIDI controllers are not transmitted directly to a VST component. MIDI as hardware protocol has
    /// restrictions that can be avoided in software. Controller data in particular come along with unclear
    /// and often ignored semantics. On top of this they can interfere with regular parameter automation and
    /// the host is unaware of what happens in the plug-in when passing MIDI controllers directly.So any functionality that is to be controlled by MIDI controllers must be exported as regular parameter.
    /// The host will transform incoming MIDI controller data using this interface and transmit them as regular
    /// parameter change. This allows the host to automate them in the same way as other parameters.
    /// CtrlNumber can be a typical MIDI controller value extended to some others values like pitchbend or
    /// aftertouch (see @ref ControllerNumbers).If the mapping has changed, the plug-in must call IComponentHandler::restartComponent (kMidiCCAssignmentChanged)
    /// to inform the host about this change. IMidiMappingExample Example@code {.cpp}
    /// //--------------------------------------
    /// // in myeditcontroller.h
    /// class MyEditController: public EditControllerEx1, public IMidiMapping
    /// {
    /// 	//...
    /// 	//---IMidiMapping---------------------------
    /// 	tresult PLUGIN_API getMidiControllerAssignment (int32 busIndex, int16 channel, CtrlNumber midiControllerNumber, ParamID&amp; id) SMTG_OVERRIDE;
    /// 	//---Interface---------
    /// 	OBJ_METHODS (MyEditController, EditControllerEx1)
    /// 	DEFINE_INTERFACES
    /// 		DEF_INTERFACE (IMidiMapping)
    /// 	END_DEFINE_INTERFACES (MyEditController)
    /// 	REFCOUNT_METHODS (MyEditController)
    /// };
    /// 
    /// //--------------------------------------
    /// // in myeditcontroller.cpp
    /// tresult PLUGIN_API MyEditController::getMidiControllerAssignment (int32 busIndex, int16 midiChannel, CtrlNumber midiControllerNumber, ParamID&amp; tag)
    /// {
    /// 	// for my first Event bus and for MIDI channel 0 and for MIDI CC Volume only
    /// 	if (busIndex == 0 &amp;&amp; midiChannel == 0 &amp;&amp; midiControllerNumber == kCtrlVolume)
    /// 	{
    /// 		tag = kGainId;
    /// 		return kResultTrue;
    /// 	}
    /// 	return kResultFalse;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IMidiMapping : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IMidiMapping*, int, short, LibVst.CtrlNumber, LibVst.ParamID*, ComResult>)&getMidiControllerAssignment_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets an (preferred) associated ParamID for a given Input Event Bus index, channel and MIDI Controller.
        /// </summary>
        /// <param name="busIndex">- index of Input Event Bus</param>
        /// <param name="channel">- channel of the bus</param>
        /// <param name="midiControllerNumber">- see @ref ControllerNumbers for expected values (could be bigger than 127)</param>
        /// <param name="id">- return the associated ParamID to the given midiControllerNumber</param>
        [UnmanagedCallersOnly]
        private static partial ComResult getMidiControllerAssignment_ccw(IMidiMapping* self, int busIndex, short channel, LibVst.CtrlNumber midiControllerNumber, LibVst.ParamID* id);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMidiMapping, 0xDF0FF9F7, 0x49B74669, 0xB63AB732, 0x7ADBF5E5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xdf, 0x0f, 0xf9, 0xf7, 0x49, 0xb7, 0x46, 0x69, 0xb6, 0x3a, 0xb7, 0x32, 0x7a, 0xdb, 0xf5, 0xe5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xf7, 0xf9, 0x0f, 0xdf, 0x69, 0x46, 0xb7, 0x49, 0x32, 0xb7, 0x3a, 0xb6, 0xe5, 0xf5, 0xdb, 0x7a })
                    )));
            }
        }
    }
    
    public partial record struct CtrlNumber(short Value);
    
    /// <summary>
    /// Parameter Editing from host: Vst::IEditControllerHostEditing
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]If this interface is implemented by the edit controller, and when performing edits from outside
    /// the plug-in (host / remote) of a not automatable and not read-only, and not hidden flagged parameter (kind of helper parameter),
    /// the host will start with a beginEditFromHost before calling setParamNormalized and end with an endEditFromHost.
    /// Here the sequence that the host will call: IEditControllerExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// plugEditController-&gt;beginEditFromHost (id);
    /// plugEditController-&gt;setParamNormalized (id, value);
    /// plugEditController-&gt;setParamNormalized (id, value + 0.1);
    /// // ...
    /// plugEditController-&gt;endEditFromHost (id);
    /// @endcode
    /// </remarks>
    /// <seealso cref="IEditController"/>
    public unsafe partial struct IEditControllerHostEditing : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 2;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IEditControllerHostEditing*, LibVst.ParamID, ComResult>)&beginEditFromHost_ccw;
            vtbl[4] = (delegate*unmanaged<IEditControllerHostEditing*, LibVst.ParamID, ComResult>)&endEditFromHost_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called before a setParamNormalized sequence, a endEditFromHost will be call at the end of the editing action.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult beginEditFromHost_ccw(IEditControllerHostEditing* self, LibVst.ParamID paramID);
        
        /// <summary>
        /// Called after a beginEditFromHost and a sequence of setParamNormalized.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult endEditFromHost_ccw(IEditControllerHostEditing* self, LibVst.ParamID paramID);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditControllerHostEditing, 0xC1271208, 0x70594098, 0xB9DD34B3, 0x6BB0195E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc1, 0x27, 0x12, 0x08, 0x70, 0x59, 0x40, 0x98, 0xb9, 0xdd, 0x34, 0xb3, 0x6b, 0xb0, 0x19, 0x5e })
                        : new ReadOnlySpan<byte>(new byte[] { 0x08, 0x12, 0x27, 0xc1, 0x98, 0x40, 0x59, 0x70, 0xb3, 0x34, 0xdd, 0xb9, 0x5e, 0x19, 0xb0, 0x6b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for note expression event support: Vst::INoteExpressionController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]With this plug-in interface, the host can retrieve all necessary note expression information supported by the plug-in.
    /// Note expression information (@ref NoteExpressionTypeInfo) are specific for given channel and event bus.Note that there is only one NoteExpressionTypeID per given channel of an event bus.The method getNoteExpressionStringByValue allows conversion from a normalized value to a string representation
    /// and the getNoteExpressionValueByString method from a string to a normalized value.When the note expression state changes (for example when switching presets) the plug-in needs
    /// to inform the host about it via @ref IComponentHandler::restartComponent (kNoteExpressionChanged).
    /// </remarks>
    public unsafe partial struct INoteExpressionController : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<INoteExpressionController*, int, short, int>)&getNoteExpressionCount_ccw;
            vtbl[4] = (delegate*unmanaged<INoteExpressionController*, int, short, int, LibVst.NoteExpressionTypeInfo*, ComResult>)&getNoteExpressionInfo_ccw;
            vtbl[5] = (delegate*unmanaged<INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, LibVst.NoteExpressionValue, LibVst.String128*, ComResult>)&getNoteExpressionStringByValue_ccw;
            vtbl[6] = (delegate*unmanaged<INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, char*, LibVst.NoteExpressionValue*, ComResult>)&getNoteExpressionValueByString_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns number of supported note change types for event bus index and channel.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int getNoteExpressionCount_ccw(INoteExpressionController* self, int busIndex, short channel);
        
        /// <summary>
        /// Returns note change type info.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getNoteExpressionInfo_ccw(INoteExpressionController* self, int busIndex, short channel, int noteExpressionIndex, LibVst.NoteExpressionTypeInfo* info);
        
        /// <summary>
        /// Gets a user readable representation of the normalized note change value.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getNoteExpressionStringByValue_ccw(INoteExpressionController* self, int busIndex, short channel, LibVst.NoteExpressionTypeID id, LibVst.NoteExpressionValue valueNormalized, LibVst.String128* @string);
        
        /// <summary>
        /// Converts the user readable representation to the normalized note change value.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getNoteExpressionValueByString_ccw(INoteExpressionController* self, int busIndex, short channel, LibVst.NoteExpressionTypeID id, char* @string, LibVst.NoteExpressionValue* valueNormalized);
        
        /// <summary>
        /// DECLARE_CLASS_IID (INoteExpressionController, 0xB7F8F859, 0x41234872, 0x91169581, 0x4F3721A3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xb7, 0xf8, 0xf8, 0x59, 0x41, 0x23, 0x48, 0x72, 0x91, 0x16, 0x95, 0x81, 0x4f, 0x37, 0x21, 0xa3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x59, 0xf8, 0xf8, 0xb7, 0x72, 0x48, 0x23, 0x41, 0x81, 0x95, 0x16, 0x91, 0xa3, 0x21, 0x37, 0x4f })
                    )));
            }
        }
    }
    
    /// <summary>
    /// NoteExpressionTypeInfo is the structure describing a note expression supported by the plug-in.
    /// This structure is used by the method @ref INoteExpressionController::getNoteExpressionInfo.
    /// </summary>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteExpressionTypeInfo
    {
        /// <summary>
        /// unique identifier of this note Expression type
        /// </summary>
        public LibVst.NoteExpressionTypeID typeId;
        
        /// <summary>
        /// note Expression type title (e.g. "Volume")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// note Expression type short title (e.g. "Vol")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// note Expression type unit (e.g. "dB")
        /// </summary>
        public LibVst.String128 units;
        
        /// <summary>
        /// id of unit this NoteExpression belongs to (see @ref vst3Units), in order to sort the note expression, it is possible to use unitId like for parameters. -1 means no unit used.
        /// </summary>
        public int unitId;
        
        /// <summary>
        /// value description see @ref NoteExpressionValueDescription
        /// </summary>
        public LibVst.NoteExpressionValueDescription valueDesc;
        
        /// <summary>
        /// optional associated parameter ID (for mapping from note expression to global (using the parameter automation for example) and back). Only used when kAssociatedParameterIDValid is set in flags.
        /// </summary>
        public LibVst.ParamID associatedParameterId;
        
        /// <summary>
        /// NoteExpressionTypeFlags (see below)
        /// </summary>
        public int flags;
        
        public enum NoteExpressionTypeFlags
        {
            /// <summary>
            /// event is bipolar (centered), otherwise unipolar
            /// </summary>
            kIsBipolar = 1 << 0,
            
            /// <summary>
            /// event occurs only one time for its associated note (at begin of the noteOn)
            /// </summary>
            kIsOneShot = 1 << 1,
            
            /// <summary>
            /// This note expression will apply an absolute change to the sound (not relative (offset))
            /// </summary>
            kIsAbsolute = 1 << 2,
            
            /// <summary>
            /// indicates that the associatedParameterID is valid and could be used
            /// </summary>
            kAssociatedParameterIDValid = 1 << 3,
        }
    }
    
    /// <summary>
    /// Description of a Note Expression Type
    /// This structure is part of the NoteExpressionTypeInfo structure, it describes for given NoteExpressionTypeID its default value
    /// (for example 0.5 for a kTuningTypeID (kIsBipolar: centered)), its minimum and maximum (for predefined NoteExpressionTypeID the full range is predefined too)
    /// and a stepCount when the given NoteExpressionTypeID is limited to discrete values (like on/off state).
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct NoteExpressionValueDescription
    {
        /// <summary>
        /// default normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue defaultValue;
        
        /// <summary>
        /// minimum normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue minimum;
        
        /// <summary>
        /// maximum normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue maximum;
        
        /// <summary>
        /// number of discrete steps (0: continuous, 1: toggle, discrete value otherwise - see @ref vst3ParameterIntro)
        /// </summary>
        public int stepCount;
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for key switches support: Vst::IKeyswitchController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]When a (instrument) plug-in supports such interface, the host could get from the plug-in the current set
    /// of used key switches (megatrig/articulation) for a given channel of a event bus and then automatically use them (like in Cubase 6) to
    /// create VST Expression Map (allowing to associated symbol to a given articulation / key switch).
    /// </remarks>
    public unsafe partial struct IKeyswitchController : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 2;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IKeyswitchController*, int, short, int>)&getKeyswitchCount_ccw;
            vtbl[4] = (delegate*unmanaged<IKeyswitchController*, int, short, int, LibVst.KeyswitchInfo*, ComResult>)&getKeyswitchInfo_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns number of supported key switches for event bus index and channel.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int getKeyswitchCount_ccw(IKeyswitchController* self, int busIndex, short channel);
        
        /// <summary>
        /// Returns key switch info.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getKeyswitchInfo_ccw(IKeyswitchController* self, int busIndex, short channel, int keySwitchIndex, LibVst.KeyswitchInfo* info);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IKeyswitchController, 0x1F2F76D3, 0xBFFB4B96, 0xB99527A5, 0x5EBCCEF4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x1f, 0x2f, 0x76, 0xd3, 0xbf, 0xfb, 0x4b, 0x96, 0xb9, 0x95, 0x27, 0xa5, 0x5e, 0xbc, 0xce, 0xf4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xd3, 0x76, 0x2f, 0x1f, 0x96, 0x4b, 0xfb, 0xbf, 0xa5, 0x27, 0x95, 0xb9, 0xf4, 0xce, 0xbc, 0x5e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// KeyswitchInfo is the structure describing a key switch
    /// This structure is used by the method @ref IKeyswitchController::getKeyswitchInfo.
    /// </summary>
    /// <seealso cref="IKeyswitchController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct KeyswitchInfo
    {
        /// <summary>
        /// see KeyswitchTypeID
        /// </summary>
        public LibVst.KeyswitchTypeID typeId;
        
        /// <summary>
        /// name of key switch (e.g. "Accentuation")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// short title (e.g. "Acc")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// associated main key switch min (value between [0, 127])
        /// </summary>
        public int keyswitchMin;
        
        /// <summary>
        /// associated main key switch max (value between [0, 127])
        /// </summary>
        public int keyswitchMax;
        
        public int keyRemapped;
        
        /// <summary>
        /// id of unit this key switch belongs to (see @ref vst3Units), -1 means no unit used.
        /// </summary>
        public int unitId;
        
        /// <summary>
        /// not yet used (set to 0)
        /// </summary>
        public int flags;
    }
    
    public partial record struct KeyswitchTypeID(uint Value);
    
    /// <summary>
    /// Private plug-in message: Vst::IMessage
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [create via IHostApplication::createInstance]
    /// - [released: 3.0.0]
    /// - [mandatory]Messages are sent from a VST controller component to a VST editor component and vice versa.
    /// </remarks>
    /// <seealso cref="vst3CommunicationIAttributeList, IConnectionPoint, "/>
    public unsafe partial struct IMessage : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IMessage*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IMessage*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IMessage*, uint>)Vtbl[1])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IMessage*, uint>)Vtbl[2])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns the message ID (for example "TextMessage").
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.FIDString getMessageID()
        {
            return ((delegate*unmanaged<LibVst.IMessage*, LibVst.FIDString>)Vtbl[3])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Sets a message ID (for example "TextMessage").
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setMessageID(LibVst.FIDString id)
        {
            ((delegate*unmanaged<LibVst.IMessage*, LibVst.FIDString, void>)Vtbl[4])((LibVst.IMessage*)Unsafe.AsPointer(ref this), id);
        }
        
        /// <summary>
        /// Returns the attribute list associated to the message.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IAttributeList* getAttributes()
        {
            return ((delegate*unmanaged<LibVst.IMessage*, LibVst.IAttributeList*>)Vtbl[5])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMessage, 0x936F033B, 0xC6C047DB, 0xBB0882F8, 0x13C1E613)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x93, 0x6f, 0x03, 0x3b, 0xc6, 0xc0, 0x47, 0xdb, 0xbb, 0x08, 0x82, 0xf8, 0x13, 0xc1, 0xe6, 0x13 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x3b, 0x03, 0x6f, 0x93, 0xdb, 0x47, 0xc0, 0xc6, 0xf8, 0x82, 0x08, 0xbb, 0x13, 0xe6, 0xc1, 0x13 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Connect a component with another one: Vst::IConnectionPoint
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface is used for the communication of separate components.
    /// Note that some hosts will place a proxy object between the components so that they are not directly connected.
    /// </remarks>
    /// <seealso cref="vst3Communication"/>
    public unsafe partial struct IConnectionPoint : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IConnectionPoint*, LibVst.IConnectionPoint*, ComResult>)&connect_ccw;
            vtbl[4] = (delegate*unmanaged<IConnectionPoint*, LibVst.IConnectionPoint*, ComResult>)&disconnect_ccw;
            vtbl[5] = (delegate*unmanaged<IConnectionPoint*, LibVst.IMessage*, ComResult>)&notify_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, uint>)Vtbl[1])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, uint>)Vtbl[2])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Connects this instance with another connection point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult connect(LibVst.IConnectionPoint* other)
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, ComResult>)Vtbl[3])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), other);
        }
        
        /// <summary>
        /// Disconnects a given connection point from this.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult disconnect(LibVst.IConnectionPoint* other)
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, ComResult>)Vtbl[4])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), other);
        }
        
        /// <summary>
        /// Called when a message has been sent from the connection point to this.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notify(LibVst.IMessage* message)
        {
            return ((delegate*unmanaged<LibVst.IConnectionPoint*, LibVst.IMessage*, ComResult>)Vtbl[5])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), message);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Connects this instance with another connection point.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult connect_ccw(IConnectionPoint* self, LibVst.IConnectionPoint* other);
        
        /// <summary>
        /// Disconnects a given connection point from this.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult disconnect_ccw(IConnectionPoint* self, LibVst.IConnectionPoint* other);
        
        /// <summary>
        /// Called when a message has been sent from the connection point to this.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult notify_ccw(IConnectionPoint* self, LibVst.IMessage* message);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IConnectionPoint, 0x70A4156F, 0x6E6E4026, 0x989148BF, 0xAA60D8D1)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x70, 0xa4, 0x15, 0x6f, 0x6e, 0x6e, 0x40, 0x26, 0x98, 0x91, 0x48, 0xbf, 0xaa, 0x60, 0xd8, 0xd1 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6f, 0x15, 0xa4, 0x70, 0x26, 0x40, 0x6e, 0x6e, 0xbf, 0x48, 0x91, 0x98, 0xd1, 0xd8, 0x60, 0xaa })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic host callback interface: Vst::IHostApplication
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [passed as 'context' in to IPluginBase::initialize () ]
    /// - [released: 3.0.0]
    /// - [mandatory]Basic VST host application interface.
    /// </remarks>
    public unsafe partial struct IHostApplication : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IHostApplication*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IHostApplication*, uint>)Vtbl[1])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IHostApplication*, uint>)Vtbl[2])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Gets host application name.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getName(LibVst.String128* name)
        {
            return ((delegate*unmanaged<LibVst.IHostApplication*, LibVst.String128*, ComResult>)Vtbl[3])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this), name);
        }
        
        /// <summary>
        /// Creates host object (e.g. Vst::IMessage).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(Guid* cid, Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IHostApplication*, Guid*, Guid*, void**, ComResult>)Vtbl[4])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this), cid, _iid, obj);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IHostApplication, 0x58E595CC, 0xDB2D4969, 0x8B6AAF8C, 0x36A664E5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x58, 0xe5, 0x95, 0xcc, 0xdb, 0x2d, 0x49, 0x69, 0x8b, 0x6a, 0xaf, 0x8c, 0x36, 0xa6, 0x64, 0xe5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xcc, 0x95, 0xe5, 0x58, 0x69, 0x49, 0x2d, 0xdb, 0x8c, 0xaf, 0x6a, 0x8b, 0xe5, 0x64, 0xa6, 0x36 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to VST 2 Wrapper interface: Vst::IVst3ToVst2Wrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.1.0]
    /// - [mandatory]Informs the plug-in that a VST 3 to VST 2 wrapper is used between the plug-in and the real host.
    /// Implemented by the VST 2 Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct IVst3ToVst2Wrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToVst2Wrapper, 0x29633AEC, 0x1D1C47E2, 0xBB85B97B, 0xD36EAC61)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x29, 0x63, 0x3a, 0xec, 0x1d, 0x1c, 0x47, 0xe2, 0xbb, 0x85, 0xb9, 0x7b, 0xd3, 0x6e, 0xac, 0x61 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xec, 0x3a, 0x63, 0x29, 0xe2, 0x47, 0x1c, 0x1d, 0x7b, 0xb9, 0x85, 0xbb, 0x61, 0xac, 0x6e, 0xd3 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to AU Wrapper interface: Vst::IVst3ToAUWrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.1.0]
    /// - [mandatory]Informs the plug-in that a VST 3 to AU wrapper is used between the plug-in and the real host.
    /// Implemented by the AU Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct IVst3ToAUWrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToAUWrapper, 0xA3B8C6C5, 0xC0954688, 0xB0916F0B, 0xB697AA44)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xa3, 0xb8, 0xc6, 0xc5, 0xc0, 0x95, 0x46, 0x88, 0xb0, 0x91, 0x6f, 0x0b, 0xb6, 0x97, 0xaa, 0x44 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc5, 0xc6, 0xb8, 0xa3, 0x88, 0x46, 0x95, 0xc0, 0x0b, 0x6f, 0x91, 0xb0, 0x44, 0xaa, 0x97, 0xb6 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to AAX Wrapper interface: Vst::IVst3ToAAXWrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst368- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.8]
    /// - [mandatory]Informs the plug-in that a VST 3 to AAX wrapper is used between the plug-in and the real host.
    /// Implemented by the AAX Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct IVst3ToAAXWrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToAAXWrapper, 0x6D319DC6, 0x60C56242, 0xB32C951B, 0x93BEF4C6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6d, 0x31, 0x9d, 0xc6, 0x60, 0xc5, 0x62, 0x42, 0xb3, 0x2c, 0x95, 0x1b, 0x93, 0xbe, 0xf4, 0xc6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc6, 0x9d, 0x31, 0x6d, 0x42, 0x62, 0xc5, 0x60, 0x1b, 0x95, 0x2c, 0xb3, 0xc6, 0xf4, 0xbe, 0x93 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Wrapper MPE Support interface: Vst::IVst3WrapperMPESupport
    /// </summary>
    /// <remarks>
    ///  vstIHost vst3612- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.12]
    /// - [optional]Implemented on wrappers that support MPE to Note Expression translation.By default, MPE input processing is enabled, the masterChannel will be zero, the memberBeginChannel
    /// will be one and the memberEndChannel will be 14.As MPE is a subset of the VST3 Note Expression feature, mapping from the three MPE expressions is
    /// handled via the INoteExpressionPhysicalUIMapping interface.
    /// </remarks>
    public unsafe partial struct IVst3WrapperMPESupport : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IVst3WrapperMPESupport*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IVst3WrapperMPESupport*, uint>)Vtbl[1])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IVst3WrapperMPESupport*, uint>)Vtbl[2])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// enable or disable MPE processing
        /// </summary>
        /// <param name="state">true to enable, false to disable MPE processing</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult enableMPEInputProcessing([MarshalAs(UnmanagedType.U1)] byte state)
        {
            return ((delegate*unmanaged<LibVst.IVst3WrapperMPESupport*, byte, ComResult>)Vtbl[3])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this), state);
        }
        
        /// <summary>
        /// setup the MPE processing
        /// </summary>
        /// <param name="masterChannel">MPE master channel (zero based)</param>
        /// <param name="memberBeginChannel">MPE member begin channel (zero based)</param>
        /// <param name="memberEndChannel">MPE member end channel (zero based)</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setMPEInputDeviceSettings(int masterChannel, int memberBeginChannel, int memberEndChannel)
        {
            return ((delegate*unmanaged<LibVst.IVst3WrapperMPESupport*, int, int, int, ComResult>)Vtbl[4])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this), masterChannel, memberBeginChannel, memberEndChannel);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3WrapperMPESupport, 0x44149067, 0x42CF4BF9, 0x8800B750, 0xF7359FE3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x44, 0x14, 0x90, 0x67, 0x42, 0xcf, 0x4b, 0xf9, 0x88, 0x00, 0xb7, 0x50, 0xf7, 0x35, 0x9f, 0xe3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x67, 0x90, 0x14, 0x44, 0xf9, 0x4b, 0xcf, 0x42, 0x50, 0xb7, 0x00, 0x88, 0xe3, 0x9f, 0x35, 0xf7 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for Inter-App Audio Preset Management
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst360- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.0]
    /// </remarks>
    public unsafe partial struct IInterAppAudioPresetManager : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IInterAppAudioPresetManager*, ComResult>)&runLoadPresetBrowser_ccw;
            vtbl[4] = (delegate*unmanaged<IInterAppAudioPresetManager*, ComResult>)&runSavePresetBrowser_ccw;
            vtbl[5] = (delegate*unmanaged<IInterAppAudioPresetManager*, ComResult>)&loadNextPreset_ccw;
            vtbl[6] = (delegate*unmanaged<IInterAppAudioPresetManager*, ComResult>)&loadPreviousPreset_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Open the Preset Browser in order to load a preset
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult runLoadPresetBrowser_ccw(IInterAppAudioPresetManager* self);
        
        /// <summary>
        /// Open the Preset Browser in order to save a preset
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult runSavePresetBrowser_ccw(IInterAppAudioPresetManager* self);
        
        /// <summary>
        /// Load the next available preset
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult loadNextPreset_ccw(IInterAppAudioPresetManager* self);
        
        /// <summary>
        /// Load the previous available preset
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult loadPreviousPreset_ccw(IInterAppAudioPresetManager* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInterAppAudioPresetManager, 0xADE6FCC4, 0x46C94E1D, 0xB3B49A80, 0xC93FEFDD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xad, 0xe6, 0xfc, 0xc4, 0x46, 0xc9, 0x4e, 0x1d, 0xb3, 0xb4, 0x9a, 0x80, 0xc9, 0x3f, 0xef, 0xdd })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc4, 0xfc, 0xe6, 0xad, 0x1d, 0x4e, 0xc9, 0x46, 0x80, 0x9a, 0xb4, 0xb3, 0xdd, 0xef, 0x3f, 0xc9 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Inter-App Audio host Interface.
    /// </summary>
    /// <remarks>
    ///  vstIHost vst360- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.0]
    /// - [optional]Implemented by the InterAppAudio Wrapper.
    /// </remarks>
    public unsafe partial struct IInterAppAudioHost : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, uint>)Vtbl[1])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, uint>)Vtbl[2])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// get the size of the screen
        /// </summary>
        /// <param name="size">size of the screen</param>
        /// <param name="scale">scale of the screen</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getScreenSize(LibVst.ViewRect* size, float* scale)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, LibVst.ViewRect*, float*, ComResult>)Vtbl[3])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), size, scale);
        }
        
        /// <summary>
        /// get status of connection
        /// </summary>
        /// <returns>kResultTrue if an Inter-App Audio connection is established</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult connectedToHost()
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, ComResult>)Vtbl[4])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// switch to the host.
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult switchToHost()
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, ComResult>)Vtbl[5])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// send a remote control event to the host
        /// </summary>
        /// <param name="event">event type, see AudioUnitRemoteControlEvent in the iOS SDK documentation for possible types</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult sendRemoteControlEvent(uint @event)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, uint, ComResult>)Vtbl[6])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), @event);
        }
        
        /// <summary>
        /// ask for the host icon.
        /// </summary>
        /// <param name="icon">pointer to a CGImageRef</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getHostIcon(void** icon)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, void**, ComResult>)Vtbl[7])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), icon);
        }
        
        /// <summary>
        /// schedule an event from the user interface thread
        /// </summary>
        /// <param name="event">the event to schedule</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult scheduleEventFromUI(LibVst.Event* @event)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, LibVst.Event*, ComResult>)Vtbl[8])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), @event);
        }
        
        /// <summary>
        /// get the preset manager
        /// </summary>
        /// <param name="cid">class ID to use by the preset manager</param>
        /// <returns>the preset manager. Needs to be released by called.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IInterAppAudioPresetManager* createPresetManager(Guid* cid)
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, Guid*, LibVst.IInterAppAudioPresetManager*>)Vtbl[9])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), cid);
        }
        
        /// <summary>
        /// show the settings view
        /// currently includes MIDI settings and Tempo setting
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult showSettingsView()
        {
            return ((delegate*unmanaged<LibVst.IInterAppAudioHost*, ComResult>)Vtbl[10])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInterAppAudioHost, 0x0CE5743D, 0x68DF415E, 0xAE285BD4, 0xE2CDC8FD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x0c, 0xe5, 0x74, 0x3d, 0x68, 0xdf, 0x41, 0x5e, 0xae, 0x28, 0x5b, 0xd4, 0xe2, 0xcd, 0xc8, 0xfd })
                        : new ReadOnlySpan<byte>(new byte[] { 0x3d, 0x74, 0xe5, 0x0c, 0x5e, 0x41, 0xdf, 0x68, 0xd4, 0x5b, 0x28, 0xae, 0xfd, 0xc8, 0xcd, 0xe2 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for Inter-App Audio connection state change notifications
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst360- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.0]
    /// </remarks>
    public unsafe partial struct IInterAppAudioConnectionNotification : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IInterAppAudioConnectionNotification*, byte, void>)&onInterAppAudioConnectionStateChange_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// called when the Inter-App Audio connection state changes
        /// </summary>
        /// <param name="newState">true if an Inter-App Audio connection is established, otherwise false</param>
        [UnmanagedCallersOnly]
        private static partial void onInterAppAudioConnectionStateChange_ccw(IInterAppAudioConnectionNotification* self, [MarshalAs(UnmanagedType.U1)] byte newState);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInterAppAudioConnectionNotification, 0x6020C72D, 0x5FC24AA1, 0xB0950DB5, 0xD7D6D5CF)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x60, 0x20, 0xc7, 0x2d, 0x5f, 0xc2, 0x4a, 0xa1, 0xb0, 0x95, 0x0d, 0xb5, 0xd7, 0xd6, 0xd5, 0xcf })
                        : new ReadOnlySpan<byte>(new byte[] { 0x2d, 0xc7, 0x20, 0x60, 0xa1, 0x4a, 0xc2, 0x5f, 0xb5, 0x0d, 0x95, 0xb0, 0xcf, 0xd5, 0xd6, 0xd7 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// MIDI Learn interface: Vst::IMidiLearn
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst3612- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.12]
    /// - [optional]If this interface is implemented by the edit controller, the host will call this method whenever
    /// there is live MIDI-CC input for the plug-in. This way, the plug-in can change its MIDI-CC parameter
    /// mapping and inform the host via the IComponentHandler::restartComponent with the
    /// kMidiCCAssignmentChanged flag.
    /// Use this if you want to implement custom MIDI-Learn functionality in your plug-in.@code {.cpp}
    /// //------------------------------------------------
    /// // in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::IMidiLearn
    /// {
    /// 	// ...
    /// 	//--- IMidiLearn ---------------------------------
    /// 	tresult PLUGIN_API onLiveMIDIControllerInput (int32 busIndex, int16 channel,
    /// 												  CtrlNumber midiCC) SMTG_OVERRIDE;
    /// 	// ...
    /// 
    /// 	OBJ_METHODS (MyController, Vst::EditController)
    /// 	DEFINE_INTERFACES
    /// 		// ...
    /// 		DEF_INTERFACE (Vst::IMidiLearn)
    /// 	END_DEFINE_INTERFACES (Vst::EditController)
    /// 	//...
    /// }
    /// 
    /// //------------------------------------------------
    /// // in mycontroller.cpp
    /// #include "pluginterfaces/vst/ivstmidilearn.h
    /// 
    /// namespace Steinberg {
    /// 	namespace Vst {
    /// 		DEF_CLASS_IID (IMidiLearn)
    /// 	}
    /// }
    /// 
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::onLiveMIDIControllerInput (int32 busIndex, 
    /// 							int16 channel, CtrlNumber midiCC)
    /// {
    /// 	// if we are not in doMIDILearn (triggered by a UI button for example) 
    /// 	// or wrong channel then return
    /// 	if (!doMIDILearn || busIndex != 0 || channel != 0 || midiLearnParamID == InvalidParamID)
    /// 		return kResultFalse;
    /// 
    /// 	// adapt our internal MIDICC -&gt; parameterID mapping
    /// 	midiCCMapping[midiCC] = midiLearnParamID;
    /// 
    /// 	// new mapping then inform the host that our MIDI assignment has changed
    /// 	if (auto componentHandler = getComponentHandler ())
    /// 	{
    /// 		componentHandler-&gt;restartComponent (kMidiCCAssignmentChanged);
    /// 	}
    /// 	return kResultTrue;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IMidiLearn : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IMidiLearn*, int, short, LibVst.CtrlNumber, ComResult>)&onLiveMIDIControllerInput_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called on live input MIDI-CC change associated to a given bus index and MIDI channel
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult onLiveMIDIControllerInput_ccw(IMidiLearn* self, int busIndex, short channel, LibVst.CtrlNumber midiCC);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMidiLearn, 0x6B2449CC, 0x419740B5, 0xAB3C79DA, 0xC5FE5C86)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6b, 0x24, 0x49, 0xcc, 0x41, 0x97, 0x40, 0xb5, 0xab, 0x3c, 0x79, 0xda, 0xc5, 0xfe, 0x5c, 0x86 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xcc, 0x49, 0x24, 0x6b, 0xb5, 0x40, 0x97, 0x41, 0xda, 0x79, 0x3c, 0xab, 0x86, 0x5c, 0xfe, 0xc5 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Edit controller component interface extension: Vst::IParameterFunctionName
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst370- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.7.0]
    /// - [optional]This interface allows the host to get a parameter associated to a specific meaning (a functionName)
    /// for a given unit. The host can use this information, for example, for drawing a Gain Reduction meter
    /// in its own UI. In order to get the plain value of this parameter, the host should use the
    /// IEditController::normalizedParamToPlain. The host can automatically map parameters to dedicated UI
    /// controls, such as the wet-dry mix knob or Randomize button. IParameterFunctionNameExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// // here an example of how a VST3 plug-in could support this IParameterFunctionName interface.
    /// // we need to define somewhere the iids:
    /// 
    /// in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::IParameterFunctionName
    /// {
    ///     ...
    ///     tresult PLUGIN_API getParameterIDFromFunctionName (UnitID unitID, FIDString functionName,
    ///                                                     Vst::ParamID&amp; paramID) override;
    ///     ...
    /// 
    ///     OBJ_METHODS (MyController, Vst::EditController)
    ///     DEFINE_INTERFACES
    ///         ...
    ///         DEF_INTERFACE (Vst::IParameterFunctionName)
    ///     END_DEFINE_INTERFACES (Vst::EditController)
    ///     DELEGATE_REFCOUNT (Vst::EditController)
    ///     ...
    /// }
    /// 
    /// #include "ivstparameterfunctionname.h"
    /// namespace Steinberg {
    ///     namespace Vst {
    ///         DEF_CLASS_IID (IParameterFunctionName)
    ///     }
    /// }
    /// 
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::getParameterIDFromFunctionName (UnitID unitID, FIDString
    /// functionName, Vst::ParamID&amp; paramID)
    /// {
    ///     using namespace Vst;
    /// 
    ///     paramID = kNoParamId;
    /// 
    ///     if (unitID == kRootUnitId &amp;&amp; FIDStringsEqual (functionName, kCompGainReduction))
    ///         paramID = kMyGainReductionId;
    /// 
    ///     return (paramID != kNoParamId) ? kResultOk : kResultFalse;
    /// }
    /// 
    /// //--- a host implementation example: --------------------
    /// ...
    /// FUnknownPtr&lt;Vst::IParameterFunctionName&gt; functionName (mEditController-&gt;getIEditController ());
    /// if (functionName)
    /// {
    ///     Vst::ParamID paramID;
    ///     if (functionName-&gt;getParameterIDFromFunctionName (kRootUnitId,
    ///                                                       Vst::FunctionNameType::kCompGainReduction, paramID) == kResultTrue)
    ///     {
    ///         // paramID could be cached for performance issue
    ///         ParamValue norm = mEditController-&gt;getIEditController ()-&gt;getParamNormalized (paramID);
    ///         ParamValue plain = mEditController-&gt;getIEditController ()-&gt;normalizedParamToPlain (paramID, norm);
    ///         // plain is something like -6 (-6dB)
    ///     }
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IParameterFunctionName : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IParameterFunctionName*, LibVst.UnitID, LibVst.FIDString, LibVst.ParamID*, ComResult>)&getParameterIDFromFunctionName_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets for the given unitID the associated paramID to a function Name.
        /// Returns kResultFalse when no found parameter (paramID is set to kNoParamId in this case).
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getParameterIDFromFunctionName_ccw(IParameterFunctionName* self, LibVst.UnitID unitID, LibVst.FIDString functionName, LibVst.ParamID* paramID);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterFunctionName, 0x6D21E1DC, 0x91199D4B, 0xA2A02FEF, 0x6C1AE55C)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6d, 0x21, 0xe1, 0xdc, 0x91, 0x19, 0x9d, 0x4b, 0xa2, 0xa0, 0x2f, 0xef, 0x6c, 0x1a, 0xe5, 0x5c })
                        : new ReadOnlySpan<byte>(new byte[] { 0xdc, 0xe1, 0x21, 0x6d, 0x4b, 0x9d, 0x19, 0x91, 0xef, 0x2f, 0xa0, 0xa2, 0x5c, 0xe5, 0x1a, 0x6c })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for note expression event support: Vst::INoteExpressionPhysicalUIMapping
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst3611- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.11]
    /// - [optional]With this plug-in interface, the host can retrieve the preferred physical mapping associated to note
    /// expression supported by the plug-in.
    /// When the mapping changes (for example when switching presets) the plug-in needs
    /// to inform the host about it via @ref IComponentHandler::restartComponent (kNoteExpressionChanged). INoteExpressionPhysicalUIMappingExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// // here an example of how a VST3 plug-in could support this INoteExpressionPhysicalUIMapping interface.
    /// // we need to define somewhere the iids:
    /// 
    /// //in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::INoteExpressionPhysicalUIMapping
    /// {
    /// 	// ...
    /// 	//--- INoteExpressionPhysicalUIMapping ---------------------------------
    /// 	tresult PLUGIN_API getPhysicalUIMapping (int32 busIndex, int16 channel, PhysicalUIMapList&amp; list) SMTG_OVERRIDE;
    /// 	// ...
    /// 
    /// 	OBJ_METHODS (MyController, Vst::EditController)
    /// 	DEFINE_INTERFACES
    /// 		// ...
    /// 		DEF_INTERFACE (Vst::INoteExpressionPhysicalUIMapping)
    /// 	END_DEFINE_INTERFACES (Vst::EditController)
    /// 	//...
    /// }
    /// 
    /// // In mycontroller.cpp
    /// #include "pluginterfaces/vst/ivstnoteexpression.h"
    /// 
    /// namespace Steinberg {
    /// 	namespace Vst {
    /// 		DEF_CLASS_IID (INoteExpressionPhysicalUIMapping)
    /// 	}
    /// }
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::getPhysicalUIMapping (int32 busIndex, int16 channel, PhysicalUIMapList&amp; list)
    /// {
    /// 	if (busIndex == 0 &amp;&amp; channel == 0)
    /// 	{
    /// 		for (uint32 i = 0; i &lt; list.count; ++i)
    /// 		{
    /// 			NoteExpressionTypeID type = kInvalidTypeID;
    /// 			if (kPUIXMovement == list.map[i].physicalUITypeID)
    /// 				list.map[i].noteExpressionTypeID = kCustomStart + 1;
    /// 			else if (kPUIYMovement == list.map[i].physicalUITypeID)
    /// 				list.map[i].noteExpressionTypeID = kCustomStart + 2;
    /// 		}
    /// 		return kResultTrue;
    /// 	}
    /// 	return kResultFalse;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct INoteExpressionPhysicalUIMapping : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<INoteExpressionPhysicalUIMapping*, int, short, LibVst.PhysicalUIMapList*, ComResult>)&getPhysicalUIMapping_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Fills the list of mapped [physical UI (in) - note expression (out)] for a given bus index
        /// and channel.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getPhysicalUIMapping_ccw(INoteExpressionPhysicalUIMapping* self, int busIndex, short channel, LibVst.PhysicalUIMapList* list);
        
        /// <summary>
        /// DECLARE_CLASS_IID (INoteExpressionPhysicalUIMapping, 0xB03078FF, 0x94D24AC8, 0x90CCD303, 0xD4133324)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xb0, 0x30, 0x78, 0xff, 0x94, 0xd2, 0x4a, 0xc8, 0x90, 0xcc, 0xd3, 0x03, 0xd4, 0x13, 0x33, 0x24 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xff, 0x78, 0x30, 0xb0, 0xc8, 0x4a, 0xd2, 0x94, 0x03, 0xd3, 0xcc, 0x90, 0x24, 0x33, 0x13, 0xd4 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// PhysicalUIMapList describes a list of PhysicalUIMap
    /// </summary>
    /// <seealso cref="INoteExpressionPhysicalUIMapping"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PhysicalUIMapList
    {
        /// <summary>
        /// Count of entries in the map array, set by the caller of getPhysicalUIMapping.
        /// </summary>
        public uint count;
        
        /// <summary>
        /// Pointer to a list of PhysicalUIMap containing count entries.
        /// </summary>
        public LibVst.PhysicalUIMap* map;
    }
    
    /// <summary>
    /// PhysicalUIMap describes a mapping of a noteExpression Type to a Physical UI Type.
    /// It is used in PhysicalUIMapList.
    /// </summary>
    /// <seealso cref="PhysicalUIMapList "/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct PhysicalUIMap
    {
        /// <summary>
        /// This represents the physical UI. /see PhysicalUITypeIDs, this is set by the caller of
        /// getPhysicalUIMapping
        /// </summary>
        public LibVst.PhysicalUITypeID physicalUITypeID;
        
        /// <summary>
        /// This represents the associated noteExpression TypeID to the given physicalUITypeID. This
        /// will be filled by the plug-in in the call getPhysicalUIMapping, set it to kInvalidTypeID if
        /// no Note Expression is associated to the given PUI.
        /// </summary>
        public LibVst.NoteExpressionTypeID noteExpressionTypeID;
    }
    
    public partial record struct PhysicalUITypeID(uint Value);
    
    /// <summary>
    /// Host callback interface for an edit controller: Vst::IPlugInterfaceSupport
    /// </summary>
    /// <remarks>
    ///  vstIHost vst3612- [host imp]
    /// - [released: 3.6.12]
    /// - [optional]Allows a plug-in to ask the host if a given plug-in interface is supported/used by the host.
    /// It is implemented by the hostContext given when the component is initialized. IPlugInterfaceSupportExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyPluginController::initialize (FUnknown* context)
    /// {
    /// 	// ...
    /// 	FUnknownPtr&lt;IPlugInterfaceSupport&gt; plugInterfaceSupport (context);
    /// 	if (plugInterfaceSupport)
    /// 	{
    /// 		if (plugInterfaceSupport-&gt;isPlugInterfaceSupported (IMidiMapping::iid) == kResultTrue)
    /// 			// IMidiMapping is used by the host
    /// 	}
    /// 	// ...
    /// }
    /// @endcode
    /// </remarks>
    /// <seealso cref="IPluginBase"/>
    public unsafe partial struct IPlugInterfaceSupport : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IPlugInterfaceSupport*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IPlugInterfaceSupport*, uint>)Vtbl[1])((LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IPlugInterfaceSupport*, uint>)Vtbl[2])((LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Returns kResultTrue if the associated interface to the given _iid is supported/used by the host.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult isPlugInterfaceSupported(Guid* _iid)
        {
            return ((delegate*unmanaged<LibVst.IPlugInterfaceSupport*, Guid*, ComResult>)Vtbl[3])((LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this), _iid);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugInterfaceSupport, 0x4FB58B9E, 0x9EAA4E0F, 0xAB361C1C, 0xCCB56FEA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x4f, 0xb5, 0x8b, 0x9e, 0x9e, 0xaa, 0x4e, 0x0f, 0xab, 0x36, 0x1c, 0x1c, 0xcc, 0xb5, 0x6f, 0xea })
                        : new ReadOnlySpan<byte>(new byte[] { 0x9e, 0x8b, 0xb5, 0x4f, 0x0f, 0x4e, 0xaa, 0x9e, 0x1c, 0x1c, 0x36, 0xab, 0xea, 0x6f, 0xb5, 0xcc })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IParameterFinder Interface
    /// Extension for IPlugView to find view parameters (lookup value under mouse support): Vst::IParameterFinder
    /// </summary>
    /// <remarks>
    ///  pluginGUI vst302- [plug imp]
    /// - [extends IPlugView]
    /// - [released: 3.0.2]
    /// - [optional]It is highly recommended to implement this interface.
    /// A host can implement important functionality when a plug-in supports this interface.For example, all Steinberg hosts require this interface in order to support the "AI Knob".
    /// </remarks>
    public unsafe partial struct IParameterFinder : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IParameterFinder*, int, int, LibVst.ParamID*, ComResult>)&findParameter_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Find out which parameter in plug-in view is at given position (relative to plug-in view).
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult findParameter_ccw(IParameterFinder* self, int xPos, int yPos, LibVst.ParamID* resultTag);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterFinder, 0x0F618302, 0x215D4587, 0xA512073C, 0x77B9D383)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x0f, 0x61, 0x83, 0x02, 0x21, 0x5d, 0x45, 0x87, 0xa5, 0x12, 0x07, 0x3c, 0x77, 0xb9, 0xd3, 0x83 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x02, 0x83, 0x61, 0x0f, 0x87, 0x45, 0x5d, 0x21, 0x3c, 0x07, 0x12, 0xa5, 0x83, 0xd3, 0xb9, 0x77 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IPrefetchableSupport Interface
    /// Indicates that the plug-in could or not support Prefetch (dynamically): Vst::IPrefetchableSupport
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst365- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.6.5]
    /// - [optional]The plug-in should implement this interface if it needs to dynamically change between prefetchable or not.
    /// By default (without implementing this interface) the host decides in which mode the plug-in is processed.
    /// For more info about the prefetch processing mode check the ProcessModes::kPrefetch documentation. IPrefetchableSupportExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API myPlug::getPrefetchableSupport (PrefetchableSupport&amp; prefetchable)
    /// {
    /// 	prefetchable = kIsNeverPrefetchable;
    /// 
    /// 	switch (myPrefetchableMode)
    /// 	{
    /// 		case 0: prefetchable = kIsNeverPrefetchable; break;
    /// 		case 1: prefetchable = kIsYetPrefetchable; break;
    /// 		case 2: prefetchable = kIsNotYetPrefetchable; break;
    /// 	}
    /// 	return kResultOk;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IPrefetchableSupport : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IPrefetchableSupport*, LibVst.PrefetchableSupport*, ComResult>)&getPrefetchableSupport_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// retrieve the current prefetch support. Use IComponentHandler::restartComponent
        /// (kPrefetchableSupportChanged) to inform the host that this support has changed.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getPrefetchableSupport_ccw(IPrefetchableSupport* self, LibVst.PrefetchableSupport* prefetchable);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPrefetchableSupport, 0x8AE54FDA, 0xE93046B9, 0xA28555BC, 0xDC98E21E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x8a, 0xe5, 0x4f, 0xda, 0xe9, 0x30, 0x46, 0xb9, 0xa2, 0x85, 0x55, 0xbc, 0xdc, 0x98, 0xe2, 0x1e })
                        : new ReadOnlySpan<byte>(new byte[] { 0xda, 0x4f, 0xe5, 0x8a, 0xb9, 0x46, 0x30, 0xe9, 0xbc, 0x55, 0x85, 0xa2, 0x1e, 0xe2, 0x98, 0xdc })
                    )));
            }
        }
    }
    
    public partial record struct PrefetchableSupport(uint Value);
    
    /// <summary>
    /// Extended plug-in interface IEditController for a component: Vst::IXmlRepresentationController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]A representation based on XML is a way to export, structure, and group plug-ins parameters for a specific remote (hardware or software rack (such as quick controls)).@n It allows to describe each parameter more precisely (what is the best matching to a knob, different title lengths matching limited remote display,...).@n See an @ref Example. @n @n - A representation is composed of pages (this means that to see all exported parameters, the user has to navigate through the pages).
    /// - A page is composed of cells (for example 8 cells per page).
    /// - A cell is composed of layers (for example a cell could have a knob, a display, and a button, which means 3 layers).
    /// - A layer is associated to a plug-in parameter using the ParameterID as identifier:
    /// - it could be a knob with a display for title and/or value, this display uses the same parameterId, but it could an another one.
    /// - switch
    /// - link which allows to jump directly to a subpage (another page) 
    /// - more... See Vst::LayerType
    /// .@n This representation is implemented as XML text following the Document Type Definition (DTD): http://dtd.steinberg.net/VST-Remote-1.1.dtd ExampleHere an example of what should be passed in the stream of getXmlRepresentationStream:@code &lt;?xml version="1.0" encoding="utf-8"?&gt;
    /// &lt;!DOCTYPE vstXML PUBLIC "-//Steinberg//DTD VST Remote 1.1//EN" "http://dtd.steinberg.net/VST-Remote-1.1.dtd"&gt;
    /// &lt;vstXML version="1.0"&gt;
    /// 	&lt;plugin classID="341FC5898AAA46A7A506BC0799E882AE" name="Chorus" vendor="Steinberg Media Technologies" /&gt;
    /// 	&lt;originator&gt;My name&lt;/originator&gt;
    /// 	&lt;date&gt;2010-12-31&lt;/date&gt;
    /// 	&lt;comment&gt;This is an example for 4 Cells per Page for the Remote named ProductRemote 
    /// 	         from company HardwareCompany.&lt;/comment&gt;
    /// 
    /// 	&lt;!-- ===================================== --&gt;
    /// 	&lt;representation name="ProductRemote" vendor="HardwareCompany" version="1.0"&gt;
    /// 		&lt;page name="Root"&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="0"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Mix dry/wet&lt;/name&gt;
    /// 						&lt;name&gt;Mix&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="display"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="3"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Delay&lt;/name&gt;
    /// 						&lt;name&gt;Dly&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="15"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Spatial&lt;/name&gt;
    /// 						&lt;name&gt;Spat&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 		&lt;/page&gt;
    /// 		&lt;page name="Page 2"&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="LED" ledStyle="spread" parameterID="2"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Width +&lt;/name&gt;
    /// 						&lt;name&gt;Widt&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 				&lt;!--this is the switch for shape A/B--&gt;
    /// 				&lt;layer type="switch" switchStyle="pushIncLooped" parameterID="4"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="display"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="LED" ledStyle="singleDot" parameterID="17"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Sync Note +&lt;/name&gt;
    /// 						&lt;name&gt;Note&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 				&lt;!--this is the switch for sync to tempo on /off--&gt;
    /// 				&lt;layer type="switch" switchStyle="pushIncLooped" parameterID="16"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="1"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Rate&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 		&lt;/page&gt;
    /// 	&lt;/representation&gt;
    /// &lt;/vstXML&gt;
    /// @endcode
    /// </remarks>
    public unsafe partial struct IXmlRepresentationController : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IXmlRepresentationController*, LibVst.RepresentationInfo*, LibVst.IBStream*, ComResult>)&getXmlRepresentationStream_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Retrieves a stream containing a XmlRepresentation for a wanted representation info
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getXmlRepresentationStream_ccw(IXmlRepresentationController* self, LibVst.RepresentationInfo* info, LibVst.IBStream* stream);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IXmlRepresentationController, 0xA81A0471, 0x48C34DC4, 0xAC30C9E1, 0x3C8393D5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xa8, 0x1a, 0x04, 0x71, 0x48, 0xc3, 0x4d, 0xc4, 0xac, 0x30, 0xc9, 0xe1, 0x3c, 0x83, 0x93, 0xd5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x71, 0x04, 0x1a, 0xa8, 0xc4, 0x4d, 0xc3, 0x48, 0xe1, 0xc9, 0x30, 0xac, 0xd5, 0x93, 0x83, 0x3c })
                    )));
            }
        }
    }
    
    /// <summary>
    /// RepresentationInfo is the structure describing a representation
    /// This structure is used in the function
    /// </summary>
    /// <seealso cref="IXmlRepresentationController "/>
    /// <seealso cref="IXmlRepresentationController::getXmlRepresentationStream."/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct RepresentationInfo
    {
        /// <summary>
        /// Vendor name of the associated representation (remote) (eg. "Yamaha").
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// Representation (remote) Name (eg. "O2").
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// Version of this "Remote" (eg. "1.0").
        /// </summary>
        public fixed byte version[64];
        
        /// <summary>
        /// Optional: used if the representation is for a given host only (eg. "Nuendo").
        /// </summary>
        public fixed byte host[64];
    }
    
    /// <summary>
    /// Test Helper.
    /// </summary>
    /// <remarks>
    ///  TestClassThis class provides access to the component and the controller of a plug-in when running a unit
    /// test (see ITest).
    /// You get this interface as the context argument in the ITestFactory::createTests method.------------------------------------------------------------------------
    /// </remarks>
    public unsafe partial struct ITestPlugProvider : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<ITestPlugProvider*, LibVst.IComponent*>)&getComponent_ccw;
            vtbl[4] = (delegate*unmanaged<ITestPlugProvider*, LibVst.IEditController*>)&getController_ccw;
            vtbl[5] = (delegate*unmanaged<ITestPlugProvider*, LibVst.IComponent*, LibVst.IEditController*, ComResult>)&releasePlugIn_ccw;
            vtbl[6] = (delegate*unmanaged<ITestPlugProvider*, LibVst.IStringResult*, ComResult>)&getSubCategories_ccw;
            vtbl[7] = (delegate*unmanaged<ITestPlugProvider*, LibVst.FUID*, ComResult>)&getComponentUID_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, uint>)Vtbl[1])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, uint>)Vtbl[2])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IComponent* getComponent()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, LibVst.IComponent*>)Vtbl[3])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IEditController* getController()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, LibVst.IEditController*>)Vtbl[4])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult releasePlugIn(LibVst.IComponent* component, LibVst.IEditController* controller)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, LibVst.IComponent*, LibVst.IEditController*, ComResult>)Vtbl[5])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), component, controller);
        }
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getSubCategories(LibVst.IStringResult* result)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, LibVst.IStringResult*, ComResult>)Vtbl[6])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), result);
        }
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getComponentUID(LibVst.FUID* uid)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider*, LibVst.FUID*, ComResult>)Vtbl[7])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), uid);
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        [UnmanagedCallersOnly]
        private static partial LibVst.IComponent* getComponent_ccw(ITestPlugProvider* self);
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        [UnmanagedCallersOnly]
        private static partial LibVst.IEditController* getController_ccw(ITestPlugProvider* self);
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult releasePlugIn_ccw(ITestPlugProvider* self, LibVst.IComponent* component, LibVst.IEditController* controller);
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getSubCategories_ccw(ITestPlugProvider* self, LibVst.IStringResult* result);
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getComponentUID_ccw(ITestPlugProvider* self, LibVst.FUID* uid);
        
        /// <summary>
        /// DECLARE_CLASS_IID (ITestPlugProvider, 0x86BE70EE, 0x4E99430F, 0x978F1E6E, 0xD68FB5BA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x86, 0xbe, 0x70, 0xee, 0x4e, 0x99, 0x43, 0x0f, 0x97, 0x8f, 0x1e, 0x6e, 0xd6, 0x8f, 0xb5, 0xba })
                        : new ReadOnlySpan<byte>(new byte[] { 0xee, 0x70, 0xbe, 0x86, 0x0f, 0x43, 0x99, 0x4e, 0x6e, 0x1e, 0x8f, 0x97, 0xba, 0xb5, 0x8f, 0xd6 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Handling 16 Byte Globally Unique Identifiers.
    /// </summary>
    /// <remarks>
    ///  pluginBaseEach interface declares its identifier as static member inside the interface
    /// namespace (e.g. FUnknown::iid).
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct FUID
    {
        /// <summary>
        /// 
        /// </summary>
        public Guid data;
        
        public enum UIDPrintStyle
        {
            /// <summary>
            /// "INLINE_UID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kINLINE_UID,
            
            /// <summary>
            /// "DECLARE_UID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kDECLARE_UID,
            
            /// <summary>
            /// "FUID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kFUID,
            
            /// <summary>
            /// "DECLARE_CLASS_IID (Interface, 0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kCLASS_UID,
        }
    }
    
    /// <summary>
    /// Test Helper extension.
    /// </summary>
    /// <remarks>
    ///  TestClass
    /// </remarks>
    public unsafe partial struct ITestPlugProvider2 : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 9;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            ITestPlugProvider.InitializeVtbl(vtbl);
            vtbl[8] = (delegate*unmanaged<ITestPlugProvider2*, LibVst.IPluginFactory*>)&getPluginFactory_ccw;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, uint>)Vtbl[1])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, uint>)Vtbl[2])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IComponent* getComponent()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.IComponent*>)Vtbl[3])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IEditController* getController()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.IEditController*>)Vtbl[4])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult releasePlugIn(LibVst.IComponent* component, LibVst.IEditController* controller)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.IComponent*, LibVst.IEditController*, ComResult>)Vtbl[5])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this), component, controller);
        }
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getSubCategories(LibVst.IStringResult* result)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.IStringResult*, ComResult>)Vtbl[6])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this), result);
        }
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getComponentUID(LibVst.FUID* uid)
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.FUID*, ComResult>)Vtbl[7])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this), uid);
        }
        
        /// <summary>
        /// get the plugin factory.
        /// </summary>
        /// <remarks>
        /// The reference count of the returned factory object is not increased when calling this
        /// function.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IPluginFactory* getPluginFactory()
        {
            return ((delegate*unmanaged<LibVst.ITestPlugProvider2*, LibVst.IPluginFactory*>)Vtbl[8])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the plugin factory.
        /// </summary>
        /// <remarks>
        /// The reference count of the returned factory object is not increased when calling this
        /// function.
        /// </remarks>
        [UnmanagedCallersOnly]
        private static partial LibVst.IPluginFactory* getPluginFactory_ccw(ITestPlugProvider2* self);
        
        /// <summary>
        /// DECLARE_CLASS_IID (ITestPlugProvider2, 0xC7C75364, 0x7B8343AC, 0xA4495B0A, 0x3E5A46C7)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc7, 0xc7, 0x53, 0x64, 0x7b, 0x83, 0x43, 0xac, 0xa4, 0x49, 0x5b, 0x0a, 0x3e, 0x5a, 0x46, 0xc7 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x64, 0x53, 0xc7, 0xc7, 0xac, 0x43, 0x83, 0x7b, 0x0a, 0x5b, 0x49, 0xa4, 0xc7, 0x46, 0x5a, 0x3e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Host callback for unit support: Vst::IUnitHandler
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.0.0]
    /// - [optional]Host callback interface, used with IUnitInfo.
    /// Retrieve via queryInterface from IComponentHandler.
    /// </remarks>
    /// <seealso cref="IUnitInfovst3Units,"/>
    public unsafe partial struct IUnitHandler : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler*, uint>)Vtbl[1])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler*, uint>)Vtbl[2])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Notify host when a module is selected in plug-in GUI.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyUnitSelection(LibVst.UnitID unitId)
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler*, LibVst.UnitID, ComResult>)Vtbl[3])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this), unitId);
        }
        
        /// <summary>
        /// Tell host that the plug-in controller changed a program list (rename, load, PitchName changes).
        /// </summary>
        /// <param name="programIndex">: when kAllProgramInvalid, all program information is invalid, otherwise only the program of given index.</param>
        /// <param name="listId">is the specified program list ID to inform.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyProgramListChange(LibVst.ProgramListID listId, int programIndex)
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler*, LibVst.ProgramListID, int, ComResult>)Vtbl[4])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this), listId, programIndex);
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitHandler, 0x4B5147F8, 0x4654486B, 0x8DAB30BA, 0x163A3C56)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x4b, 0x51, 0x47, 0xf8, 0x46, 0x54, 0x48, 0x6b, 0x8d, 0xab, 0x30, 0xba, 0x16, 0x3a, 0x3c, 0x56 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xf8, 0x47, 0x51, 0x4b, 0x6b, 0x48, 0x54, 0x46, 0xba, 0x30, 0xab, 0x8d, 0x56, 0x3c, 0x3a, 0x16 })
                    )));
            }
        }
    }
    
    public partial record struct ProgramListID(int Value);
    
    /// <summary>
    /// Host callback for extended unit support: Vst::IUnitHandler2
    /// </summary>
    /// <remarks>
    ///  vstIHost vst365- [host imp]
    /// - [extends IUnitHandler]
    /// - [released: 3.6.5]
    /// - [optional]Host callback interface, used with IUnitInfo.
    /// Retrieve via queryInterface from IComponentHandler.The plug-in has the possibility to inform the host with notifyUnitByBusChange that something has
    /// changed in the bus - unit assignment, the host then has to recall IUnitInfo::getUnitByBus in order
    /// to get the new relations between busses and unit.
    /// </remarks>
    /// <seealso cref="IUnitHandlervst3Units,"/>
    public unsafe partial struct IUnitHandler2 : INativeGuid
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler2*, Guid*, void**, ComResult>)Vtbl[0])((LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this), _iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler2*, uint>)Vtbl[1])((LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler2*, uint>)Vtbl[2])((LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// Tell host that assignment Unit-Bus defined by IUnitInfo::getUnitByBus has changed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyUnitByBusChange()
        {
            return ((delegate*unmanaged<LibVst.IUnitHandler2*, ComResult>)Vtbl[3])((LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this));
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitHandler2, 0xF89F8CDF, 0x699E4BA5, 0x96AAC9A4, 0x81452B01)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf8, 0x9f, 0x8c, 0xdf, 0x69, 0x9e, 0x4b, 0xa5, 0x96, 0xaa, 0xc9, 0xa4, 0x81, 0x45, 0x2b, 0x01 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xdf, 0x8c, 0x9f, 0xf8, 0xa5, 0x4b, 0x9e, 0x69, 0xa4, 0xc9, 0xaa, 0x96, 0x01, 0x2b, 0x45, 0x81 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Edit controller extension to describe the plug-in structure: Vst::IUnitInfo
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.0.0]
    /// - [optional]IUnitInfo describes the internal structure of the plug-in.
    /// - The root unit is the component itself, so getUnitCount must return 1 at least.
    /// - The root unit id has to be 0 (kRootUnitId).
    /// - Each unit can reference one program list - this reference must not change.
    /// - Each unit, using a program list, references one program of the list.
    /// </remarks>
    /// <seealso cref="IUnitHandlervst3Units,"/>
    public unsafe partial struct IUnitInfo : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 12;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IUnitInfo*, int>)&getUnitCount_ccw;
            vtbl[4] = (delegate*unmanaged<IUnitInfo*, int, LibVst.UnitInfo*, ComResult>)&getUnitInfo_ccw;
            vtbl[5] = (delegate*unmanaged<IUnitInfo*, int>)&getProgramListCount_ccw;
            vtbl[6] = (delegate*unmanaged<IUnitInfo*, int, LibVst.ProgramListInfo*, ComResult>)&getProgramListInfo_ccw;
            vtbl[7] = (delegate*unmanaged<IUnitInfo*, LibVst.ProgramListID, int, LibVst.String128*, ComResult>)&getProgramName_ccw;
            vtbl[8] = (delegate*unmanaged<IUnitInfo*, LibVst.ProgramListID, int, LibVst.CString, LibVst.String128*, ComResult>)&getProgramInfo_ccw;
            vtbl[9] = (delegate*unmanaged<IUnitInfo*, LibVst.ProgramListID, int, ComResult>)&hasProgramPitchNames_ccw;
            vtbl[10] = (delegate*unmanaged<IUnitInfo*, LibVst.ProgramListID, int, short, LibVst.String128*, ComResult>)&getProgramPitchName_ccw;
            vtbl[11] = (delegate*unmanaged<IUnitInfo*, LibVst.UnitID>)&getSelectedUnit_ccw;
            vtbl[12] = (delegate*unmanaged<IUnitInfo*, LibVst.UnitID, ComResult>)&selectUnit_ccw;
            vtbl[13] = (delegate*unmanaged<IUnitInfo*, LibVst.MediaType, LibVst.BusDirection, int, int, LibVst.UnitID*, ComResult>)&getUnitByBus_ccw;
            vtbl[14] = (delegate*unmanaged<IUnitInfo*, int, int, LibVst.IBStream*, ComResult>)&setUnitProgramData_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the flat count of units.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial int getUnitCount_ccw(IUnitInfo* self);
        
        /// <summary>
        /// Gets UnitInfo for a given index in the flat list of unit.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getUnitInfo_ccw(IUnitInfo* self, int unitIndex, LibVst.UnitInfo* info);
        
        /// <summary>
        /// Component intern program structure.
        /// </summary>
        /// <remarks>
        /// Gets the count of Program List.
        /// </remarks>
        [UnmanagedCallersOnly]
        private static partial int getProgramListCount_ccw(IUnitInfo* self);
        
        /// <summary>
        /// Gets for a given index the Program List Info.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getProgramListInfo_ccw(IUnitInfo* self, int listIndex, LibVst.ProgramListInfo* info);
        
        /// <summary>
        /// Gets for a given program list ID and program index its program name.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getProgramName_ccw(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, LibVst.String128* name);
        
        /// <summary>
        /// Gets for a given program list ID, program index and attributeId the associated attribute value.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getProgramInfo_ccw(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, LibVst.CString attributeId, LibVst.String128* attributeValue);
        
        /// <summary>
        /// Returns kResultTrue if the given program index of a given program list ID supports PitchNames.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult hasProgramPitchNames_ccw(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex);
        
        /// <summary>
        /// Gets the PitchName for a given program list ID, program index and pitch.
        /// If PitchNames are changed the plug-in should inform the host with IUnitHandler::notifyProgramListChange.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getProgramPitchName_ccw(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, short midiPitch, LibVst.String128* name);
        
        /// <summary>
        /// units selection --------------------
        /// Gets the current selected unit.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial LibVst.UnitID getSelectedUnit_ccw(IUnitInfo* self);
        
        /// <summary>
        /// Sets a new selected unit.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult selectUnit_ccw(IUnitInfo* self, LibVst.UnitID unitId);
        
        /// <summary>
        /// Gets the according unit if there is an unambiguous relation between a channel or a bus and a unit.
        /// This method mainly is intended to find out which unit is related to a given MIDI input channel.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getUnitByBus_ccw(IUnitInfo* self, LibVst.MediaType type, LibVst.BusDirection dir, int busIndex, int channel, LibVst.UnitID* unitId);
        
        /// <summary>
        /// Receives a preset data stream.
        /// - If the component supports program list data (IProgramListData), the destination of the data
        /// stream is the program specified by list-Id and program index (first and second parameter)
        /// - If the component supports unit data (IUnitData), the destination is the unit specified by the first
        /// parameter - in this case parameter programIndex is 
        /// &lt;
        /// 0).
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setUnitProgramData_ccw(IUnitInfo* self, int listOrUnitId, int programIndex, LibVst.IBStream* data);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitInfo, 0x3D4BD6B5, 0x913A4FD2, 0xA886E768, 0xA5EB92C1)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x3d, 0x4b, 0xd6, 0xb5, 0x91, 0x3a, 0x4f, 0xd2, 0xa8, 0x86, 0xe7, 0x68, 0xa5, 0xeb, 0x92, 0xc1 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb5, 0xd6, 0x4b, 0x3d, 0xd2, 0x4f, 0x3a, 0x91, 0x68, 0xe7, 0x86, 0xa8, 0xc1, 0x92, 0xeb, 0xa5 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic Unit Description.
    /// </summary>
    /// <seealso cref="IUnitInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct UnitInfo
    {
        /// <summary>
        /// unit identifier
        /// </summary>
        public LibVst.UnitID id;
        
        /// <summary>
        /// identifier of parent unit (kNoParentUnitId: does not apply, this unit is the root)
        /// </summary>
        public LibVst.UnitID parentUnitId;
        
        /// <summary>
        /// name, optional for the root component, required otherwise
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// id of program list used in unit (kNoProgramListId = no programs used in this unit)
        /// </summary>
        public LibVst.ProgramListID programListId;
    }
    
    /// <summary>
    /// Basic Program List Description.
    /// </summary>
    /// <seealso cref="IUnitInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public unsafe partial struct ProgramListInfo
    {
        /// <summary>
        /// program list identifier
        /// </summary>
        public LibVst.ProgramListID id;
        
        /// <summary>
        /// name of program list
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// number of programs in this list
        /// </summary>
        public int programCount;
    }
    
    public unsafe partial struct CString
    {
        public byte* Value;
    }
    
    /// <summary>
    /// Component extension to access program list data: Vst::IProgramListData
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [optional]A component can support program list data via this interface or/and
    /// unit preset data (IUnitData).
    /// </remarks>
    /// <seealso cref="vst3MultitimbralProgramsIUnitData, "/>
    public unsafe partial struct IProgramListData : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IProgramListData*, LibVst.ProgramListID, ComResult>)&programDataSupported_ccw;
            vtbl[4] = (delegate*unmanaged<IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, ComResult>)&getProgramData_ccw;
            vtbl[5] = (delegate*unmanaged<IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, ComResult>)&setProgramData_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns kResultTrue if the given Program List ID supports Program Data.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult programDataSupported_ccw(IProgramListData* self, LibVst.ProgramListID listId);
        
        /// <summary>
        /// Gets for a given program list ID and program index the program Data.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getProgramData_ccw(IProgramListData* self, LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data);
        
        /// <summary>
        /// Sets for a given program list ID and program index a program Data.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setProgramData_ccw(IProgramListData* self, LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProgramListData, 0x8683B01F, 0x7B354F70, 0xA2651DEC, 0x353AF4FF)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x86, 0x83, 0xb0, 0x1f, 0x7b, 0x35, 0x4f, 0x70, 0xa2, 0x65, 0x1d, 0xec, 0x35, 0x3a, 0xf4, 0xff })
                        : new ReadOnlySpan<byte>(new byte[] { 0x1f, 0xb0, 0x83, 0x86, 0x70, 0x4f, 0x35, 0x7b, 0xec, 0x1d, 0x65, 0xa2, 0xff, 0xf4, 0x3a, 0x35 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Component extension to access unit data: Vst::IUnitData
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [optional]A component can support unit preset data via this interface or
    /// program list data (IProgramListData).
    /// </remarks>
    /// <seealso cref="vst3ProgramLists"/>
    public unsafe partial struct IUnitData : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IUnitData*, LibVst.UnitID, ComResult>)&unitDataSupported_ccw;
            vtbl[4] = (delegate*unmanaged<IUnitData*, LibVst.UnitID, LibVst.IBStream*, ComResult>)&getUnitData_ccw;
            vtbl[5] = (delegate*unmanaged<IUnitData*, LibVst.UnitID, LibVst.IBStream*, ComResult>)&setUnitData_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns kResultTrue if the specified unit supports export and import of preset data.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult unitDataSupported_ccw(IUnitData* self, LibVst.UnitID unitID);
        
        /// <summary>
        /// Gets the preset data for the specified unit.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult getUnitData_ccw(IUnitData* self, LibVst.UnitID unitId, LibVst.IBStream* data);
        
        /// <summary>
        /// Sets the preset data for the specified unit.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setUnitData_ccw(IUnitData* self, LibVst.UnitID unitId, LibVst.IBStream* data);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitData, 0x6C389611, 0xD391455D, 0xB870B833, 0x94A0EFDD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6c, 0x38, 0x96, 0x11, 0xd3, 0x91, 0x45, 0x5d, 0xb8, 0x70, 0xb8, 0x33, 0x94, 0xa0, 0xef, 0xdd })
                        : new ReadOnlySpan<byte>(new byte[] { 0x11, 0x96, 0x38, 0x6c, 0x5d, 0x45, 0x91, 0xd3, 0x33, 0xb8, 0x70, 0xb8, 0xdd, 0xef, 0xa0, 0x94 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Bus media types
    /// </summary>
    public enum MediaTypes
    {
        /// <summary>
        /// audio
        /// </summary>
        kAudio = 0,
        
        /// <summary>
        /// events
        /// </summary>
        kEvent,
        
        kNumMediaTypes,
    }
    
    /// <summary>
    /// Bus directions
    /// </summary>
    public enum BusDirections
    {
        /// <summary>
        /// input bus
        /// </summary>
        kInput = 0,
        
        /// <summary>
        /// output bus
        /// </summary>
        kOutput,
    }
    
    /// <summary>
    /// Bus types
    /// </summary>
    public enum BusTypes
    {
        /// <summary>
        /// main bus
        /// </summary>
        kMain = 0,
        
        /// <summary>
        /// auxiliary bus (sidechain)
        /// </summary>
        kAux,
    }
    
    /// <summary>
    /// I/O modes
    /// </summary>
    public enum IoModes
    {
        /// <summary>
        /// 1:1 Input / Output. Only used for Instruments. See @ref vst3IoMode
        /// </summary>
        kSimple = 0,
        
        /// <summary>
        /// n:m Input / Output. Only used for Instruments.
        /// </summary>
        kAdvanced,
        
        /// <summary>
        /// plug-in used in an offline processing context
        /// </summary>
        kOfflineProcessing,
    }
    
    /// <summary>
    /// Component Flags used as classFlags in PClassInfo2
    /// </summary>
    public enum ComponentFlags
    {
        /// <summary>
        /// Component can be run on remote computer
        /// </summary>
        kDistributable = 1 << 0,
        
        /// <summary>
        /// Component supports simple IO mode (or works in simple mode anyway) see @ref vst3IoMode
        /// </summary>
        kSimpleModeSupported = 1 << 1,
    }
    
    /// <summary>
    /// Symbolic sample size.
    /// </summary>
    /// <seealso cref="ProcessSetup, ProcessData"/>
    public enum SymbolicSampleSizes
    {
        /// <summary>
        /// 32-bit precision
        /// </summary>
        kSample32,
        
        /// <summary>
        /// 64-bit precision
        /// </summary>
        kSample64,
    }
    
    /// <summary>
    /// Processing mode informs the plug-in about the context and at which frequency the process call is called.
    /// VST3 defines 3 modes:
    /// - kRealtime: each process call is called at a realtime frequency (defined by [numSamples of ProcessData] / samplerate).
    /// The plug-in should always try to process as fast as possible in order to let enough time slice to other plug-ins.
    /// - kPrefetch: each process call could be called at a variable frequency (jitter, slower / faster than realtime),
    /// the plug-in should process at the same quality level than realtime, plug-in must not slow down to realtime
    /// (e.g. disk streaming)!
    /// The host should avoid to process in kPrefetch mode such sampler based plug-in.
    /// - kOffline:  each process call could be faster than realtime or slower, higher quality than realtime could be used.
    /// plug-ins using disk streaming should be sure that they have enough time in the process call for streaming,
    /// if needed by slowing down to realtime or slower.
    /// .
    /// Note about Process Modes switching:
    /// - Switching between kRealtime and kPrefetch process modes are done in realtime thread without need of calling
    /// IAudioProcessor::setupProcessing, the plug-in should check in process call the member processMode of ProcessData
    /// in order to know in which mode it is processed.
    /// - Switching between kRealtime (or kPrefetch) and kOffline requires that the host calls IAudioProcessor::setupProcessing
    /// in order to inform the plug-in about this mode change.
    /// .
    /// </summary>
    /// <seealso cref="ProcessSetup, ProcessData"/>
    public enum ProcessModes
    {
        /// <summary>
        /// realtime processing
        /// </summary>
        kRealtime,
        
        /// <summary>
        /// prefetch processing
        /// </summary>
        kPrefetch,
        
        /// <summary>
        /// offline processing
        /// </summary>
        kOffline,
    }
    
    /// <summary>
    /// Flags used for IComponentHandler::restartComponent
    /// </summary>
    public enum RestartFlags
    {
        /// <summary>
        /// The Component should be reloaded
        /// The host has to unload completely the plug-in (controller/processor) and reload it. 
        /// [SDK 3.0.0]
        /// </summary>
        kReloadComponent = 1 << 0,
        
        /// <summary>
        /// Input / Output Bus configuration has changed
        /// The plug-in informs the host that either the bus configuration or the bus count has changed.
        /// The host has to deactivate the plug-in, asks the plug-in for its wanted new bus configurations,
        /// adapts its processing graph and reactivate the plug-in.
        /// [SDK 3.0.0]
        /// </summary>
        kIoChanged = 1 << 1,
        
        /// <summary>
        /// Multiple parameter values have changed  (as result of a program change for example)
        /// The host invalidates all caches of parameter values and asks the edit controller for the current values.
        /// [SDK 3.0.0]
        /// </summary>
        kParamValuesChanged = 1 << 2,
        
        /// <summary>
        /// Latency has changed
        /// The plug informs the host that its latency has changed, getLatencySamples should return the new latency after setActive (true) was called
        /// The host has to deactivate and reactivate the plug-in, then afterwards the host could ask for the current latency (getLatencySamples)
        /// see IAudioProcessor::getLatencySamples
        /// [SDK 3.0.0]
        /// </summary>
        kLatencyChanged = 1 << 3,
        
        /// <summary>
        /// Parameter titles, default values or flags (ParameterFlags) have changed
        /// The host invalidates all caches of parameter infos and asks the edit controller for the current infos.
        /// [SDK 3.0.0]
        /// </summary>
        kParamTitlesChanged = 1 << 4,
        
        /// <summary>
        /// MIDI Controllers and/or Program Changes Assignments have changed
        /// The plug-in informs the host that its MIDI-CC mapping has changed (for example after a MIDI learn or new loaded preset) 
        /// or if the stepCount or UnitID of a ProgramChange parameter has changed.
        /// The host has to rebuild the MIDI-CC =&gt; parameter mapping (getMidiControllerAssignment)
        /// and reread program changes parameters (stepCount and associated unitID)
        /// [SDK 3.0.1]
        /// </summary>
        kMidiCCAssignmentChanged = 1 << 5,
        
        /// <summary>
        /// Note Expression has changed (info, count, PhysicalUIMapping, ...)
        /// Either the note expression type info, the count of note expressions or the physical UI mapping has changed.
        /// The host invalidates all caches of note expression infos and asks the edit controller for the current ones.
        /// See INoteExpressionController, NoteExpressionTypeInfo and INoteExpressionPhysicalUIMapping
        /// [SDK 3.5.0]
        /// </summary>
        kNoteExpressionChanged = 1 << 6,
        
        /// <summary>
        /// Input / Output bus titles have changed
        /// The host invalidates all caches of bus titles and asks the edit controller for the current titles.
        /// [SDK 3.5.0]
        /// </summary>
        kIoTitlesChanged = 1 << 7,
        
        /// <summary>
        /// Prefetch support has changed
        /// The plug-in informs the host that its PrefetchSupport has changed
        /// The host has to deactivate the plug-in, calls IPrefetchableSupport::getPrefetchableSupport and reactivate the plug-in
        /// see IPrefetchableSupport
        /// [SDK 3.6.1]
        /// </summary>
        kPrefetchableSupportChanged = 1 << 8,
        
        /// <summary>
        /// RoutingInfo has changed
        /// The plug-in informs the host that its internal routing (relation of an event-input-channel to an audio-output-bus) has changed
        /// The host ask the plug-in for the new routing with IComponent::getRoutingInfo, @ref vst3Routing see IComponent
        /// [SDK 3.6.6]
        /// </summary>
        kRoutingInfoChanged = 1 << 9,
        
        /// <summary>
        /// Key switches has changed (info, count)
        /// Either the Key switches info, the count of Key switches has changed.
        /// The host invalidates all caches of Key switches infos and asks the edit controller (IKeyswitchController) for the current ones.
        /// See IKeyswitchController
        /// [SDK 3.7.3]
        /// </summary>
        kKeyswitchChanged = 1 << 10,
    }
    
    /// <summary>
    /// Knob Mode
    /// </summary>
    public enum KnobModes
    {
        /// <summary>
        /// Circular with jump to clicked position
        /// </summary>
        kCircularMode = 0,
        
        /// <summary>
        /// Circular without jump to clicked position
        /// </summary>
        kRelativCircularMode,
        
        /// <summary>
        /// Linear: depending on vertical movement
        /// </summary>
        kLinearMode,
    }
    
    /// <summary>
    /// NoteExpressionTypeIDs describes the type of the note expression.
    /// VST predefines some types like volume, pan, tuning by defining their ranges and curves.
    /// Used by NoteExpressionEvent::typeId and NoteExpressionTypeID::typeId
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    public enum NoteExpressionTypeIDs : uint
    {
        /// <summary>
        /// Volume, plain range [0 = -oo , 0.25 = 0dB, 0.5 = +6dB, 1 = +12dB]: plain = 20 * log (4 * norm)
        /// </summary>
        kVolumeTypeID = 0,
        
        /// <summary>
        /// Panning (L-R), plain range [0 = left, 0.5 = center, 1 = right]
        /// </summary>
        kPanTypeID,
        
        /// <summary>
        /// Tuning, plain range [0 = -120.0 (ten octaves down), 0.5 none, 1 = +120.0 (ten octaves up)]
        /// plain = 240 * (norm - 0.5) and norm = plain / 240 + 0.5
        /// oneOctave is 12.0 / 240.0; oneHalfTune = 1.0 / 240.0;
        /// </summary>
        kTuningTypeID,
        
        /// <summary>
        /// Vibrato
        /// </summary>
        kVibratoTypeID,
        
        /// <summary>
        /// Expression
        /// </summary>
        kExpressionTypeID,
        
        /// <summary>
        /// Brightness
        /// </summary>
        kBrightnessTypeID,
        
        /// <summary>
        /// See NoteExpressionTextEvent
        /// </summary>
        kTextTypeID,
        
        /// <summary>
        /// TODO:
        /// </summary>
        kPhonemeTypeID,
        
        /// <summary>
        /// start of custom note expression type ids
        /// </summary>
        kCustomStart = 100000,
        
        /// <summary>
        /// end of custom note expression type ids
        /// </summary>
        kCustomEnd = 200000,
        
        /// <summary>
        /// indicates an invalid note expression type
        /// </summary>
        kInvalidTypeID = 0xFFFFFFFF,
    }
    
    /// <summary>
    /// KeyswitchTypeIDs describes the type of a key switch
    /// </summary>
    /// <seealso cref="KeyswitchInfo"/>
    public enum KeyswitchTypeIDs : uint
    {
        /// <summary>
        /// press before noteOn is played
        /// </summary>
        kNoteOnKeyswitchTypeID = 0,
        
        /// <summary>
        /// press while noteOn is played
        /// </summary>
        kOnTheFlyKeyswitchTypeID,
        
        /// <summary>
        /// press before entering release
        /// </summary>
        kOnReleaseKeyswitchTypeID,
        
        /// <summary>
        /// key should be maintained pressed for playing
        /// </summary>
        kKeyRangeTypeID,
    }
    
    /// <summary>
    /// Reserved note identifier (noteId) range for a plug-in. Guaranteed not used by the host.
    /// </summary>
    public enum NoteIDUserRange
    {
        kNoteIDUserRangeLowerBound = -10000,
        
        kNoteIDUserRangeUpperBound = -1000,
    }
    
    /// <summary>
    /// Controller Numbers (MIDI)
    /// </summary>
    public enum ControllerNumbers
    {
        /// <summary>
        /// Bank Select MSB
        /// </summary>
        kCtrlBankSelectMSB = 0,
        
        /// <summary>
        /// Modulation Wheel
        /// </summary>
        kCtrlModWheel = 1,
        
        /// <summary>
        /// Breath controller
        /// </summary>
        kCtrlBreath = 2,
        
        /// <summary>
        /// Foot Controller
        /// </summary>
        kCtrlFoot = 4,
        
        /// <summary>
        /// Portamento Time
        /// </summary>
        kCtrlPortaTime = 5,
        
        /// <summary>
        /// Data Entry MSB
        /// </summary>
        kCtrlDataEntryMSB = 6,
        
        /// <summary>
        /// Channel Volume (formerly Main Volume)
        /// </summary>
        kCtrlVolume = 7,
        
        /// <summary>
        /// Balance
        /// </summary>
        kCtrlBalance = 8,
        
        /// <summary>
        /// Pan
        /// </summary>
        kCtrlPan = 10,
        
        /// <summary>
        /// Expression
        /// </summary>
        kCtrlExpression = 11,
        
        /// <summary>
        /// Effect Control 1
        /// </summary>
        kCtrlEffect1 = 12,
        
        /// <summary>
        /// Effect Control 2
        /// </summary>
        kCtrlEffect2 = 13,
        
        /// <summary>
        /// General Purpose Controller #1
        /// </summary>
        kCtrlGPC1 = 16,
        
        /// <summary>
        /// General Purpose Controller #2
        /// </summary>
        kCtrlGPC2 = 17,
        
        /// <summary>
        /// General Purpose Controller #3
        /// </summary>
        kCtrlGPC3 = 18,
        
        /// <summary>
        /// General Purpose Controller #4
        /// </summary>
        kCtrlGPC4 = 19,
        
        /// <summary>
        /// Bank Select LSB
        /// </summary>
        kCtrlBankSelectLSB = 32,
        
        /// <summary>
        /// Data Entry LSB
        /// </summary>
        kCtrlDataEntryLSB = 38,
        
        /// <summary>
        /// Damper Pedal On/Off (Sustain)
        /// </summary>
        kCtrlSustainOnOff = 64,
        
        /// <summary>
        /// Portamento On/Off
        /// </summary>
        kCtrlPortaOnOff = 65,
        
        /// <summary>
        /// Sustenuto On/Off
        /// </summary>
        kCtrlSustenutoOnOff = 66,
        
        /// <summary>
        /// Soft Pedal On/Off
        /// </summary>
        kCtrlSoftPedalOnOff = 67,
        
        /// <summary>
        /// Legato Footswitch On/Off
        /// </summary>
        kCtrlLegatoFootSwOnOff = 68,
        
        /// <summary>
        /// Hold 2 On/Off
        /// </summary>
        kCtrlHold2OnOff = 69,
        
        /// <summary>
        /// Sound Variation
        /// </summary>
        kCtrlSoundVariation = 70,
        
        /// <summary>
        /// Filter Cutoff (Timbre/Harmonic Intensity)
        /// </summary>
        kCtrlFilterCutoff = 71,
        
        /// <summary>
        /// Release Time
        /// </summary>
        kCtrlReleaseTime = 72,
        
        /// <summary>
        /// Attack Time
        /// </summary>
        kCtrlAttackTime = 73,
        
        /// <summary>
        /// Filter Resonance (Brightness)
        /// </summary>
        kCtrlFilterResonance = 74,
        
        /// <summary>
        /// Decay Time
        /// </summary>
        kCtrlDecayTime = 75,
        
        /// <summary>
        /// Vibrato Rate
        /// </summary>
        kCtrlVibratoRate = 76,
        
        /// <summary>
        /// Vibrato Depth
        /// </summary>
        kCtrlVibratoDepth = 77,
        
        /// <summary>
        /// Vibrato Delay
        /// </summary>
        kCtrlVibratoDelay = 78,
        
        /// <summary>
        /// undefined
        /// </summary>
        kCtrlSoundCtrler10 = 79,
        
        /// <summary>
        /// General Purpose Controller #5
        /// </summary>
        kCtrlGPC5 = 80,
        
        /// <summary>
        /// General Purpose Controller #6
        /// </summary>
        kCtrlGPC6 = 81,
        
        /// <summary>
        /// General Purpose Controller #7
        /// </summary>
        kCtrlGPC7 = 82,
        
        /// <summary>
        /// General Purpose Controller #8
        /// </summary>
        kCtrlGPC8 = 83,
        
        /// <summary>
        /// Portamento Control
        /// </summary>
        kCtrlPortaControl = 84,
        
        /// <summary>
        /// Effect 1 Depth (Reverb Send Level)
        /// </summary>
        kCtrlEff1Depth = 91,
        
        /// <summary>
        /// Effect 2 Depth (Tremolo Level)
        /// </summary>
        kCtrlEff2Depth = 92,
        
        /// <summary>
        /// Effect 3 Depth (Chorus Send Level)
        /// </summary>
        kCtrlEff3Depth = 93,
        
        /// <summary>
        /// Effect 4 Depth (Delay/Variation/Detune Level)
        /// </summary>
        kCtrlEff4Depth = 94,
        
        /// <summary>
        /// Effect 5 Depth (Phaser Level)
        /// </summary>
        kCtrlEff5Depth = 95,
        
        /// <summary>
        /// Data Increment (+1)
        /// </summary>
        kCtrlDataIncrement = 96,
        
        /// <summary>
        /// Data Decrement (-1)
        /// </summary>
        kCtrlDataDecrement = 97,
        
        /// <summary>
        /// NRPN Select LSB
        /// </summary>
        kCtrlNRPNSelectLSB = 98,
        
        /// <summary>
        /// NRPN Select MSB
        /// </summary>
        kCtrlNRPNSelectMSB = 99,
        
        /// <summary>
        /// RPN Select LSB
        /// </summary>
        kCtrlRPNSelectLSB = 100,
        
        /// <summary>
        /// RPN Select MSB
        /// </summary>
        kCtrlRPNSelectMSB = 101,
        
        /// <summary>
        /// All Sounds Off
        /// </summary>
        kCtrlAllSoundsOff = 120,
        
        /// <summary>
        /// Reset All Controllers
        /// </summary>
        kCtrlResetAllCtrlers = 121,
        
        /// <summary>
        /// Local Control On/Off
        /// </summary>
        kCtrlLocalCtrlOnOff = 122,
        
        /// <summary>
        /// All Notes Off
        /// </summary>
        kCtrlAllNotesOff = 123,
        
        /// <summary>
        /// Omni Mode Off + All Notes Off
        /// </summary>
        kCtrlOmniModeOff = 124,
        
        /// <summary>
        /// Omni Mode On  + All Notes Off
        /// </summary>
        kCtrlOmniModeOn = 125,
        
        /// <summary>
        /// Poly Mode On/Off + All Sounds Off
        /// </summary>
        kCtrlPolyModeOnOff = 126,
        
        /// <summary>
        /// Poly Mode On
        /// </summary>
        kCtrlPolyModeOn = 127,
        
        /// <summary>
        /// After Touch (associated to Channel Pressure)
        /// </summary>
        kAfterTouch = 128,
        
        /// <summary>
        /// Pitch Bend Change
        /// </summary>
        kPitchBend = 129,
        
        /// <summary>
        /// Count of Controller Number
        /// </summary>
        kCountCtrlNumber,
        
        /// <summary>
        /// Program Change (use LegacyMIDICCOutEvent.value only)
        /// </summary>
        kCtrlProgramChange = 130,
        
        /// <summary>
        /// Polyphonic Key Pressure (use LegacyMIDICCOutEvent.value for pitch and
        /// </summary>
        kCtrlPolyPressure = 131,
        
        /// <summary>
        /// Quarter Frame ((use LegacyMIDICCOutEvent.value only)
        /// </summary>
        kCtrlQuarterFrame = 132,
    }
    
    /// <summary>
    /// PhysicalUITypeIDs describes the type of Physical UI (PUI) which could be associated to a note
    /// expression.
    /// </summary>
    /// <seealso cref="PhysicalUIMap"/>
    public enum PhysicalUITypeIDs
    {
        /// <summary>
        /// absolute X position when touching keys of PUIs. Range [0=left, 0.5=middle, 1=right]
        /// </summary>
        kPUIXMovement = 0,
        
        /// <summary>
        /// absolute Y position when touching keys of PUIs. Range [0=bottom/near, 0.5=center, 1=top/far]
        /// </summary>
        kPUIYMovement,
        
        /// <summary>
        /// pressing a key down on keys of PUIs. Range [0=No Pressure, 1=Full Pressure]
        /// </summary>
        kPUIPressure,
        
        /// <summary>
        /// count of current defined PUIs
        /// </summary>
        kPUITypeCount,
        
        /// <summary>
        /// indicates an invalid or not initialized PUI type
        /// </summary>
        kInvalidPUITypeID = -1,
    }
    
    /// <summary>
    /// Prefetchable Support Enum
    /// </summary>
    public enum ePrefetchableSupport
    {
        /// <summary>
        /// every instance of the plug does not support prefetch processing
        /// </summary>
        kIsNeverPrefetchable = 0,
        
        /// <summary>
        /// in the current state the plug support prefetch processing
        /// </summary>
        kIsYetPrefetchable,
        
        /// <summary>
        /// in the current state the plug does not support prefetch processing
        /// </summary>
        kIsNotYetPrefetchable,
        
        kNumPrefetchableSupport,
    }
    
    /// <summary>
    /// Channel context interface: Vst::IInfoListener
    /// </summary>
    /// <remarks>
    ///  vstIHost vst365- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.5]
    /// - [optional]Allows the host to inform the plug-in about the context in which the plug-in is instantiated,
    /// mainly channel based info (color, name, index,...). Index can be defined inside a namespace 
    /// (for example, index start from 1 to N for Type Input/Output Channel (Index namespace) and index 
    /// start from 1 to M for Type Audio Channel).@n As soon as the plug-in provides this IInfoListener interface, the host will call setChannelContextInfos 
    /// for each change occurring to this channel (new name, new color, new indexation,...) IChannelContextExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyPlugin::setChannelContextInfos (IAttributeList* list)
    /// {
    /// 	if (list)
    /// 	{
    /// 		// optional we can ask for the Channel Name Length
    /// 		int64 length;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelNameLengthKey, length) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the Channel Name where we, as plug-in, are instantiated
    /// 		String128 name;
    /// 		if (list-&gt;getString (ChannelContext::kChannelNameKey, name, sizeof (name)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 
    /// 		// get the Channel UID
    /// 		if (list-&gt;getString (ChannelContext::kChannelUIDKey, name, sizeof (name)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get Channel Index
    /// 		int64 index;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexKey, index) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the Channel Color
    /// 		int64 color;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelColorKey, color) == kResultTrue)
    /// 		{
    /// 			uint32 channelColor = (uint32)color;
    /// 			String str;
    /// 			str.printf ("%x%x%x%x", ChannelContext::GetAlpha (channelColor),
    /// 			ChannelContext::GetRed (channelColor),
    /// 			ChannelContext::GetGreen (channelColor),
    /// 			ChannelContext::GetBlue (channelColor));
    /// 			String128 string128;
    /// 			Steinberg::UString (string128, 128).fromAscii (str);
    /// 			...
    /// 		}
    /// 
    /// 		// get Channel Index Namespace Order of the current used index namespace
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexNamespaceOrderKey, index) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 	
    /// 		// get the channel Index Namespace Length
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexNamespaceLengthKey, length) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the channel Index Namespace
    /// 		String128 namespaceName;
    /// 		if (list-&gt;getString (ChannelContext::kChannelIndexNamespaceKey, namespaceName, sizeof (namespaceName)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 
    /// 		// get plug-in Channel Location
    /// 		int64 location;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelPluginLocationKey, location) == kResultTrue)
    /// 		{
    /// 			String128 string128;
    /// 			switch (location)
    /// 			{
    /// 				case ChannelContext::kPreVolumeFader:
    /// 					Steinberg::UString (string128, 128).fromAscii ("PreVolFader");
    /// 				break;
    /// 				case ChannelContext::kPostVolumeFader:
    /// 					Steinberg::UString (string128, 128).fromAscii ("PostVolFader");
    /// 				break;
    /// 				case ChannelContext::kUsedAsPanner:
    /// 					Steinberg::UString (string128, 128).fromAscii ("UsedAsPanner");
    /// 				break;
    /// 				default: Steinberg::UString (string128, 128).fromAscii ("unknown!");
    /// 				break;
    /// 			}
    /// 		}
    /// 		
    /// 		// do not forget to call addRef () if you want to keep this list
    /// 	}
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IInfoListener : INativeGuid, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public static int VtblCount => 1;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged<IInfoListener*, LibVst.IAttributeList*, ComResult>)&setChannelContextInfos_ccw;
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Receive the channel context infos from host.
        /// </summary>
        [UnmanagedCallersOnly]
        private static partial ComResult setChannelContextInfos_ccw(IInfoListener* self, LibVst.IAttributeList* list);
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInfoListener, 0x0F194781, 0x8D984ADA, 0xBBA0C1EF, 0xC011D8D0)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x0f, 0x19, 0x47, 0x81, 0x8d, 0x98, 0x4a, 0xda, 0xbb, 0xa0, 0xc1, 0xef, 0xc0, 0x11, 0xd8, 0xd0 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x81, 0x47, 0x19, 0x0f, 0xda, 0x4a, 0x98, 0x8d, 0xef, 0xc1, 0xa0, 0xbb, 0xd0, 0xd8, 0x11, 0xc0 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Values used for kChannelPluginLocationKey
    /// </summary>
    public enum ChannelPluginLocation
    {
        kPreVolumeFader = 0,
        
        kPostVolumeFader,
        
        kUsedAsPanner,
    }
    
    public const string kPlatformStringWin = "WIN";
    
    public static ReadOnlySpan<byte> kPlatformStringWin_u8 => "WIN\0"u8;
    
    public const string kPlatformStringMac = "MAC";
    
    public static ReadOnlySpan<byte> kPlatformStringMac_u8 => "MAC\0"u8;
    
    public const string kPlatformStringIOS = "IOS";
    
    public static ReadOnlySpan<byte> kPlatformStringIOS_u8 => "IOS\0"u8;
    
    public const string kPlatformStringLinux = "Linux";
    
    public static ReadOnlySpan<byte> kPlatformStringLinux_u8 => "Linux\0"u8;
    
    /// <summary>
    /// HWND handle. (Microsoft Windows)
    /// </summary>
    public const string kPlatformTypeHWND = "HWND";
    
    /// <summary>
    /// HWND handle. (Microsoft Windows)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeHWND_u8 => "HWND\0"u8;
    
    /// <summary>
    /// HIViewRef. (Mac OS X)
    /// </summary>
    public const string kPlatformTypeHIView = "HIView";
    
    /// <summary>
    /// HIViewRef. (Mac OS X)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeHIView_u8 => "HIView\0"u8;
    
    /// <summary>
    /// NSView pointer. (Mac OS X)
    /// </summary>
    public const string kPlatformTypeNSView = "NSView";
    
    /// <summary>
    /// NSView pointer. (Mac OS X)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeNSView_u8 => "NSView\0"u8;
    
    /// <summary>
    /// UIView pointer. (iOS)
    /// </summary>
    public const string kPlatformTypeUIView = "UIView";
    
    /// <summary>
    /// UIView pointer. (iOS)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeUIView_u8 => "UIView\0"u8;
    
    /// <summary>
    /// X11 Window ID. (X11)
    /// </summary>
    public const string kPlatformTypeX11EmbedWindowID = "X11EmbedWindowID";
    
    /// <summary>
    /// X11 Window ID. (X11)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeX11EmbedWindowID_u8 => "X11EmbedWindowID\0"u8;
    
    public static partial class SpeakerArr
    {
        /// <summary>
        /// Speaker Arrangement String Representation.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public const string kStringEmpty = "";
        
        /// <summary>
        /// Speaker Arrangement String Representation.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kStringEmpty_u8 => "\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringMono = "Mono";
        
        public static ReadOnlySpan<byte> kStringMono_u8 => "Mono\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereo = "Stereo";
        
        public static ReadOnlySpan<byte> kStringStereo_u8 => "Stereo\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoR = "Stereo (Ls Rs)";
        
        public static ReadOnlySpan<byte> kStringStereoR_u8 => "Stereo (Ls Rs)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoC = "Stereo (Lc Rc)";
        
        public static ReadOnlySpan<byte> kStringStereoC_u8 => "Stereo (Lc Rc)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoSide = "Stereo (Sl Sr)";
        
        public static ReadOnlySpan<byte> kStringStereoSide_u8 => "Stereo (Sl Sr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCLfe = "Stereo (C LFE)";
        
        public static ReadOnlySpan<byte> kStringStereoCLfe_u8 => "Stereo (C LFE)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTF = "Stereo (Tfl Tfr)";
        
        public static ReadOnlySpan<byte> kStringStereoTF_u8 => "Stereo (Tfl Tfr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTS = "Stereo (Tsl Tsr)";
        
        public static ReadOnlySpan<byte> kStringStereoTS_u8 => "Stereo (Tsl Tsr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTR = "Stereo (Trl Trr)";
        
        public static ReadOnlySpan<byte> kStringStereoTR_u8 => "Stereo (Trl Trr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoBF = "Stereo (Bfl Bfr)";
        
        public static ReadOnlySpan<byte> kStringStereoBF_u8 => "Stereo (Bfl Bfr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringCineFront = "Cine Front";
        
        public static ReadOnlySpan<byte> kStringCineFront_u8 => "Cine Front\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30Cine = "LRC";
        
        public static ReadOnlySpan<byte> kString30Cine_u8 => "LRC\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30Music = "LRS";
        
        public static ReadOnlySpan<byte> kString30Music_u8 => "LRS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31Cine = "LRC+LFE";
        
        public static ReadOnlySpan<byte> kString31Cine_u8 => "LRC+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31Music = "LRS+LFE";
        
        public static ReadOnlySpan<byte> kString31Music_u8 => "LRS+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40Cine = "LRCS";
        
        public static ReadOnlySpan<byte> kString40Cine_u8 => "LRCS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40Music = "Quadro";
        
        public static ReadOnlySpan<byte> kString40Music_u8 => "Quadro\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41Cine = "LRCS+LFE";
        
        public static ReadOnlySpan<byte> kString41Cine_u8 => "LRCS+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41Music = "Quadro+LFE";
        
        public static ReadOnlySpan<byte> kString41Music_u8 => "Quadro+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50 = "5.0";
        
        public static ReadOnlySpan<byte> kString50_u8 => "5.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51 = "5.1";
        
        public static ReadOnlySpan<byte> kString51_u8 => "5.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60Cine = "6.0 Cine";
        
        public static ReadOnlySpan<byte> kString60Cine_u8 => "6.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60Music = "6.0 Music";
        
        public static ReadOnlySpan<byte> kString60Music_u8 => "6.0 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61Cine = "6.1 Cine";
        
        public static ReadOnlySpan<byte> kString61Cine_u8 => "6.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61Music = "6.1 Music";
        
        public static ReadOnlySpan<byte> kString61Music_u8 => "6.1 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70Cine = "7.0 SDDS";
        
        public static ReadOnlySpan<byte> kString70Cine_u8 => "7.0 SDDS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineOld = "7.0 Cine (SDDS)";
        
        public static ReadOnlySpan<byte> kString70CineOld_u8 => "7.0 Cine (SDDS)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70Music = "7.0";
        
        public static ReadOnlySpan<byte> kString70Music_u8 => "7.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70MusicOld = "7.0 Music (Dolby)";
        
        public static ReadOnlySpan<byte> kString70MusicOld_u8 => "7.0 Music (Dolby)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Cine = "7.1 SDDS";
        
        public static ReadOnlySpan<byte> kString71Cine_u8 => "7.1 SDDS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineOld = "7.1 Cine (SDDS)";
        
        public static ReadOnlySpan<byte> kString71CineOld_u8 => "7.1 Cine (SDDS)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Music = "7.1";
        
        public static ReadOnlySpan<byte> kString71Music_u8 => "7.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71MusicOld = "7.1 Music (Dolby)";
        
        public static ReadOnlySpan<byte> kString71MusicOld_u8 => "7.1 Music (Dolby)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineTopCenter = "7.1 Cine Top Center";
        
        public static ReadOnlySpan<byte> kString71CineTopCenter_u8 => "7.1 Cine Top Center\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineCenterHigh = "7.1 Cine Center High";
        
        public static ReadOnlySpan<byte> kString71CineCenterHigh_u8 => "7.1 Cine Center High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFrontHigh = "7.1 Cine Front High";
        
        public static ReadOnlySpan<byte> kString71CineFrontHigh_u8 => "7.1 Cine Front High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineFrontHigh = "7.0 Cine Front High";
        
        public static ReadOnlySpan<byte> kString70CineFrontHigh_u8 => "7.0 Cine Front High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineSideHigh = "7.1 Cine Side High";
        
        public static ReadOnlySpan<byte> kString71CineSideHigh_u8 => "7.1 Cine Side High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFullRear = "7.1 Cine Full Rear";
        
        public static ReadOnlySpan<byte> kString71CineFullRear_u8 => "7.1 Cine Full Rear\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Proximity = "7.1 Proximity";
        
        public static ReadOnlySpan<byte> kString71Proximity_u8 => "7.1 Proximity\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Cine = "8.0 Cine";
        
        public static ReadOnlySpan<byte> kString80Cine_u8 => "8.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Music = "8.0 Music";
        
        public static ReadOnlySpan<byte> kString80Music_u8 => "8.0 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Cube = "8.0 Cube";
        
        public static ReadOnlySpan<byte> kString80Cube_u8 => "8.0 Cube\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81Cine = "8.1 Cine";
        
        public static ReadOnlySpan<byte> kString81Cine_u8 => "8.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81Music = "8.1 Music";
        
        public static ReadOnlySpan<byte> kString81Music_u8 => "8.1 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90Cine = "9.0 Cine";
        
        public static ReadOnlySpan<byte> kString90Cine_u8 => "9.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91Cine = "9.1 Cine";
        
        public static ReadOnlySpan<byte> kString91Cine_u8 => "9.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100Cine = "10.0 Cine";
        
        public static ReadOnlySpan<byte> kString100Cine_u8 => "10.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101Cine = "10.1 Cine";
        
        public static ReadOnlySpan<byte> kString101Cine_u8 => "10.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString102 = "10.2 Experimental";
        
        public static ReadOnlySpan<byte> kString102_u8 => "10.2 Experimental\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString122 = "12.2";
        
        public static ReadOnlySpan<byte> kString122_u8 => "12.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4 = "5.0.4";
        
        public static ReadOnlySpan<byte> kString50_4_u8 => "5.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4 = "5.1.4";
        
        public static ReadOnlySpan<byte> kString51_4_u8 => "5.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4_1 = "5.0.4.1";
        
        public static ReadOnlySpan<byte> kString50_4_1_u8 => "5.0.4.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4_1 = "5.1.4.1";
        
        public static ReadOnlySpan<byte> kString51_4_1_u8 => "5.1.4.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_2 = "7.0.2";
        
        public static ReadOnlySpan<byte> kString70_2_u8 => "7.0.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_2 = "7.1.2";
        
        public static ReadOnlySpan<byte> kString71_2_u8 => "7.1.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_3 = "7.0.3";
        
        public static ReadOnlySpan<byte> kString70_3_u8 => "7.0.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString72_3 = "7.2.3";
        
        public static ReadOnlySpan<byte> kString72_3_u8 => "7.2.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_4 = "7.0.4";
        
        public static ReadOnlySpan<byte> kString70_4_u8 => "7.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_4 = "7.1.4";
        
        public static ReadOnlySpan<byte> kString71_4_u8 => "7.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_6 = "7.0.6";
        
        public static ReadOnlySpan<byte> kString70_6_u8 => "7.0.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_6 = "7.1.6";
        
        public static ReadOnlySpan<byte> kString71_6_u8 => "7.1.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_4 = "9.0.4";
        
        public static ReadOnlySpan<byte> kString90_4_u8 => "9.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_4 = "9.1.4";
        
        public static ReadOnlySpan<byte> kString91_4_u8 => "9.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_6 = "9.0.6";
        
        public static ReadOnlySpan<byte> kString90_6_u8 => "9.0.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_6 = "9.1.6";
        
        public static ReadOnlySpan<byte> kString91_6_u8 => "9.1.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100 = "10.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString100_u8 => "10.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101 = "10.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString101_u8 => "10.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString110 = "11.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString110_u8 => "11.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString111 = "11.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString111_u8 => "11.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString130 = "13.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString130_u8 => "13.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString131 = "13.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString131_u8 => "13.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MPEG = "8.1 MPEG";
        
        public static ReadOnlySpan<byte> kString81MPEG_u8 => "8.1 MPEG\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString140 = "14.0";
        
        public static ReadOnlySpan<byte> kString140_u8 => "14.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString222 = "22.2";
        
        public static ReadOnlySpan<byte> kString222_u8 => "22.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString220 = "22.0";
        
        public static ReadOnlySpan<byte> kString220_u8 => "22.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_5_3 = "5.0.5.3";
        
        public static ReadOnlySpan<byte> kString50_5_3_u8 => "5.0.5.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_5_3 = "5.1.5.3";
        
        public static ReadOnlySpan<byte> kString51_5_3_u8 => "5.1.5.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi1stOrder = "1st Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi1stOrder_u8 => "1st Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi2cdOrder = "2nd Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi2cdOrder_u8 => "2nd Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi3rdOrder = "3rd Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi3rdOrder_u8 => "3rd Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        /// <summary>
        /// Speaker Arrangement String Representation with Speakers Name.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public const string kStringMonoS = "M";
        
        /// <summary>
        /// Speaker Arrangement String Representation with Speakers Name.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kStringMonoS_u8 => "M\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoS = "L R";
        
        public static ReadOnlySpan<byte> kStringStereoS_u8 => "L R\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoRS = "Ls Rs";
        
        public static ReadOnlySpan<byte> kStringStereoRS_u8 => "Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCS = "Lc Rc";
        
        public static ReadOnlySpan<byte> kStringStereoCS_u8 => "Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoSS = "Sl Sr";
        
        public static ReadOnlySpan<byte> kStringStereoSS_u8 => "Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCLfeS = "C LFE";
        
        public static ReadOnlySpan<byte> kStringStereoCLfeS_u8 => "C LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTFS = "Tfl Tfr";
        
        public static ReadOnlySpan<byte> kStringStereoTFS_u8 => "Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTSS = "Tsl Tsr";
        
        public static ReadOnlySpan<byte> kStringStereoTSS_u8 => "Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTRS = "Trl Trr";
        
        public static ReadOnlySpan<byte> kStringStereoTRS_u8 => "Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoBFS = "Bfl Bfr";
        
        public static ReadOnlySpan<byte> kStringStereoBFS_u8 => "Bfl Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringCineFrontS = "L R C Lc Rc";
        
        public static ReadOnlySpan<byte> kStringCineFrontS_u8 => "L R C Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30CineS = "L R C";
        
        public static ReadOnlySpan<byte> kString30CineS_u8 => "L R C\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30MusicS = "L R S";
        
        public static ReadOnlySpan<byte> kString30MusicS_u8 => "L R S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31CineS = "L R C LFE";
        
        public static ReadOnlySpan<byte> kString31CineS_u8 => "L R C LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31MusicS = "L R LFE S";
        
        public static ReadOnlySpan<byte> kString31MusicS_u8 => "L R LFE S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40CineS = "L R C S";
        
        public static ReadOnlySpan<byte> kString40CineS_u8 => "L R C S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40MusicS = "L R Ls Rs";
        
        public static ReadOnlySpan<byte> kString40MusicS_u8 => "L R Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41CineS = "L R C LFE S";
        
        public static ReadOnlySpan<byte> kString41CineS_u8 => "L R C LFE S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41MusicS = "L R LFE Ls Rs";
        
        public static ReadOnlySpan<byte> kString41MusicS_u8 => "L R LFE Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50S = "L R C Ls Rs";
        
        public static ReadOnlySpan<byte> kString50S_u8 => "L R C Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51S = "L R C LFE Ls Rs";
        
        public static ReadOnlySpan<byte> kString51S_u8 => "L R C LFE Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60CineS = "L R C Ls Rs Cs";
        
        public static ReadOnlySpan<byte> kString60CineS_u8 => "L R C Ls Rs Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60MusicS = "L R Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString60MusicS_u8 => "L R Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61CineS = "L R C LFE Ls Rs Cs";
        
        public static ReadOnlySpan<byte> kString61CineS_u8 => "L R C LFE Ls Rs Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61MusicS = "L R LFE Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString61MusicS_u8 => "L R LFE Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineS = "L R C Ls Rs Lc Rc";
        
        public static ReadOnlySpan<byte> kString70CineS_u8 => "L R C Ls Rs Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70MusicS = "L R C Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString70MusicS_u8 => "L R C Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineS = "L R C LFE Ls Rs Lc Rc";
        
        public static ReadOnlySpan<byte> kString71CineS_u8 => "L R C LFE Ls Rs Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71MusicS = "L R C LFE Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString71MusicS_u8 => "L R C LFE Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80CineS = "L R C Ls Rs Lc Rc Cs";
        
        public static ReadOnlySpan<byte> kString80CineS_u8 => "L R C Ls Rs Lc Rc Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80MusicS = "L R C Ls Rs Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString80MusicS_u8 => "L R C Ls Rs Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81CineS = "L R C LFE Ls Rs Lc Rc Cs";
        
        public static ReadOnlySpan<byte> kString81CineS_u8 => "L R C LFE Ls Rs Lc Rc Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MusicS = "L R C LFE Ls Rs Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString81MusicS_u8 => "L R C LFE Ls Rs Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80CubeS = "L R Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString80CubeS_u8 => "L R Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineTopCenterS = "L R C LFE Ls Rs Cs Tc";
        
        public static ReadOnlySpan<byte> kString71CineTopCenterS_u8 => "L R C LFE Ls Rs Cs Tc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineCenterHighS = "L R C LFE Ls Rs Cs Tfc";
        
        public static ReadOnlySpan<byte> kString71CineCenterHighS_u8 => "L R C LFE Ls Rs Cs Tfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFrontHighS = "L R C LFE Ls Rs Tfl Tfr";
        
        public static ReadOnlySpan<byte> kString71CineFrontHighS_u8 => "L R C LFE Ls Rs Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineFrontHighS = "L R C Ls Rs Tfl Tfr";
        
        public static ReadOnlySpan<byte> kString70CineFrontHighS_u8 => "L R C Ls Rs Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineSideHighS = "L R C LFE Ls Rs Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71CineSideHighS_u8 => "L R C LFE Ls Rs Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFullRearS = "L R C LFE Ls Rs Lcs Rcs";
        
        public static ReadOnlySpan<byte> kString71CineFullRearS_u8 => "L R C LFE Ls Rs Lcs Rcs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71ProximityS = "L R C LFE Ls Rs Pl Pr";
        
        public static ReadOnlySpan<byte> kString71ProximityS_u8 => "L R C LFE Ls Rs Pl Pr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90CineS = "L R C Ls Rs Lc Rc Sl Sr";
        
        public static ReadOnlySpan<byte> kString90CineS_u8 => "L R C Ls Rs Lc Rc Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91CineS = "L R C LFE Ls Rs Lc Rc Sl Sr";
        
        public static ReadOnlySpan<byte> kString91CineS_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100CineS = "L R C Ls Rs Lc Rc Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString100CineS_u8 => "L R C Ls Rs Lc Rc Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101CineS = "L R C LFE Ls Rs Lc Rc Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString101CineS_u8 => "L R C LFE Ls Rs Lc Rc Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4S = "L R C Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString50_4S_u8 => "L R C Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4S = "L R C LFE Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString51_4S_u8 => "L R C LFE Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4_1S = "L R C Ls Rs Tfl Tfr Trl Trr Bfc";
        
        public static ReadOnlySpan<byte> kString50_4_1S_u8 => "L R C Ls Rs Tfl Tfr Trl Trr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4_1S = "L R C LFE Ls Rs Tfl Tfr Trl Trr Bfc";
        
        public static ReadOnlySpan<byte> kString51_4_1S_u8 => "L R C LFE Ls Rs Tfl Tfr Trl Trr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_2S = "L R C Ls Rs Sl Sr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString70_2S_u8 => "L R C Ls Rs Sl Sr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_2S = "L R C LFE Ls Rs Sl Sr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71_2S_u8 => "L R C LFE Ls Rs Sl Sr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_3S = "L R C Ls Rs Sl Sr Tfl Tfr Trc";
        
        public static ReadOnlySpan<byte> kString70_3S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString72_3S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trc LFE2";
        
        public static ReadOnlySpan<byte> kString72_3S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trc LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_4S = "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString70_4S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_4S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString71_4S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_6S = "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString70_6S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_6S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71_6S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_4S = "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString90_4S_u8 => "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_4S = "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString91_4S_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_6S = "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString90_6S_u8 => "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_6S = "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString91_6S_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100S = "L R C Ls Rs Tc Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString100S_u8 => "L R C Ls Rs Tc Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101S = "L R C LFE Ls Rs Tc Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString101S_u8 => "L R C LFE Ls Rs Tc Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString110S = "L R C Ls Rs Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString110S_u8 => "L R C Ls Rs Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString111S = "L R C LFE Ls Rs Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString111S_u8 => "L R C LFE Ls Rs Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString130S = "L R C Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString130S_u8 => "L R C Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString131S = "L R C LFE Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString131S_u8 => "L R C LFE Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString102S = "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr LFE2";
        
        public static ReadOnlySpan<byte> kString102S_u8 => "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString122S = "L R C LFE Ls Rs Lc Rc Tfl Tfc Tfr Trl Trr LFE2";
        
        public static ReadOnlySpan<byte> kString122S_u8 => "L R C LFE Ls Rs Lc Rc Tfl Tfc Tfr Trl Trr LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MPEGS = "L R LFE Ls Rs Tfl Tfc Tfr Bfc";
        
        public static ReadOnlySpan<byte> kString81MPEGS_u8 => "L R LFE Ls Rs Tfl Tfc Tfr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString140S = "L R Ls Rs Sl Sr Tfl Tfr Trl Trr Bfl Bfr Brl Brr";
        
        public static ReadOnlySpan<byte> kString140S_u8 => "L R Ls Rs Sl Sr Tfl Tfr Trl Trr Bfl Bfr Brl Brr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString222S = "L R C LFE Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr LFE2 Tsl Tsr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString222S_u8 => "L R C LFE Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr LFE2 Tsl Tsr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString220S = "L R C Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr Tsl Tsr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString220S_u8 => "L R C Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr Tsl Tsr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_5_3S = "L R C Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString50_5_3S_u8 => "L R C Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_5_3S = "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString51_5_3S_u8 => "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi1stOrderS = "0 1 2 3";
        
        public static ReadOnlySpan<byte> kStringAmbi1stOrderS_u8 => "0 1 2 3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi2cdOrderS = "0 1 2 3 4 5 6 7 8";
        
        public static ReadOnlySpan<byte> kStringAmbi2cdOrderS_u8 => "0 1 2 3 4 5 6 7 8\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi3rdOrderS = "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15";
        
        public static ReadOnlySpan<byte> kStringAmbi3rdOrderS_u8 => "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Scope, FFT-Display, Loudness Processing...
        /// </summary>
        public const string kFxAnalyzer = "Fx|Analyzer";
        
        /// <summary>
        /// Scope, FFT-Display, Loudness Processing...
        /// </summary>
        public static ReadOnlySpan<byte> kFxAnalyzer_u8 => "Fx|Analyzer\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Delay, Multi-tap Delay, Ping-Pong Delay...
        /// </summary>
        public const string kFxDelay = "Fx|Delay";
        
        /// <summary>
        /// Delay, Multi-tap Delay, Ping-Pong Delay...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDelay_u8 => "Fx|Delay\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Amp Simulator, Sub-Harmonic, SoftClipper...
        /// </summary>
        public const string kFxDistortion = "Fx|Distortion";
        
        /// <summary>
        /// Amp Simulator, Sub-Harmonic, SoftClipper...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDistortion_u8 => "Fx|Distortion\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Compressor, Expander, Gate, Limiter, Maximizer, Tape Simulator, EnvelopeShaper...
        /// </summary>
        public const string kFxDynamics = "Fx|Dynamics";
        
        /// <summary>
        /// Compressor, Expander, Gate, Limiter, Maximizer, Tape Simulator, EnvelopeShaper...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDynamics_u8 => "Fx|Dynamics\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Equalization, Graphical EQ...
        /// </summary>
        public const string kFxEQ = "Fx|EQ";
        
        /// <summary>
        /// Equalization, Graphical EQ...
        /// </summary>
        public static ReadOnlySpan<byte> kFxEQ_u8 => "Fx|EQ\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// WahWah, ToneBooster, Specific Filter,...
        /// </summary>
        public const string kFxFilter = "Fx|Filter";
        
        /// <summary>
        /// WahWah, ToneBooster, Specific Filter,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxFilter_u8 => "Fx|Filter\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// others type (not categorized)
        /// </summary>
        public const string kFx = "Fx";
        
        /// <summary>
        /// others type (not categorized)
        /// </summary>
        public static ReadOnlySpan<byte> kFx_u8 => "Fx\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Fx which could be loaded as Instrument too
        /// </summary>
        public const string kFxInstrument = "Fx|Instrument";
        
        /// <summary>
        /// Fx which could be loaded as Instrument too
        /// </summary>
        public static ReadOnlySpan<byte> kFxInstrument_u8 => "Fx|Instrument\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Fx which could be loaded as Instrument too and is external (wrapped Hardware)
        /// </summary>
        public const string kFxInstrumentExternal = "Fx|Instrument|External";
        
        /// <summary>
        /// Fx which could be loaded as Instrument too and is external (wrapped Hardware)
        /// </summary>
        public static ReadOnlySpan<byte> kFxInstrumentExternal_u8 => "Fx|Instrument|External\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// MonoToStereo, StereoEnhancer,...
        /// </summary>
        public const string kFxSpatial = "Fx|Spatial";
        
        /// <summary>
        /// MonoToStereo, StereoEnhancer,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxSpatial_u8 => "Fx|Spatial\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Tone Generator, Noise Generator...
        /// </summary>
        public const string kFxGenerator = "Fx|Generator";
        
        /// <summary>
        /// Tone Generator, Noise Generator...
        /// </summary>
        public static ReadOnlySpan<byte> kFxGenerator_u8 => "Fx|Generator\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Dither, Noise Shaping,...
        /// </summary>
        public const string kFxMastering = "Fx|Mastering";
        
        /// <summary>
        /// Dither, Noise Shaping,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxMastering_u8 => "Fx|Mastering\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Phaser, Flanger, Chorus, Tremolo, Vibrato, AutoPan, Rotary, Cloner...
        /// </summary>
        public const string kFxModulation = "Fx|Modulation";
        
        /// <summary>
        /// Phaser, Flanger, Chorus, Tremolo, Vibrato, AutoPan, Rotary, Cloner...
        /// </summary>
        public static ReadOnlySpan<byte> kFxModulation_u8 => "Fx|Modulation\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Pitch Processing, Pitch Correction, Vocal Tuning...
        /// </summary>
        public const string kFxPitchShift = "Fx|Pitch Shift";
        
        /// <summary>
        /// Pitch Processing, Pitch Correction, Vocal Tuning...
        /// </summary>
        public static ReadOnlySpan<byte> kFxPitchShift_u8 => "Fx|Pitch Shift\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Denoiser, Declicker,...
        /// </summary>
        public const string kFxRestoration = "Fx|Restoration";
        
        /// <summary>
        /// Denoiser, Declicker,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxRestoration_u8 => "Fx|Restoration\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Reverberation, Room Simulation, Convolution Reverb...
        /// </summary>
        public const string kFxReverb = "Fx|Reverb";
        
        /// <summary>
        /// Reverberation, Room Simulation, Convolution Reverb...
        /// </summary>
        public static ReadOnlySpan<byte> kFxReverb_u8 => "Fx|Reverb\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// dedicated to surround processing: LFE Splitter, Bass Manager...
        /// </summary>
        public const string kFxSurround = "Fx|Surround";
        
        /// <summary>
        /// dedicated to surround processing: LFE Splitter, Bass Manager...
        /// </summary>
        public static ReadOnlySpan<byte> kFxSurround_u8 => "Fx|Surround\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Volume, Mixer, Tuner...
        /// </summary>
        public const string kFxTools = "Fx|Tools";
        
        /// <summary>
        /// Volume, Mixer, Tuner...
        /// </summary>
        public static ReadOnlySpan<byte> kFxTools_u8 => "Fx|Tools\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// using Network
        /// </summary>
        public const string kFxNetwork = "Fx|Network";
        
        /// <summary>
        /// using Network
        /// </summary>
        public static ReadOnlySpan<byte> kFxNetwork_u8 => "Fx|Network\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Effect used as instrument (sound generator), not as insert
        /// </summary>
        public const string kInstrument = "Instrument";
        
        /// <summary>
        /// Effect used as instrument (sound generator), not as insert
        /// </summary>
        public static ReadOnlySpan<byte> kInstrument_u8 => "Instrument\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument for Drum sounds
        /// </summary>
        public const string kInstrumentDrum = "Instrument|Drum";
        
        /// <summary>
        /// Instrument for Drum sounds
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentDrum_u8 => "Instrument|Drum\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// External Instrument (wrapped Hardware)
        /// </summary>
        public const string kInstrumentExternal = "Instrument|External";
        
        /// <summary>
        /// External Instrument (wrapped Hardware)
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentExternal_u8 => "Instrument|External\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument for Piano sounds
        /// </summary>
        public const string kInstrumentPiano = "Instrument|Piano";
        
        /// <summary>
        /// Instrument for Piano sounds
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentPiano_u8 => "Instrument|Piano\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Samples
        /// </summary>
        public const string kInstrumentSampler = "Instrument|Sampler";
        
        /// <summary>
        /// Instrument based on Samples
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSampler_u8 => "Instrument|Sampler\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Synthesis
        /// </summary>
        public const string kInstrumentSynth = "Instrument|Synth";
        
        /// <summary>
        /// Instrument based on Synthesis
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSynth_u8 => "Instrument|Synth\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Synthesis and Samples
        /// </summary>
        public const string kInstrumentSynthSampler = "Instrument|Synth|Sampler";
        
        /// <summary>
        /// Instrument based on Synthesis and Samples
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSynthSampler_u8 => "Instrument|Synth|Sampler\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for SurroundPanner
        /// </summary>
        public const string kSpatial = "Spatial";
        
        /// <summary>
        /// used for SurroundPanner
        /// </summary>
        public static ReadOnlySpan<byte> kSpatial_u8 => "Spatial\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for SurroundPanner and as insert effect
        /// </summary>
        public const string kSpatialFx = "Spatial|Fx";
        
        /// <summary>
        /// used for SurroundPanner and as insert effect
        /// </summary>
        public static ReadOnlySpan<byte> kSpatialFx_u8 => "Spatial|Fx\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// indicates that it supports only realtime process call, no processing faster than realtime
        /// </summary>
        public const string kOnlyRealTime = "OnlyRT";
        
        /// <summary>
        /// indicates that it supports only realtime process call, no processing faster than realtime
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyRealTime_u8 => "OnlyRT\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for plug-in offline processing  (will not work as normal insert plug-in)
        /// </summary>
        public const string kOnlyOfflineProcess = "OnlyOfflineProcess";
        
        /// <summary>
        /// used for plug-in offline processing  (will not work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyOfflineProcess_u8 => "OnlyOfflineProcess\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for plug-ins that require ARA to operate (will not work as normal insert plug-in)
        /// </summary>
        public const string kOnlyARA = "OnlyARA";
        
        /// <summary>
        /// used for plug-ins that require ARA to operate (will not work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyARA_u8 => "OnlyARA\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// will be NOT used for plug-in offline processing (will work as normal insert plug-in)
        /// </summary>
        public const string kNoOfflineProcess = "NoOfflineProcess";
        
        /// <summary>
        /// will be NOT used for plug-in offline processing (will work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kNoOfflineProcess_u8 => "NoOfflineProcess\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Mixconverter/Up-Mixer/Down-Mixer
        /// </summary>
        public const string kUpDownMix = "Up-Downmix";
        
        /// <summary>
        /// used for Mixconverter/Up-Mixer/Down-Mixer
        /// </summary>
        public static ReadOnlySpan<byte> kUpDownMix_u8 => "Up-Downmix\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Meter, Scope, FFT-Display, not selectable as insert plug-in
        /// </summary>
        public const string kAnalyzer = "Analyzer";
        
        /// <summary>
        /// Meter, Scope, FFT-Display, not selectable as insert plug-in
        /// </summary>
        public static ReadOnlySpan<byte> kAnalyzer_u8 => "Analyzer\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Ambisonics channel (FX or Panner/Mixconverter/Up-Mixer/Down-Mixer when combined with other category)
        /// </summary>
        public const string kAmbisonics = "Ambisonics";
        
        /// <summary>
        /// used for Ambisonics channel (FX or Panner/Mixconverter/Up-Mixer/Down-Mixer when combined with other category)
        /// </summary>
        public static ReadOnlySpan<byte> kAmbisonics_u8 => "Ambisonics\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Mono only plug-in [optional]
        /// </summary>
        public const string kMono = "Mono";
        
        /// <summary>
        /// used for Mono only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kMono_u8 => "Mono\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Stereo only plug-in [optional]
        /// </summary>
        public const string kStereo = "Stereo";
        
        /// <summary>
        /// used for Stereo only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kStereo_u8 => "Stereo\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Surround only plug-in [optional]
        /// </summary>
        public const string kSurround = "Surround";
        
        /// <summary>
        /// used for Surround only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kSurround_u8 => "Surround\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// Keys used as AttrID (Attribute ID) in the return IAttributeList of
        /// IInfoListener::setChannelContextInfos
        /// </summary>
        /// <remarks>
        /// ------------------------------------------------------------------------
        /// string (TChar) [optional]: unique id string used to identify a channel
        /// </remarks>
        public const string kChannelUIDKey = "channel uid";
        
        /// <summary>
        /// Keys used as AttrID (Attribute ID) in the return IAttributeList of
        /// IInfoListener::setChannelContextInfos
        /// </summary>
        /// <remarks>
        /// ------------------------------------------------------------------------
        /// string (TChar) [optional]: unique id string used to identify a channel
        /// </remarks>
        public static ReadOnlySpan<byte> kChannelUIDKey_u8 => "channel uid\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelUIDKey
        /// </summary>
        public const string kChannelUIDLengthKey = "channel uid length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelUIDKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelUIDLengthKey_u8 => "channel uid length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// string (TChar) [optional]: name of the channel like displayed in the mixer
        /// </summary>
        public const string kChannelNameKey = "channel name";
        
        /// <summary>
        /// string (TChar) [optional]: name of the channel like displayed in the mixer
        /// </summary>
        public static ReadOnlySpan<byte> kChannelNameKey_u8 => "channel name\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelNameKey
        /// </summary>
        public const string kChannelNameLengthKey = "channel name length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelNameKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelNameLengthKey_u8 => "channel name length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// color (ColorSpec) [optional]: used color for the channel in mixer or track
        /// </summary>
        public const string kChannelColorKey = "channel color";
        
        /// <summary>
        /// color (ColorSpec) [optional]: used color for the channel in mixer or track
        /// </summary>
        public static ReadOnlySpan<byte> kChannelColorKey_u8 => "channel color\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: index of the channel in a channel index namespace, start with 1 not * 0!
        /// </summary>
        public const string kChannelIndexKey = "channel index";
        
        /// <summary>
        /// integer (int64) [optional]: index of the channel in a channel index namespace, start with 1 not * 0!
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexKey_u8 => "channel index\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: define the order of the current used index namespace, start with 1 not 0!
        /// For example:
        /// index namespace is "Input"   -&gt; order 1,
        /// index namespace is "Channel" -&gt; order 2,
        /// index namespace is "Output"  -&gt; order 3
        /// </summary>
        public const string kChannelIndexNamespaceOrderKey = "channel index namespace order";
        
        /// <summary>
        /// integer (int64) [optional]: define the order of the current used index namespace, start with 1 not 0!
        /// For example:
        /// index namespace is "Input"   -&gt; order 1,
        /// index namespace is "Channel" -&gt; order 2,
        /// index namespace is "Output"  -&gt; order 3
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceOrderKey_u8 => "channel index namespace order\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// string (TChar) [optional]: name of the channel index namespace for example "Input", "Output", "Channel", ...
        /// </summary>
        public const string kChannelIndexNamespaceKey = "channel index namespace";
        
        /// <summary>
        /// string (TChar) [optional]: name of the channel index namespace for example "Input", "Output", "Channel", ...
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceKey_u8 => "channel index namespace\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelIndexNamespaceKey
        /// </summary>
        public const string kChannelIndexNamespaceLengthKey = "channel index namespace length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelIndexNamespaceKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceLengthKey_u8 => "channel index namespace length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// PNG image representation as binary [optional]
        /// </summary>
        public const string kChannelImageKey = "channel image";
        
        /// <summary>
        /// PNG image representation as binary [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kChannelImageKey_u8 => "channel image\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: routing position of the plug-in in the channel (see ChannelPluginLocation)
        /// </summary>
        public const string kChannelPluginLocationKey = "channel plugin location";
        
        /// <summary>
        /// integer (int64) [optional]: routing position of the plug-in in the channel (see ChannelPluginLocation)
        /// </summary>
        public static ReadOnlySpan<byte> kChannelPluginLocationKey_u8 => "channel plugin location\0"u8;
    }
    
    public static partial class ViewType
    {
        public const string kEditor = "editor";
        
        public static ReadOnlySpan<byte> kEditor_u8 => "editor\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// 
        /// </summary>
        public const string kCompGainReduction = "Comp:GainReduction";
        
        /// <summary>
        /// 
        /// </summary>
        public static ReadOnlySpan<byte> kCompGainReduction_u8 => "Comp:GainReduction\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompGainReductionMax = "Comp:GainReductionMax";
        
        public static ReadOnlySpan<byte> kCompGainReductionMax_u8 => "Comp:GainReductionMax\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompGainReductionPeakHold = "Comp:GainReductionPeakHold";
        
        public static ReadOnlySpan<byte> kCompGainReductionPeakHold_u8 => "Comp:GainReductionPeakHold\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompResetGainReductionMax = "Comp:ResetGainReductionMax";
        
        public static ReadOnlySpan<byte> kCompResetGainReductionMax_u8 => "Comp:ResetGainReductionMax\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kLowLatencyMode = "LowLatencyMode";
        
        public static ReadOnlySpan<byte> kLowLatencyMode_u8 => "LowLatencyMode\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Useful for live situation where low
        /// latency is required:
        /// 0 means LowLatency disable,
        /// 1 means LowLatency enable
        /// </summary>
        public const string kDryWetMix = "DryWetMix";
        
        /// <summary>
        /// Useful for live situation where low
        /// latency is required:
        /// 0 means LowLatency disable,
        /// 1 means LowLatency enable
        /// </summary>
        public static ReadOnlySpan<byte> kDryWetMix_u8 => "DryWetMix\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Allowing to mix the original (Dry) Signal with the processed one (Wet):
        /// 0.0 means Dry Signal only,
        /// 0.5 means 50% Dry Signal + 50% Wet Signal,
        /// 1.0 means Wet Signal only
        /// </summary>
        public const string kRandomize = "Randomize";
        
        /// <summary>
        /// Allowing to mix the original (Dry) Signal with the processed one (Wet):
        /// 0.0 means Dry Signal only,
        /// 0.5 means 50% Dry Signal + 50% Wet Signal,
        /// 1.0 means Wet Signal only
        /// </summary>
        public static ReadOnlySpan<byte> kRandomize_u8 => "Randomize\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point X-axis [0, 1]=&gt;[L-R] (for stereo: middle between left and right)
        /// </summary>
        public const string kPanPosCenterX = "PanPosCenterX";
        
        /// <summary>
        /// Gravity point X-axis [0, 1]=&gt;[L-R] (for stereo: middle between left and right)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterX_u8 => "PanPosCenterX\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point Y-axis [0, 1]=&gt;[Front-Rear]
        /// </summary>
        public const string kPanPosCenterY = "PanPosCenterY";
        
        /// <summary>
        /// Gravity point Y-axis [0, 1]=&gt;[Front-Rear]
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterY_u8 => "PanPosCenterY\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point Z-axis [0, 1]=&gt;[Bottom-Top]
        /// </summary>
        public const string kPanPosCenterZ = "PanPosCenterZ";
        
        /// <summary>
        /// Gravity point Z-axis [0, 1]=&gt;[Bottom-Top]
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterZ_u8 => "PanPosCenterZ\0"u8;
    }
    
    public static partial class CurveType
    {
        public const string kSegment = "segment";
        
        public static ReadOnlySpan<byte> kSegment_u8 => "segment\0"u8;
    }
    
    public static partial class CurveType
    {
        public const string kValueList = "valueList";
        
        public static ReadOnlySpan<byte> kValueList_u8 => "valueList\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kStyle = "style";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kStyle_u8 => "style\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kLEDStyle = "ledStyle";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kLEDStyle_u8 => "ledStyle\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kSwitchStyle = "switchStyle";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchStyle_u8 => "switchStyle\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// float attribute
        /// </summary>
        public const string kKnobTurnsPerFullRange = "turnsPerFullRange";
        
        /// <summary>
        /// float attribute
        /// </summary>
        public static ReadOnlySpan<byte> kKnobTurnsPerFullRange_u8 => "turnsPerFullRange\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesFunction for available string value
        /// </summary>
        public const string kFunction = "function";
        
        /// <summary>
        /// string attribute : See AttributesFunction for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kFunction_u8 => "function\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesFlags for available string value
        /// </summary>
        public const string kFlags = "flags";
        
        /// <summary>
        /// string attribute : See AttributesFlags for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kFlags_u8 => "flags\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gravity point X-axis (L-R) (for stereo: middle between left and right)
        /// </summary>
        public const string kPanPosCenterXFunc = "PanPosCenterX";
        
        /// <summary>
        /// Gravity point X-axis (L-R) (for stereo: middle between left and right)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterXFunc_u8 => "PanPosCenterX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gravity point Y-axis (Front-Rear)
        /// </summary>
        public const string kPanPosCenterYFunc = "PanPosCenterY";
        
        /// <summary>
        /// Gravity point Y-axis (Front-Rear)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterYFunc_u8 => "PanPosCenterY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Left channel Position in X-axis
        /// </summary>
        public const string kPanPosFrontLeftXFunc = "PanPosFrontLeftX";
        
        /// <summary>
        /// Left channel Position in X-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontLeftXFunc_u8 => "PanPosFrontLeftX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Left channel Position in Y-axis
        /// </summary>
        public const string kPanPosFrontLeftYFunc = "PanPosFrontLeftY";
        
        /// <summary>
        /// Left channel Position in Y-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontLeftYFunc_u8 => "PanPosFrontLeftY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Right channel Position in X-axis
        /// </summary>
        public const string kPanPosFrontRightXFunc = "PanPosFrontRightX";
        
        /// <summary>
        /// Right channel Position in X-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontRightXFunc_u8 => "PanPosFrontRightX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Right channel Position in Y-axis
        /// </summary>
        public const string kPanPosFrontRightYFunc = "PanPosFrontRightY";
        
        /// <summary>
        /// Right channel Position in Y-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontRightYFunc_u8 => "PanPosFrontRightY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Rotation around the Center (gravity point)
        /// </summary>
        public const string kPanRotationFunc = "PanRotation";
        
        /// <summary>
        /// Rotation around the Center (gravity point)
        /// </summary>
        public static ReadOnlySpan<byte> kPanRotationFunc_u8 => "PanRotation\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning Law
        /// </summary>
        public const string kPanLawFunc = "PanLaw";
        
        /// <summary>
        /// Panning Law
        /// </summary>
        public static ReadOnlySpan<byte> kPanLawFunc_u8 => "PanLaw\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning Mirror Mode
        /// </summary>
        public const string kPanMirrorModeFunc = "PanMirrorMode";
        
        /// <summary>
        /// Panning Mirror Mode
        /// </summary>
        public static ReadOnlySpan<byte> kPanMirrorModeFunc_u8 => "PanMirrorMode\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning LFE Gain
        /// </summary>
        public const string kPanLfeGainFunc = "PanLfeGain";
        
        /// <summary>
        /// Panning LFE Gain
        /// </summary>
        public static ReadOnlySpan<byte> kPanLfeGainFunc_u8 => "PanLfeGain\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gain Reduction for compressor
        /// </summary>
        public const string kGainReductionFunc = "GainReduction";
        
        /// <summary>
        /// Gain Reduction for compressor
        /// </summary>
        public static ReadOnlySpan<byte> kGainReductionFunc_u8 => "GainReduction\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Solo
        /// </summary>
        public const string kSoloFunc = "Solo";
        
        /// <summary>
        /// Solo
        /// </summary>
        public static ReadOnlySpan<byte> kSoloFunc_u8 => "Solo\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Mute
        /// </summary>
        public const string kMuteFunc = "Mute";
        
        /// <summary>
        /// Mute
        /// </summary>
        public static ReadOnlySpan<byte> kMuteFunc_u8 => "Mute\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Volume
        /// </summary>
        public const string kVolumeFunc = "Volume";
        
        /// <summary>
        /// Volume
        /// </summary>
        public static ReadOnlySpan<byte> kVolumeFunc_u8 => "Volume\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// the associated layer should use the inverse value of parameter (1 - x).
        /// </summary>
        public const string kInverseStyle = "inverse";
        
        /// <summary>
        /// the associated layer should use the inverse value of parameter (1 - x).
        /// </summary>
        public static ReadOnlySpan<byte> kInverseStyle_u8 => "inverse\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// |======&gt;----- (the default one if not specified)
        /// </summary>
        public const string kLEDWrapLeftStyle = "wrapLeft";
        
        /// <summary>
        /// |======&gt;----- (the default one if not specified)
        /// </summary>
        public static ReadOnlySpan<byte> kLEDWrapLeftStyle_u8 => "wrapLeft\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// &lt;
        /// ====|
        /// </summary>
        public const string kLEDWrapRightStyle = "wrapRight";
        
        /// <summary>
        /// &lt;
        /// ====|
        /// </summary>
        public static ReadOnlySpan<byte> kLEDWrapRightStyle_u8 => "wrapRight\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// &lt;
        /// ==|==&gt;---
        /// </summary>
        public const string kLEDSpreadStyle = "spread";
        
        /// <summary>
        /// &lt;
        /// ==|==&gt;---
        /// </summary>
        public static ReadOnlySpan<byte> kLEDSpreadStyle_u8 => "spread\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// ------|===&gt;--
        /// </summary>
        public const string kLEDBoostCutStyle = "boostCut";
        
        /// <summary>
        /// ------|===&gt;--
        /// </summary>
        public static ReadOnlySpan<byte> kLEDBoostCutStyle_u8 => "boostCut\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// --------|----
        /// </summary>
        public const string kLEDSingleDotStyle = "singleDot";
        
        /// <summary>
        /// --------|----
        /// </summary>
        public static ReadOnlySpan<byte> kLEDSingleDotStyle_u8 => "singleDot\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Apply only when pressed, unpressed will reset the value to min.
        /// </summary>
        public const string kSwitchPushStyle = "push";
        
        /// <summary>
        /// Apply only when pressed, unpressed will reset the value to min.
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushStyle_u8 => "push\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Push will increment the value. When the max is reached it will restart with min.
        /// The default one if not specified (with 2 states values it is a OnOff switch).
        /// </summary>
        public const string kSwitchPushIncLoopedStyle = "pushIncLooped";
        
        /// <summary>
        /// Push will increment the value. When the max is reached it will restart with min.
        /// The default one if not specified (with 2 states values it is a OnOff switch).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushIncLoopedStyle_u8 => "pushIncLooped\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Push will decrement the value. When the min is reached it will restart with max.
        /// </summary>
        public const string kSwitchPushDecLoopedStyle = "pushDecLooped";
        
        /// <summary>
        /// Push will decrement the value. When the min is reached it will restart with max.
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushDecLoopedStyle_u8 => "pushDecLooped\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Increment after each press (delta depends of the curve).
        /// </summary>
        public const string kSwitchPushIncStyle = "pushInc";
        
        /// <summary>
        /// Increment after each press (delta depends of the curve).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushIncStyle_u8 => "pushInc\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Decrement after each press (delta depends of the curve).
        /// </summary>
        public const string kSwitchPushDecStyle = "pushDec";
        
        /// <summary>
        /// Decrement after each press (delta depends of the curve).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushDecStyle_u8 => "pushDec\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Each push-release will change the value between min and max. 
        /// A timeout between push and release could be used to simulate a push style (if timeout is reached).
        /// </summary>
        public const string kSwitchLatchStyle = "latch";
        
        /// <summary>
        /// Each push-release will change the value between min and max. 
        /// A timeout between push and release could be used to simulate a push style (if timeout is reached).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchLatchStyle_u8 => "latch\0"u8;
    }
    
    public static partial class AttributesFlags
    {
        /// <summary>
        /// the associated layer marked as hideable allows a remote to hide or make it not usable a parameter when the associated value is inactive
        /// </summary>
        public const string kHideableFlag = "hideable";
        
        /// <summary>
        /// the associated layer marked as hideable allows a remote to hide or make it not usable a parameter when the associated value is inactive
        /// </summary>
        public static ReadOnlySpan<byte> kHideableFlag_u8 => "hideable\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// plug-in name
        /// </summary>
        public const string kPlugInName = "PlugInName";
        
        /// <summary>
        /// plug-in name
        /// </summary>
        public static ReadOnlySpan<byte> kPlugInName_u8 => "PlugInName\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. "Fx|Dynamics", "Instrument", "Instrument|Synth"
        /// </summary>
        public const string kPlugInCategory = "PlugInCategory";
        
        /// <summary>
        /// eg. "Fx|Dynamics", "Instrument", "Instrument|Synth"
        /// </summary>
        public static ReadOnlySpan<byte> kPlugInCategory_u8 => "PlugInCategory\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. instrument group (like 'Piano' or 'Piano|A. Piano')
        /// </summary>
        public const string kInstrument = "MusicalInstrument";
        
        /// <summary>
        /// eg. instrument group (like 'Piano' or 'Piano|A. Piano')
        /// </summary>
        public static ReadOnlySpan<byte> kInstrument_u8 => "MusicalInstrument\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. 'Pop', 'Jazz', 'Classic'
        /// </summary>
        public const string kStyle = "MusicalStyle";
        
        /// <summary>
        /// eg. 'Pop', 'Jazz', 'Classic'
        /// </summary>
        public static ReadOnlySpan<byte> kStyle_u8 => "MusicalStyle\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. instrument nature (like 'Soft' 'Dry' 'Acoustic')
        /// </summary>
        public const string kCharacter = "MusicalCharacter";
        
        /// <summary>
        /// eg. instrument nature (like 'Soft' 'Dry' 'Acoustic')
        /// </summary>
        public static ReadOnlySpan<byte> kCharacter_u8 => "MusicalCharacter\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// Type of the given state see @ref StateType : Project / Default Preset or Normal Preset
        /// </summary>
        public const string kStateType = "StateType";
        
        /// <summary>
        /// Type of the given state see @ref StateType : Project / Default Preset or Normal Preset
        /// </summary>
        public static ReadOnlySpan<byte> kStateType_u8 => "StateType\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// Full file path string (if available) where the preset comes from (be sure to use a bigger string when asking for it (with 1024 characters))
        /// </summary>
        public const string kFilePathStringType = "FilePathString";
        
        /// <summary>
        /// Full file path string (if available) where the preset comes from (be sure to use a bigger string when asking for it (with 1024 characters))
        /// </summary>
        public static ReadOnlySpan<byte> kFilePathStringType_u8 => "FilePathString\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// name of the preset
        /// </summary>
        public const string kName = "Name";
        
        /// <summary>
        /// name of the preset
        /// </summary>
        public static ReadOnlySpan<byte> kName_u8 => "Name\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// filename of the preset (including extension)
        /// </summary>
        public const string kFileName = "FileName";
        
        /// <summary>
        /// filename of the preset (including extension)
        /// </summary>
        public static ReadOnlySpan<byte> kFileName_u8 => "FileName\0"u8;
    }
    
    public static partial class StateType
    {
        /// <summary>
        /// the state is restored from a project loading or it is saved in a project
        /// </summary>
        public const string kProject = "Project";
        
        /// <summary>
        /// the state is restored from a project loading or it is saved in a project
        /// </summary>
        public static ReadOnlySpan<byte> kProject_u8 => "Project\0"u8;
    }
    
    public static partial class StateType
    {
        /// <summary>
        /// the state is restored from a preset (marked as default) or the host wants to store a default state of the plug-in
        /// </summary>
        public const string kDefault = "Default";
        
        /// <summary>
        /// the state is restored from a preset (marked as default) or the host wants to store a default state of the plug-in
        /// </summary>
        public static ReadOnlySpan<byte> kDefault_u8 => "Default\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        /// <summary>
        ///  musicalInstrument Predefined Musical Instrument
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public const string kAccordion = "Accordion";
        
        /// <summary>
        ///  musicalInstrument Predefined Musical Instrument
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kAccordion_u8 => "Accordion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionAccordion = "Accordion|Accordion";
        
        public static ReadOnlySpan<byte> kAccordionAccordion_u8 => "Accordion|Accordion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionHarmonica = "Accordion|Harmonica";
        
        public static ReadOnlySpan<byte> kAccordionHarmonica_u8 => "Accordion|Harmonica\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionOther = "Accordion|Other";
        
        public static ReadOnlySpan<byte> kAccordionOther_u8 => "Accordion|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBass = "Bass";
        
        public static ReadOnlySpan<byte> kBass_u8 => "Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassABass = "Bass|A. Bass";
        
        public static ReadOnlySpan<byte> kBassABass_u8 => "Bass|A. Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassEBass = "Bass|E. Bass";
        
        public static ReadOnlySpan<byte> kBassEBass_u8 => "Bass|E. Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassSynthBass = "Bass|Synth Bass";
        
        public static ReadOnlySpan<byte> kBassSynthBass_u8 => "Bass|Synth Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassOther = "Bass|Other";
        
        public static ReadOnlySpan<byte> kBassOther_u8 => "Bass|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrass = "Brass";
        
        public static ReadOnlySpan<byte> kBrass_u8 => "Brass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassFrenchHorn = "Brass|French Horn";
        
        public static ReadOnlySpan<byte> kBrassFrenchHorn_u8 => "Brass|French Horn\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTrumpet = "Brass|Trumpet";
        
        public static ReadOnlySpan<byte> kBrassTrumpet_u8 => "Brass|Trumpet\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTrombone = "Brass|Trombone";
        
        public static ReadOnlySpan<byte> kBrassTrombone_u8 => "Brass|Trombone\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTuba = "Brass|Tuba";
        
        public static ReadOnlySpan<byte> kBrassTuba_u8 => "Brass|Tuba\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassSection = "Brass|Section";
        
        public static ReadOnlySpan<byte> kBrassSection_u8 => "Brass|Section\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassSynth = "Brass|Synth";
        
        public static ReadOnlySpan<byte> kBrassSynth_u8 => "Brass|Synth\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassOther = "Brass|Other";
        
        public static ReadOnlySpan<byte> kBrassOther_u8 => "Brass|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPerc = "Chromatic Perc";
        
        public static ReadOnlySpan<byte> kChromaticPerc_u8 => "Chromatic Perc\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercBell = "Chromatic Perc|Bell";
        
        public static ReadOnlySpan<byte> kChromaticPercBell_u8 => "Chromatic Perc|Bell\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercMallett = "Chromatic Perc|Mallett";
        
        public static ReadOnlySpan<byte> kChromaticPercMallett_u8 => "Chromatic Perc|Mallett\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercWood = "Chromatic Perc|Wood";
        
        public static ReadOnlySpan<byte> kChromaticPercWood_u8 => "Chromatic Perc|Wood\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercPercussion = "Chromatic Perc|Percussion";
        
        public static ReadOnlySpan<byte> kChromaticPercPercussion_u8 => "Chromatic Perc|Percussion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercTimpani = "Chromatic Perc|Timpani";
        
        public static ReadOnlySpan<byte> kChromaticPercTimpani_u8 => "Chromatic Perc|Timpani\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercOther = "Chromatic Perc|Other";
        
        public static ReadOnlySpan<byte> kChromaticPercOther_u8 => "Chromatic Perc|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPerc = "Drum&Perc";
        
        public static ReadOnlySpan<byte> kDrumPerc_u8 => "Drum&Perc\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumsetGM = "Drum&Perc|Drumset GM";
        
        public static ReadOnlySpan<byte> kDrumPercDrumsetGM_u8 => "Drum&Perc|Drumset GM\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumset = "Drum&Perc|Drumset";
        
        public static ReadOnlySpan<byte> kDrumPercDrumset_u8 => "Drum&Perc|Drumset\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumMenues = "Drum&Perc|Drum Menues";
        
        public static ReadOnlySpan<byte> kDrumPercDrumMenues_u8 => "Drum&Perc|Drum Menues\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercBeats = "Drum&Perc|Beats";
        
        public static ReadOnlySpan<byte> kDrumPercBeats_u8 => "Drum&Perc|Beats\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercPercussion = "Drum&Perc|Percussion";
        
        public static ReadOnlySpan<byte> kDrumPercPercussion_u8 => "Drum&Perc|Percussion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercKickDrum = "Drum&Perc|Kick Drum";
        
        public static ReadOnlySpan<byte> kDrumPercKickDrum_u8 => "Drum&Perc|Kick Drum\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercSnareDrum = "Drum&Perc|Snare Drum";
        
        public static ReadOnlySpan<byte> kDrumPercSnareDrum_u8 => "Drum&Perc|Snare Drum\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercToms = "Drum&Perc|Toms";
        
        public static ReadOnlySpan<byte> kDrumPercToms_u8 => "Drum&Perc|Toms\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercHiHats = "Drum&Perc|HiHats";
        
        public static ReadOnlySpan<byte> kDrumPercHiHats_u8 => "Drum&Perc|HiHats\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercCymbals = "Drum&Perc|Cymbals";
        
        public static ReadOnlySpan<byte> kDrumPercCymbals_u8 => "Drum&Perc|Cymbals\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercOther = "Drum&Perc|Other";
        
        public static ReadOnlySpan<byte> kDrumPercOther_u8 => "Drum&Perc|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnic = "Ethnic";
        
        public static ReadOnlySpan<byte> kEthnic_u8 => "Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAsian = "Ethnic|Asian";
        
        public static ReadOnlySpan<byte> kEthnicAsian_u8 => "Ethnic|Asian\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAfrican = "Ethnic|African";
        
        public static ReadOnlySpan<byte> kEthnicAfrican_u8 => "Ethnic|African\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicEuropean = "Ethnic|European";
        
        public static ReadOnlySpan<byte> kEthnicEuropean_u8 => "Ethnic|European\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicLatin = "Ethnic|Latin";
        
        public static ReadOnlySpan<byte> kEthnicLatin_u8 => "Ethnic|Latin\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAmerican = "Ethnic|American";
        
        public static ReadOnlySpan<byte> kEthnicAmerican_u8 => "Ethnic|American\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAlien = "Ethnic|Alien";
        
        public static ReadOnlySpan<byte> kEthnicAlien_u8 => "Ethnic|Alien\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicOther = "Ethnic|Other";
        
        public static ReadOnlySpan<byte> kEthnicOther_u8 => "Ethnic|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitar = "Guitar/Plucked";
        
        public static ReadOnlySpan<byte> kGuitar_u8 => "Guitar/Plucked\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarAGuitar = "Guitar/Plucked|A. Guitar";
        
        public static ReadOnlySpan<byte> kGuitarAGuitar_u8 => "Guitar/Plucked|A. Guitar\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarEGuitar = "Guitar/Plucked|E. Guitar";
        
        public static ReadOnlySpan<byte> kGuitarEGuitar_u8 => "Guitar/Plucked|E. Guitar\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarHarp = "Guitar/Plucked|Harp";
        
        public static ReadOnlySpan<byte> kGuitarHarp_u8 => "Guitar/Plucked|Harp\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarEthnic = "Guitar/Plucked|Ethnic";
        
        public static ReadOnlySpan<byte> kGuitarEthnic_u8 => "Guitar/Plucked|Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarOther = "Guitar/Plucked|Other";
        
        public static ReadOnlySpan<byte> kGuitarOther_u8 => "Guitar/Plucked|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboard = "Keyboard";
        
        public static ReadOnlySpan<byte> kKeyboard_u8 => "Keyboard\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardClavi = "Keyboard|Clavi";
        
        public static ReadOnlySpan<byte> kKeyboardClavi_u8 => "Keyboard|Clavi\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardEPiano = "Keyboard|E. Piano";
        
        public static ReadOnlySpan<byte> kKeyboardEPiano_u8 => "Keyboard|E. Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardHarpsichord = "Keyboard|Harpsichord";
        
        public static ReadOnlySpan<byte> kKeyboardHarpsichord_u8 => "Keyboard|Harpsichord\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardOther = "Keyboard|Other";
        
        public static ReadOnlySpan<byte> kKeyboardOther_u8 => "Keyboard|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFX = "Musical FX";
        
        public static ReadOnlySpan<byte> kMusicalFX_u8 => "Musical FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXHitsStabs = "Musical FX|Hits&Stabs";
        
        public static ReadOnlySpan<byte> kMusicalFXHitsStabs_u8 => "Musical FX|Hits&Stabs\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXMotion = "Musical FX|Motion";
        
        public static ReadOnlySpan<byte> kMusicalFXMotion_u8 => "Musical FX|Motion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXSweeps = "Musical FX|Sweeps";
        
        public static ReadOnlySpan<byte> kMusicalFXSweeps_u8 => "Musical FX|Sweeps\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXBeepsBlips = "Musical FX|Beeps&Blips";
        
        public static ReadOnlySpan<byte> kMusicalFXBeepsBlips_u8 => "Musical FX|Beeps&Blips\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXScratches = "Musical FX|Scratches";
        
        public static ReadOnlySpan<byte> kMusicalFXScratches_u8 => "Musical FX|Scratches\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXOther = "Musical FX|Other";
        
        public static ReadOnlySpan<byte> kMusicalFXOther_u8 => "Musical FX|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrgan = "Organ";
        
        public static ReadOnlySpan<byte> kOrgan_u8 => "Organ\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganElectric = "Organ|Electric";
        
        public static ReadOnlySpan<byte> kOrganElectric_u8 => "Organ|Electric\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganPipe = "Organ|Pipe";
        
        public static ReadOnlySpan<byte> kOrganPipe_u8 => "Organ|Pipe\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganOther = "Organ|Other";
        
        public static ReadOnlySpan<byte> kOrganOther_u8 => "Organ|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPiano = "Piano";
        
        public static ReadOnlySpan<byte> kPiano_u8 => "Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoAPiano = "Piano|A. Piano";
        
        public static ReadOnlySpan<byte> kPianoAPiano_u8 => "Piano|A. Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoEGrand = "Piano|E. Grand";
        
        public static ReadOnlySpan<byte> kPianoEGrand_u8 => "Piano|E. Grand\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoOther = "Piano|Other";
        
        public static ReadOnlySpan<byte> kPianoOther_u8 => "Piano|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFX = "Sound FX";
        
        public static ReadOnlySpan<byte> kSoundFX_u8 => "Sound FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXNature = "Sound FX|Nature";
        
        public static ReadOnlySpan<byte> kSoundFXNature_u8 => "Sound FX|Nature\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXMechanical = "Sound FX|Mechanical";
        
        public static ReadOnlySpan<byte> kSoundFXMechanical_u8 => "Sound FX|Mechanical\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXSynthetic = "Sound FX|Synthetic";
        
        public static ReadOnlySpan<byte> kSoundFXSynthetic_u8 => "Sound FX|Synthetic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXOther = "Sound FX|Other";
        
        public static ReadOnlySpan<byte> kSoundFXOther_u8 => "Sound FX|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStrings = "Strings";
        
        public static ReadOnlySpan<byte> kStrings_u8 => "Strings\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsViolin = "Strings|Violin";
        
        public static ReadOnlySpan<byte> kStringsViolin_u8 => "Strings|Violin\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsViola = "Strings|Viola";
        
        public static ReadOnlySpan<byte> kStringsViola_u8 => "Strings|Viola\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsCello = "Strings|Cello";
        
        public static ReadOnlySpan<byte> kStringsCello_u8 => "Strings|Cello\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsBass = "Strings|Bass";
        
        public static ReadOnlySpan<byte> kStringsBass_u8 => "Strings|Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsSection = "Strings|Section";
        
        public static ReadOnlySpan<byte> kStringsSection_u8 => "Strings|Section\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsSynth = "Strings|Synth";
        
        public static ReadOnlySpan<byte> kStringsSynth_u8 => "Strings|Synth\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsOther = "Strings|Other";
        
        public static ReadOnlySpan<byte> kStringsOther_u8 => "Strings|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLead = "Synth Lead";
        
        public static ReadOnlySpan<byte> kSynthLead_u8 => "Synth Lead\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadAnalog = "Synth Lead|Analog";
        
        public static ReadOnlySpan<byte> kSynthLeadAnalog_u8 => "Synth Lead|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadDigital = "Synth Lead|Digital";
        
        public static ReadOnlySpan<byte> kSynthLeadDigital_u8 => "Synth Lead|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadArpeggio = "Synth Lead|Arpeggio";
        
        public static ReadOnlySpan<byte> kSynthLeadArpeggio_u8 => "Synth Lead|Arpeggio\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadOther = "Synth Lead|Other";
        
        public static ReadOnlySpan<byte> kSynthLeadOther_u8 => "Synth Lead|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPad = "Synth Pad";
        
        public static ReadOnlySpan<byte> kSynthPad_u8 => "Synth Pad\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadSynthChoir = "Synth Pad|Synth Choir";
        
        public static ReadOnlySpan<byte> kSynthPadSynthChoir_u8 => "Synth Pad|Synth Choir\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadAnalog = "Synth Pad|Analog";
        
        public static ReadOnlySpan<byte> kSynthPadAnalog_u8 => "Synth Pad|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadDigital = "Synth Pad|Digital";
        
        public static ReadOnlySpan<byte> kSynthPadDigital_u8 => "Synth Pad|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadMotion = "Synth Pad|Motion";
        
        public static ReadOnlySpan<byte> kSynthPadMotion_u8 => "Synth Pad|Motion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadOther = "Synth Pad|Other";
        
        public static ReadOnlySpan<byte> kSynthPadOther_u8 => "Synth Pad|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthComp = "Synth Comp";
        
        public static ReadOnlySpan<byte> kSynthComp_u8 => "Synth Comp\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompAnalog = "Synth Comp|Analog";
        
        public static ReadOnlySpan<byte> kSynthCompAnalog_u8 => "Synth Comp|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompDigital = "Synth Comp|Digital";
        
        public static ReadOnlySpan<byte> kSynthCompDigital_u8 => "Synth Comp|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompOther = "Synth Comp|Other";
        
        public static ReadOnlySpan<byte> kSynthCompOther_u8 => "Synth Comp|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocal = "Vocal";
        
        public static ReadOnlySpan<byte> kVocal_u8 => "Vocal\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalLeadVocal = "Vocal|Lead Vocal";
        
        public static ReadOnlySpan<byte> kVocalLeadVocal_u8 => "Vocal|Lead Vocal\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalAdlibs = "Vocal|Adlibs";
        
        public static ReadOnlySpan<byte> kVocalAdlibs_u8 => "Vocal|Adlibs\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalChoir = "Vocal|Choir";
        
        public static ReadOnlySpan<byte> kVocalChoir_u8 => "Vocal|Choir\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalSolo = "Vocal|Solo";
        
        public static ReadOnlySpan<byte> kVocalSolo_u8 => "Vocal|Solo\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalFX = "Vocal|FX";
        
        public static ReadOnlySpan<byte> kVocalFX_u8 => "Vocal|FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalSpoken = "Vocal|Spoken";
        
        public static ReadOnlySpan<byte> kVocalSpoken_u8 => "Vocal|Spoken\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalOther = "Vocal|Other";
        
        public static ReadOnlySpan<byte> kVocalOther_u8 => "Vocal|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwinds = "Woodwinds";
        
        public static ReadOnlySpan<byte> kWoodwinds_u8 => "Woodwinds\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsEthnic = "Woodwinds|Ethnic";
        
        public static ReadOnlySpan<byte> kWoodwindsEthnic_u8 => "Woodwinds|Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsFlute = "Woodwinds|Flute";
        
        public static ReadOnlySpan<byte> kWoodwindsFlute_u8 => "Woodwinds|Flute\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsOboe = "Woodwinds|Oboe";
        
        public static ReadOnlySpan<byte> kWoodwindsOboe_u8 => "Woodwinds|Oboe\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsEnglHorn = "Woodwinds|Engl. Horn";
        
        public static ReadOnlySpan<byte> kWoodwindsEnglHorn_u8 => "Woodwinds|Engl. Horn\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsClarinet = "Woodwinds|Clarinet";
        
        public static ReadOnlySpan<byte> kWoodwindsClarinet_u8 => "Woodwinds|Clarinet\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsSaxophone = "Woodwinds|Saxophone";
        
        public static ReadOnlySpan<byte> kWoodwindsSaxophone_u8 => "Woodwinds|Saxophone\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsBassoon = "Woodwinds|Bassoon";
        
        public static ReadOnlySpan<byte> kWoodwindsBassoon_u8 => "Woodwinds|Bassoon\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsOther = "Woodwinds|Other";
        
        public static ReadOnlySpan<byte> kWoodwindsOther_u8 => "Woodwinds|Other\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        /// <summary>
        ///  musicalStyle Predefined Musical Style
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public const string kAlternativeIndie = "Alternative/Indie";
        
        /// <summary>
        ///  musicalStyle Predefined Musical Style
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kAlternativeIndie_u8 => "Alternative/Indie\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieGothRock = "Alternative/Indie|Goth Rock";
        
        public static ReadOnlySpan<byte> kAlternativeIndieGothRock_u8 => "Alternative/Indie|Goth Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieGrunge = "Alternative/Indie|Grunge";
        
        public static ReadOnlySpan<byte> kAlternativeIndieGrunge_u8 => "Alternative/Indie|Grunge\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieNewWave = "Alternative/Indie|New Wave";
        
        public static ReadOnlySpan<byte> kAlternativeIndieNewWave_u8 => "Alternative/Indie|New Wave\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndiePunk = "Alternative/Indie|Punk";
        
        public static ReadOnlySpan<byte> kAlternativeIndiePunk_u8 => "Alternative/Indie|Punk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieCollegeRock = "Alternative/Indie|College Rock";
        
        public static ReadOnlySpan<byte> kAlternativeIndieCollegeRock_u8 => "Alternative/Indie|College Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieDarkWave = "Alternative/Indie|Dark Wave";
        
        public static ReadOnlySpan<byte> kAlternativeIndieDarkWave_u8 => "Alternative/Indie|Dark Wave\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieHardcore = "Alternative/Indie|Hardcore";
        
        public static ReadOnlySpan<byte> kAlternativeIndieHardcore_u8 => "Alternative/Indie|Hardcore\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOut = "Ambient/ChillOut";
        
        public static ReadOnlySpan<byte> kAmbientChillOut_u8 => "Ambient/ChillOut\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutNewAgeMeditation = "Ambient/ChillOut|New Age/Meditation";
        
        public static ReadOnlySpan<byte> kAmbientChillOutNewAgeMeditation_u8 => "Ambient/ChillOut|New Age/Meditation\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutDarkAmbient = "Ambient/ChillOut|Dark Ambient";
        
        public static ReadOnlySpan<byte> kAmbientChillOutDarkAmbient_u8 => "Ambient/ChillOut|Dark Ambient\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutDowntempo = "Ambient/ChillOut|Downtempo";
        
        public static ReadOnlySpan<byte> kAmbientChillOutDowntempo_u8 => "Ambient/ChillOut|Downtempo\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutLounge = "Ambient/ChillOut|Lounge";
        
        public static ReadOnlySpan<byte> kAmbientChillOutLounge_u8 => "Ambient/ChillOut|Lounge\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBlues = "Blues";
        
        public static ReadOnlySpan<byte> kBlues_u8 => "Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesAcousticBlues = "Blues|Acoustic Blues";
        
        public static ReadOnlySpan<byte> kBluesAcousticBlues_u8 => "Blues|Acoustic Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesCountryBlues = "Blues|Country Blues";
        
        public static ReadOnlySpan<byte> kBluesCountryBlues_u8 => "Blues|Country Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesElectricBlues = "Blues|Electric Blues";
        
        public static ReadOnlySpan<byte> kBluesElectricBlues_u8 => "Blues|Electric Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesChicagoBlues = "Blues|Chicago Blues";
        
        public static ReadOnlySpan<byte> kBluesChicagoBlues_u8 => "Blues|Chicago Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassical = "Classical";
        
        public static ReadOnlySpan<byte> kClassical_u8 => "Classical\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalBaroque = "Classical|Baroque";
        
        public static ReadOnlySpan<byte> kClassicalBaroque_u8 => "Classical|Baroque\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalChamberMusic = "Classical|Chamber Music";
        
        public static ReadOnlySpan<byte> kClassicalChamberMusic_u8 => "Classical|Chamber Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalMedieval = "Classical|Medieval";
        
        public static ReadOnlySpan<byte> kClassicalMedieval_u8 => "Classical|Medieval\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalModernComposition = "Classical|Modern Composition";
        
        public static ReadOnlySpan<byte> kClassicalModernComposition_u8 => "Classical|Modern Composition\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalOpera = "Classical|Opera";
        
        public static ReadOnlySpan<byte> kClassicalOpera_u8 => "Classical|Opera\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalGregorian = "Classical|Gregorian";
        
        public static ReadOnlySpan<byte> kClassicalGregorian_u8 => "Classical|Gregorian\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalRenaissance = "Classical|Renaissance";
        
        public static ReadOnlySpan<byte> kClassicalRenaissance_u8 => "Classical|Renaissance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalClassic = "Classical|Classic";
        
        public static ReadOnlySpan<byte> kClassicalClassic_u8 => "Classical|Classic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalRomantic = "Classical|Romantic";
        
        public static ReadOnlySpan<byte> kClassicalRomantic_u8 => "Classical|Romantic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalSoundtrack = "Classical|Soundtrack";
        
        public static ReadOnlySpan<byte> kClassicalSoundtrack_u8 => "Classical|Soundtrack\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountry = "Country";
        
        public static ReadOnlySpan<byte> kCountry_u8 => "Country\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryCountryWestern = "Country|Country/Western";
        
        public static ReadOnlySpan<byte> kCountryCountryWestern_u8 => "Country|Country/Western\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryHonkyTonk = "Country|Honky Tonk";
        
        public static ReadOnlySpan<byte> kCountryHonkyTonk_u8 => "Country|Honky Tonk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryUrbanCowboy = "Country|Urban Cowboy";
        
        public static ReadOnlySpan<byte> kCountryUrbanCowboy_u8 => "Country|Urban Cowboy\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryBluegrass = "Country|Bluegrass";
        
        public static ReadOnlySpan<byte> kCountryBluegrass_u8 => "Country|Bluegrass\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryAmericana = "Country|Americana";
        
        public static ReadOnlySpan<byte> kCountryAmericana_u8 => "Country|Americana\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountrySquaredance = "Country|Squaredance";
        
        public static ReadOnlySpan<byte> kCountrySquaredance_u8 => "Country|Squaredance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryNorthAmericanFolk = "Country|North American Folk";
        
        public static ReadOnlySpan<byte> kCountryNorthAmericanFolk_u8 => "Country|North American Folk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDance = "Electronica/Dance";
        
        public static ReadOnlySpan<byte> kElectronicaDance_u8 => "Electronica/Dance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceMinimal = "Electronica/Dance|Minimal";
        
        public static ReadOnlySpan<byte> kElectronicaDanceMinimal_u8 => "Electronica/Dance|Minimal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceClassicHouse = "Electronica/Dance|Classic House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceClassicHouse_u8 => "Electronica/Dance|Classic House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElektroHouse = "Electronica/Dance|Elektro House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElektroHouse_u8 => "Electronica/Dance|Elektro House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceFunkyHouse = "Electronica/Dance|Funky House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceFunkyHouse_u8 => "Electronica/Dance|Funky House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceIndustrial = "Electronica/Dance|Industrial";
        
        public static ReadOnlySpan<byte> kElectronicaDanceIndustrial_u8 => "Electronica/Dance|Industrial\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElectronicBodyMusic = "Electronica/Dance|Electronic Body Music";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElectronicBodyMusic_u8 => "Electronica/Dance|Electronic Body Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTripHop = "Electronica/Dance|Trip Hop";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTripHop_u8 => "Electronica/Dance|Trip Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTechno = "Electronica/Dance|Techno";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTechno_u8 => "Electronica/Dance|Techno\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceDrumNBassJungle = "Electronica/Dance|Drum'n'Bass/Jungle";
        
        public static ReadOnlySpan<byte> kElectronicaDanceDrumNBassJungle_u8 => "Electronica/Dance|Drum'n'Bass/Jungle\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElektro = "Electronica/Dance|Elektro";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElektro_u8 => "Electronica/Dance|Elektro\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTrance = "Electronica/Dance|Trance";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTrance_u8 => "Electronica/Dance|Trance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceDub = "Electronica/Dance|Dub";
        
        public static ReadOnlySpan<byte> kElectronicaDanceDub_u8 => "Electronica/Dance|Dub\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceBigBeats = "Electronica/Dance|Big Beats";
        
        public static ReadOnlySpan<byte> kElectronicaDanceBigBeats_u8 => "Electronica/Dance|Big Beats\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimental = "Experimental";
        
        public static ReadOnlySpan<byte> kExperimental_u8 => "Experimental\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalNewMusic = "Experimental|New Music";
        
        public static ReadOnlySpan<byte> kExperimentalNewMusic_u8 => "Experimental|New Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalFreeImprovisation = "Experimental|Free Improvisation";
        
        public static ReadOnlySpan<byte> kExperimentalFreeImprovisation_u8 => "Experimental|Free Improvisation\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalElectronicArtMusic = "Experimental|Electronic Art Music";
        
        public static ReadOnlySpan<byte> kExperimentalElectronicArtMusic_u8 => "Experimental|Electronic Art Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalNoise = "Experimental|Noise";
        
        public static ReadOnlySpan<byte> kExperimentalNoise_u8 => "Experimental|Noise\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazz = "Jazz";
        
        public static ReadOnlySpan<byte> kJazz_u8 => "Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzNewOrleansJazz = "Jazz|New Orleans Jazz";
        
        public static ReadOnlySpan<byte> kJazzNewOrleansJazz_u8 => "Jazz|New Orleans Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzTraditionalJazz = "Jazz|Traditional Jazz";
        
        public static ReadOnlySpan<byte> kJazzTraditionalJazz_u8 => "Jazz|Traditional Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzOldtimeJazzDixiland = "Jazz|Oldtime Jazz/Dixiland";
        
        public static ReadOnlySpan<byte> kJazzOldtimeJazzDixiland_u8 => "Jazz|Oldtime Jazz/Dixiland\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzFusion = "Jazz|Fusion";
        
        public static ReadOnlySpan<byte> kJazzFusion_u8 => "Jazz|Fusion\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzAvantgarde = "Jazz|Avantgarde";
        
        public static ReadOnlySpan<byte> kJazzAvantgarde_u8 => "Jazz|Avantgarde\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzLatinJazz = "Jazz|Latin Jazz";
        
        public static ReadOnlySpan<byte> kJazzLatinJazz_u8 => "Jazz|Latin Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzFreeJazz = "Jazz|Free Jazz";
        
        public static ReadOnlySpan<byte> kJazzFreeJazz_u8 => "Jazz|Free Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzRagtime = "Jazz|Ragtime";
        
        public static ReadOnlySpan<byte> kJazzRagtime_u8 => "Jazz|Ragtime\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPop = "Pop";
        
        public static ReadOnlySpan<byte> kPop_u8 => "Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopBritpop = "Pop|Britpop";
        
        public static ReadOnlySpan<byte> kPopBritpop_u8 => "Pop|Britpop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopRock = "Pop|Pop/Rock";
        
        public static ReadOnlySpan<byte> kPopRock_u8 => "Pop|Pop/Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopTeenPop = "Pop|Teen Pop";
        
        public static ReadOnlySpan<byte> kPopTeenPop_u8 => "Pop|Teen Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopChartDance = "Pop|Chart Dance";
        
        public static ReadOnlySpan<byte> kPopChartDance_u8 => "Pop|Chart Dance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPop80sPop = "Pop|80's Pop";
        
        public static ReadOnlySpan<byte> kPop80sPop_u8 => "Pop|80's Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopDancehall = "Pop|Dancehall";
        
        public static ReadOnlySpan<byte> kPopDancehall_u8 => "Pop|Dancehall\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopDisco = "Pop|Disco";
        
        public static ReadOnlySpan<byte> kPopDisco_u8 => "Pop|Disco\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetal = "Rock/Metal";
        
        public static ReadOnlySpan<byte> kRockMetal_u8 => "Rock/Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalBluesRock = "Rock/Metal|Blues Rock";
        
        public static ReadOnlySpan<byte> kRockMetalBluesRock_u8 => "Rock/Metal|Blues Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalClassicRock = "Rock/Metal|Classic Rock";
        
        public static ReadOnlySpan<byte> kRockMetalClassicRock_u8 => "Rock/Metal|Classic Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalHardRock = "Rock/Metal|Hard Rock";
        
        public static ReadOnlySpan<byte> kRockMetalHardRock_u8 => "Rock/Metal|Hard Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalRockRoll = "Rock/Metal|Rock &amp; Roll";
        
        public static ReadOnlySpan<byte> kRockMetalRockRoll_u8 => "Rock/Metal|Rock &amp; Roll\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalSingerSongwriter = "Rock/Metal|Singer/Songwriter";
        
        public static ReadOnlySpan<byte> kRockMetalSingerSongwriter_u8 => "Rock/Metal|Singer/Songwriter\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalHeavyMetal = "Rock/Metal|Heavy Metal";
        
        public static ReadOnlySpan<byte> kRockMetalHeavyMetal_u8 => "Rock/Metal|Heavy Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalDeathBlackMetal = "Rock/Metal|Death/Black Metal";
        
        public static ReadOnlySpan<byte> kRockMetalDeathBlackMetal_u8 => "Rock/Metal|Death/Black Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalNuMetal = "Rock/Metal|NuMetal";
        
        public static ReadOnlySpan<byte> kRockMetalNuMetal_u8 => "Rock/Metal|NuMetal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalReggae = "Rock/Metal|Reggae";
        
        public static ReadOnlySpan<byte> kRockMetalReggae_u8 => "Rock/Metal|Reggae\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalBallad = "Rock/Metal|Ballad";
        
        public static ReadOnlySpan<byte> kRockMetalBallad_u8 => "Rock/Metal|Ballad\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalAlternativeRock = "Rock/Metal|Alternative Rock";
        
        public static ReadOnlySpan<byte> kRockMetalAlternativeRock_u8 => "Rock/Metal|Alternative Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalRockabilly = "Rock/Metal|Rockabilly";
        
        public static ReadOnlySpan<byte> kRockMetalRockabilly_u8 => "Rock/Metal|Rockabilly\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalThrashMetal = "Rock/Metal|Thrash Metal";
        
        public static ReadOnlySpan<byte> kRockMetalThrashMetal_u8 => "Rock/Metal|Thrash Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalProgressiveRock = "Rock/Metal|Progressive Rock";
        
        public static ReadOnlySpan<byte> kRockMetalProgressiveRock_u8 => "Rock/Metal|Progressive Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRB = "Urban (Hip-Hop / R&B)";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRB_u8 => "Urban (Hip-Hop / R&B)\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBClassic = "Urban (Hip-Hop / R&B)|Classic R&B";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBClassic_u8 => "Urban (Hip-Hop / R&B)|Classic R&B\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBModern = "Urban (Hip-Hop / R&B)|Modern R&B";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBModern_u8 => "Urban (Hip-Hop / R&B)|Modern R&B\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBPop = "Urban (Hip-Hop / R&B)|R&B Pop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBPop_u8 => "Urban (Hip-Hop / R&B)|R&B Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBWestCoastHipHop = "Urban (Hip-Hop / R&B)|WestCoast Hip-Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBWestCoastHipHop_u8 => "Urban (Hip-Hop / R&B)|WestCoast Hip-Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBEastCoastHipHop = "Urban (Hip-Hop / R&B)|EastCoast Hip-Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBEastCoastHipHop_u8 => "Urban (Hip-Hop / R&B)|EastCoast Hip-Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBRapHipHop = "Urban (Hip-Hop / R&B)|Rap/Hip Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBRapHipHop_u8 => "Urban (Hip-Hop / R&B)|Rap/Hip Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBSoul = "Urban (Hip-Hop / R&B)|Soul";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBSoul_u8 => "Urban (Hip-Hop / R&B)|Soul\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBFunk = "Urban (Hip-Hop / R&B)|Funk";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBFunk_u8 => "Urban (Hip-Hop / R&B)|Funk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnic = "World/Ethnic";
        
        public static ReadOnlySpan<byte> kWorldEthnic_u8 => "World/Ethnic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAfrica = "World/Ethnic|Africa";
        
        public static ReadOnlySpan<byte> kWorldEthnicAfrica_u8 => "World/Ethnic|Africa\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAsia = "World/Ethnic|Asia";
        
        public static ReadOnlySpan<byte> kWorldEthnicAsia_u8 => "World/Ethnic|Asia\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicCeltic = "World/Ethnic|Celtic";
        
        public static ReadOnlySpan<byte> kWorldEthnicCeltic_u8 => "World/Ethnic|Celtic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicEurope = "World/Ethnic|Europe";
        
        public static ReadOnlySpan<byte> kWorldEthnicEurope_u8 => "World/Ethnic|Europe\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicKlezmer = "World/Ethnic|Klezmer";
        
        public static ReadOnlySpan<byte> kWorldEthnicKlezmer_u8 => "World/Ethnic|Klezmer\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicScandinavia = "World/Ethnic|Scandinavia";
        
        public static ReadOnlySpan<byte> kWorldEthnicScandinavia_u8 => "World/Ethnic|Scandinavia\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicEasternEurope = "World/Ethnic|Eastern Europe";
        
        public static ReadOnlySpan<byte> kWorldEthnicEasternEurope_u8 => "World/Ethnic|Eastern Europe\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicIndiaOriental = "World/Ethnic|India/Oriental";
        
        public static ReadOnlySpan<byte> kWorldEthnicIndiaOriental_u8 => "World/Ethnic|India/Oriental\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicNorthAmerica = "World/Ethnic|North America";
        
        public static ReadOnlySpan<byte> kWorldEthnicNorthAmerica_u8 => "World/Ethnic|North America\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicSouthAmerica = "World/Ethnic|South America";
        
        public static ReadOnlySpan<byte> kWorldEthnicSouthAmerica_u8 => "World/Ethnic|South America\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAustralia = "World/Ethnic|Australia";
        
        public static ReadOnlySpan<byte> kWorldEthnicAustralia_u8 => "World/Ethnic|Australia\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        ///  musicalCharacter Predefined Musical Character
        /// </summary>
        /// <remarks>
        /// @
        /// {----TYPE------------------------------------
        /// </remarks>
        public const string kMono = "Mono";
        
        /// <summary>
        ///  musicalCharacter Predefined Musical Character
        /// </summary>
        /// <remarks>
        /// @
        /// {----TYPE------------------------------------
        /// </remarks>
        public static ReadOnlySpan<byte> kMono_u8 => "Mono\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kPoly = "Poly";
        
        public static ReadOnlySpan<byte> kPoly_u8 => "Poly\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSplit = "Split";
        
        public static ReadOnlySpan<byte> kSplit_u8 => "Split\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLayer = "Layer";
        
        public static ReadOnlySpan<byte> kLayer_u8 => "Layer\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlide = "Glide";
        
        public static ReadOnlySpan<byte> kGlide_u8 => "Glide\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlissando = "Glissando";
        
        public static ReadOnlySpan<byte> kGlissando_u8 => "Glissando\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMajor = "Major";
        
        public static ReadOnlySpan<byte> kMajor_u8 => "Major\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMinor = "Minor";
        
        public static ReadOnlySpan<byte> kMinor_u8 => "Minor\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSingle = "Single";
        
        public static ReadOnlySpan<byte> kSingle_u8 => "Single\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kEnsemble = "Ensemble";
        
        public static ReadOnlySpan<byte> kEnsemble_u8 => "Ensemble\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAcoustic = "Acoustic";
        
        public static ReadOnlySpan<byte> kAcoustic_u8 => "Acoustic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kElectric = "Electric";
        
        public static ReadOnlySpan<byte> kElectric_u8 => "Electric\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAnalog = "Analog";
        
        public static ReadOnlySpan<byte> kAnalog_u8 => "Analog\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDigital = "Digital";
        
        public static ReadOnlySpan<byte> kDigital_u8 => "Digital\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kVintage = "Vintage";
        
        public static ReadOnlySpan<byte> kVintage_u8 => "Vintage\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kModern = "Modern";
        
        public static ReadOnlySpan<byte> kModern_u8 => "Modern\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kOld = "Old";
        
        public static ReadOnlySpan<byte> kOld_u8 => "Old\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kNew = "New";
        
        public static ReadOnlySpan<byte> kNew_u8 => "New\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        /// ----TONE------------------------------------
        /// </summary>
        public const string kClean = "Clean";
        
        /// <summary>
        /// ----TONE------------------------------------
        /// </summary>
        public static ReadOnlySpan<byte> kClean_u8 => "Clean\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDistorted = "Distorted";
        
        public static ReadOnlySpan<byte> kDistorted_u8 => "Distorted\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDry = "Dry";
        
        public static ReadOnlySpan<byte> kDry_u8 => "Dry\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kProcessed = "Processed";
        
        public static ReadOnlySpan<byte> kProcessed_u8 => "Processed\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kHarmonic = "Harmonic";
        
        public static ReadOnlySpan<byte> kHarmonic_u8 => "Harmonic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDissonant = "Dissonant";
        
        public static ReadOnlySpan<byte> kDissonant_u8 => "Dissonant\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kClear = "Clear";
        
        public static ReadOnlySpan<byte> kClear_u8 => "Clear\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kNoisy = "Noisy";
        
        public static ReadOnlySpan<byte> kNoisy_u8 => "Noisy\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kThin = "Thin";
        
        public static ReadOnlySpan<byte> kThin_u8 => "Thin\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kRich = "Rich";
        
        public static ReadOnlySpan<byte> kRich_u8 => "Rich\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDark = "Dark";
        
        public static ReadOnlySpan<byte> kDark_u8 => "Dark\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kBright = "Bright";
        
        public static ReadOnlySpan<byte> kBright_u8 => "Bright\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kCold = "Cold";
        
        public static ReadOnlySpan<byte> kCold_u8 => "Cold\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kWarm = "Warm";
        
        public static ReadOnlySpan<byte> kWarm_u8 => "Warm\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMetallic = "Metallic";
        
        public static ReadOnlySpan<byte> kMetallic_u8 => "Metallic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kWooden = "Wooden";
        
        public static ReadOnlySpan<byte> kWooden_u8 => "Wooden\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlass = "Glass";
        
        public static ReadOnlySpan<byte> kGlass_u8 => "Glass\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kPlastic = "Plastic";
        
        public static ReadOnlySpan<byte> kPlastic_u8 => "Plastic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        /// ----ENVELOPE------------------------------------
        /// </summary>
        public const string kPercussive = "Percussive";
        
        /// <summary>
        /// ----ENVELOPE------------------------------------
        /// </summary>
        public static ReadOnlySpan<byte> kPercussive_u8 => "Percussive\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSoft = "Soft";
        
        public static ReadOnlySpan<byte> kSoft_u8 => "Soft\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kFast = "Fast";
        
        public static ReadOnlySpan<byte> kFast_u8 => "Fast\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSlow = "Slow";
        
        public static ReadOnlySpan<byte> kSlow_u8 => "Slow\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kShort = "Short";
        
        public static ReadOnlySpan<byte> kShort_u8 => "Short\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLong = "Long";
        
        public static ReadOnlySpan<byte> kLong_u8 => "Long\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAttack = "Attack";
        
        public static ReadOnlySpan<byte> kAttack_u8 => "Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kRelease = "Release";
        
        public static ReadOnlySpan<byte> kRelease_u8 => "Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDecay = "Decay";
        
        public static ReadOnlySpan<byte> kDecay_u8 => "Decay\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSustain = "Sustain";
        
        public static ReadOnlySpan<byte> kSustain_u8 => "Sustain\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kFastAttack = "Fast Attack";
        
        public static ReadOnlySpan<byte> kFastAttack_u8 => "Fast Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSlowAttack = "Slow Attack";
        
        public static ReadOnlySpan<byte> kSlowAttack_u8 => "Slow Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kShortRelease = "Short Release";
        
        public static ReadOnlySpan<byte> kShortRelease_u8 => "Short Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLongRelease = "Long Release";
        
        public static ReadOnlySpan<byte> kLongRelease_u8 => "Long Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kStatic = "Static";
        
        public static ReadOnlySpan<byte> kStatic_u8 => "Static\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMoving = "Moving";
        
        public static ReadOnlySpan<byte> kMoving_u8 => "Moving\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLoop = "Loop";
        
        public static ReadOnlySpan<byte> kLoop_u8 => "Loop\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kOneShot = "One Shot";
        
        public static ReadOnlySpan<byte> kOneShot_u8 => "One Shot\0"u8;
    }
}
